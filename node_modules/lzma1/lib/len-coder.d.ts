import { type BitTree } from "./utils.js";
/**
 * Range encoder interface for LenEncoder to communicate with
 */
export interface RangeEncoder {
    encodeBit(probs: number[], index: number, symbol: number): void;
    encodeBitTree(encoder: BitTree, symbol: number): void;
}
/**
 * Length encoder class for LZMA compression
 * Handles encoding of match lengths with price optimization
 */
export declare class LenEncoder {
    private choice;
    private lowCoder;
    private midCoder;
    private highCoder;
    private tableSize;
    private prices;
    private counters;
    constructor();
    /**
     * Initialize the encoder with specified number of position states
     */
    init(numPosStates: number): void;
    /**
     * Encode a length value using the provided range encoder
     */
    encode(symbol: number, posState: number, rangeEncoder: RangeEncoder): void;
    /**
     * Encode with price table update
     */
    encodeWithUpdate(symbol: number, posState: number, rangeEncoder: RangeEncoder): void;
    /**
     * Get price for encoding a symbol at the given position state
     */
    getPrice(symbol: number, posState: number): number;
    /**
     * Initialize as a price table encoder
     */
    initPriceTable(): void;
    /**
     * Set table size for price optimization
     */
    setTableSize(size: number): void;
    /**
     * Set table size and update internal counters
     */
    setTableSizeAndInitCounters(size: number, numPosStates: number): void;
    /**
     * Get table size
     */
    getTableSize(): number;
    /**
     * Update price tables for all position states
     */
    updateTables(numPosStates: number): void;
    /**
     * Calculate price for bit tree encoder
     */
    private getBitTreePrice;
    /**
     * Get price for a single bit
     */
    private getBitPrice;
    /**
     * Set prices for all symbols in a position state range
     */
    private setPrices;
}
