export interface BitTree {
    numBitLevels: number;
    models: number[];
}
/**
 * Literal decoder/encoder for optimization
 */
export interface LiteralDecoderEncoder2 {
    decoders: number[];
}
/**
 * Basic range encoder interface for bit operations
 */
export interface BasicRangeEncoder {
    encodeBit(probs: number[], index: number, bit: number): void;
}
/**
 * Basic range decoder interface for bit operations
 */
export interface BasicRangeDecoder {
    decodeBit(probs: number[], index: number): number;
}
export declare const INFINITY_PRICE = 268435455;
export declare const _MAX_UINT32 = 4294967295;
export declare const DICTIONARY_SIZE_THRESHOLD = 1073741823;
export declare const kTopValue: number;
export declare const kNumBitModelTotalBits = 11;
export declare const kBitModelTotal: number;
export declare const kNumMoveBits = 5;
export declare const kNumMoveReducingBits = 2;
export declare const kNumBitPriceShiftBits = 6;
export declare const MATCH_DECODERS_SIZE = 192;
export declare const REP_DECODERS_SIZE = 12;
export declare const POS_DECODERS_SIZE = 114;
export declare const LITERAL_DECODER_SIZE = 768;
export declare const DEFAULT_WINDOW_SIZE = 4096;
export declare const CHOICE_ARRAY_SIZE = 2;
export declare const N1_LONG_LIT: [number, number];
export declare const MIN_VALUE: [number, number];
export declare const P0_LONG_LIT: [number, number];
export declare const P1_LONG_LIT: [number, number];
export declare const ZERO_64: [number, number];
/**
 * CRC32 lookup table for hash calculations
 * dprint-ignore
 */
export declare const CRC32_TABLE: number[];
/**
 * Pre-computed static instances for common use
 */
export declare const PROB_PRICES: number[];
export declare const G_FAST_POS: number[];
/**
 * Initialize array with specified length and default value
 * This is MUCH faster than "new Array(len)" in newer versions of v8
 * (starting with Node.js 0.11.15, which uses v8 3.28.73).
 */
export declare function initArray(len: number, value?: number): number[];
/**
 * Copy array data with bounds checking and overlap handling
 */
export declare function arraycopy(src: number[], srcOfs: number, dest: number[], destOfs: number, len: number): void;
/**
 * Get bit price using pre-computed probability prices
 */
export declare function getBitPrice(probability: number, bit: number): number;
/**
 * Create a 64-bit number from low and high parts
 */
export declare function create64(valueLow: number, valueHigh: number): [number, number];
/**
 * Add two 64-bit numbers
 */
export declare function add64(a: [number, number], b: [number, number]): [number, number];
/**
 * Subtract two 64-bit numbers
 */
export declare function sub64(a: [number, number], b: [number, number]): [number, number];
/**
 * Compare two 64-bit numbers
 */
export declare function compare64(a: [number, number], b: [number, number]): 0 | 1 | -1;
/**
 * Extract low bits from 64-bit number
 */
export declare function lowBits64(a: [number, number]): number;
/**
 * Create 64-bit number from integer
 */
export declare function fromInt64(value: number): [number, number];
/**
 * Right shift 64-bit number
 */
export declare function shr64(a: [number, number], n: number): [number, number];
/**
 * Bit model operations
 */
/**
 * Initialize bit models with default probability
 */
export declare function initBitModels(probs: number[]): void;
/**
 * Position and state operations
 */
/**
 * Get length to position state mapping
 */
export declare function getLenToPosState(len: number): number;
/**
 * Update state after character encoding/decoding
 */
export declare function stateUpdateChar(index: number): number;
/**
 * Bit tree operations
 */
/**
 * Create a bit tree with specified number of bit levels
 */
export declare function createBitTree(numBitLevels: number): BitTree;
/**
 * Create probability prices lookup table
 */
export declare function createProbPrices(): number[];
/**
 * Create fast position lookup table
 */
export declare function createFastPos(): number[];
