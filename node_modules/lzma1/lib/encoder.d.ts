import { LenEncoder, type RangeEncoder as LenRangeEncoder } from "./len-coder.js";
import { LitCoder } from "./lit-coder.js";
import type { BaseStream } from "./streams.js";
import type { LiteralDecoderEncoder2 } from "./utils.js";
import { type BitTree } from "./utils.js";
export interface MatchFinder {
    _posLimit: number;
    _bufferBase: number[];
    _pos: number;
    _streamPos: number;
    _streamEndWasReached: number;
    _bufferOffset: number;
    _blockSize: number;
    _keepSizeBefore: number;
    _keepSizeAfter: number;
    _pointerToLastSafePosition: number;
    _stream: BaseStream | null;
    HASH_ARRAY: boolean;
    kNumHashDirectBytes: number;
    kMinMatchCheck: number;
    kFixHashSize: number;
    _hashMask: number;
    _hashSizeSum: number;
    _hash: number[];
    _cyclicBufferSize: number;
    _cyclicBufferPos: number;
    _son: number[];
    _matchMaxLen: number;
    _cutValue: number;
}
export interface Optimum {
    state?: number;
    price?: number;
    posPrev?: number;
    backPrev?: number;
    prev1IsChar?: number;
    prev2?: number;
    posPrev2?: number;
    backPrev2?: number;
    backs0?: number;
    backs1?: number;
    backs2?: number;
    backs3?: number;
}
interface RangeEncoder {
    stream: {
        buf: number[];
        count: number;
    } | null;
    rrange: number;
    cache: number;
    low: [number, number];
    cacheSize: number;
    position: [number, number];
    encodeBit(probs: number[], index: number, bit: number): void;
    encodeBitTree(tree: BitTree, symbol: number): void;
    encodeDirectBits(value: number, bits: number): void;
}
/**
 * LZMA Encoder class that handles compression operations
 */
export declare class Encoder implements LenRangeEncoder {
    private encoderState;
    private positionEncoder;
    _state: number;
    _previousByte: number;
    _distTableSize: number;
    _longestMatchWasFound: number;
    _optimumEndIndex: number;
    _optimumCurrentIndex: number;
    _additionalOffset: number;
    _dictionarySize: number;
    _matchFinder: MatchFinder | null;
    _dictionarySizePrev: number;
    _numFastBytes: number;
    _numLiteralContextBits: number;
    _numLiteralPosStateBits: number;
    _posStateBits: number;
    _posStateMask: number;
    _needReleaseMFStream: number;
    _inStream: BaseStream | null;
    _finished: number;
    nowPos64: [number, number];
    _repDistances: number[];
    _optimum: Optimum[];
    _rangeEncoder: RangeEncoder;
    _isMatch: number[];
    _isRep: number[];
    _isRepG0: number[];
    _isRepG1: number[];
    _isRepG2: number[];
    _isRep0Long: number[];
    _posSlotEncoder: BitTree[];
    _posEncoders: number[];
    _posAlignEncoder: BitTree | null;
    _lenEncoder: LenEncoder | null;
    _repMatchLenEncoder: LenEncoder | null;
    _literalEncoder: LitCoder | null;
    _matchDistances: number[];
    _posSlotPrices: number[];
    _distancesPrices: number[];
    _alignPrices: number[];
    _matchPriceCount: number;
    _alignPriceCount: number;
    reps: number[];
    repLens: number[];
    processedInSize: [number, number][];
    processedOutSize: [number, number][];
    finished: number[];
    properties: number[];
    tempPrices: number[];
    _longestMatchLength: number;
    _matchFinderType: number;
    _numDistancePairs: number;
    _numFastBytesPrev: number;
    backRes: number;
    constructor();
    /**
     * Initialize basic encoder state
     */
    baseInit(): void;
    /**
     * Get optimum array
     */
    getOptimum(): Optimum[];
    /**
     * Get back result
     */
    getBackRes(): number;
    setBackRes(backRes: number): void;
    init(): void;
    /**
     * Initialize encoder range coder
     */
    initEncoderState(): void;
    /**
     * Initialize literal encoder
     */
    initLiteralEncoder(): void;
    /**
     * Create optimum structures
     */
    createOptimumStructures(): void;
    /**
     * Create length price table encoder
     */
    createLenPriceTableEncoder(): LenEncoder;
    /**
     * Create literal encoder encoder2
     */
    createLiteralEncoderEncoder2(): LiteralDecoderEncoder2;
    /**
     * Create literal encoder
     */
    createLiteralEncoder(): void;
    /**
     * Initialize completely with proper encoder state
     */
    initialize(): void;
    /**
     * Configure encoder settings
     */
    configure(mode: {
        searchDepth: number;
        filterStrength: number;
        modeIndex: number;
    }): void;
    /**
     * Set dictionary size
     */
    setDictionarySize(dictionarySize: number): void;
    /**
     * Encode a bit using range coder
     */
    encodeBit(probs: number[], index: number, symbol: number): void;
    /**
     * Encode bit tree
     */
    encodeBitTree(encoder: BitTree, symbol: number): void;
    /**
     * Encode literal
     */
    encodeLiteral(encoder: LiteralDecoderEncoder2, symbol: number): void;
    /**
     * Encode matched literal
     */
    encodeMatched(encoder: LiteralDecoderEncoder2, matchByte: number, symbol: number): void;
    /**
     * Encode length using direct method calls
     */
    encodeLength(encoder: LenEncoder, symbol: number, posState: number): void;
    /**
     * Encode direct bits
     */
    encodeDirectBits(valueToEncode: number, numTotalBits: number): void;
    /**
     * Reverse encode
     */
    reverseEncode(symbol: number): void;
    /**
     * Reverse encode range
     */
    reverseEncodeRange(startIndex: number, numBitLevels: number, symbol: number): void;
    /**
     * Write end marker
     */
    writeEndMarker(positionState: number): void;
    /**
     * Encode length with price table update
     */
    encodeLengthWithPriceUpdate(encoder: LenEncoder, symbol: number, posState: number): void;
    private and64;
    private shru64;
    private shl64;
    private pwrAsDouble;
    /**
     * Shift low helper (proper implementation) - public method for external access
     */
    shiftLow(): void;
    /**
     * Write byte to stream
     */
    private writeToStream;
    initRangeEncoder(): void;
    /**
     * Fill alignment prices for position alignment encoder
     */
    fillAlignPrices(): void;
    /**
     * Fill distance prices for position encoders
     */
    fillDistancesPrices(): void;
    /**
     * Get position slot for a distance value
     */
    getPosSlot(pos: number): number;
    /**
     * Get reverse price for bit tree encoder
     */
    reverseGetPrice(encoder: BitTree, symbol: number): number;
    /**
     * Get reverse price for array of models
     */
    reverseGetPriceArray(Models: number[], startIndex: number, NumBitLevels: number, symbol: number): number;
    /**
     * Get price for probability model (optimized)
     */
    getPrice(Prob: number, symbol: number): number;
    /**
     * Get price for bit tree encoder (optimized)
     */
    rangeCoder_Encoder_GetPrice_1(encoder: BitTree, symbol: number): number;
    /**
     * Create encoder optimization structures (optimized)
     */
    createEncoderStructures(): void;
    /**
     * Create match finder and encoder structures (replaces #Create_2)
     */
    createMatchFinderAndStructures(): void;
    /**
     * Get literal encoder subcoder (utility method)
     */
    getSubCoderUtility(pos: number, prevByte: number): LiteralDecoderEncoder2;
}
export {};
