import { compare64, P0_LONG_LIT, } from "./utils.js";
/**
 * Encoder chunker for handling compression chunk processing
 */
export class EncoderChunker {
    encoder = null;
    decoder = null;
    alive = 0;
    inBytesProcessed = [0, 0];
    lzma;
    constructor(lzma) {
        this.lzma = lzma;
    }
    /**
     * Process one chunk of encoding
     */
    processChunk() {
        if (!this.alive) {
            throw new Error("bad state");
        }
        if (!this.encoder) {
            throw new Error("No decoding");
        }
        this.lzma.codeOneBlock();
        this.inBytesProcessed = this.encoder.processedInSize[0];
        if (this.encoder.finished[0]) {
            this.lzma.releaseStreams();
            this.alive = 0;
        }
        return this.alive;
    }
}
/**
 * Decoder chunker for handling decompression chunk processing
 */
export class DecoderChunker {
    encoder = null;
    decoder;
    alive = 0;
    inBytesProcessed = [0, 0];
    constructor(decoder) {
        this.decoder = decoder;
    }
    /**
     * Process one chunk of decoding
     */
    processChunk() {
        if (!this.alive) {
            throw new Error("Bad state");
        }
        if (this.encoder) {
            throw new Error("No encoding");
        }
        const result = this.decoder.codeOneChunk();
        if (result === -1) {
            throw new Error("Corrupted input");
        }
        this.inBytesProcessed = this.decoder.nowPos64;
        const isOutputComplete = (compare64(this.decoder.outSize, P0_LONG_LIT) >= 0)
            && (compare64(this.decoder.nowPos64, this.decoder.outSize) >= 0);
        if (result || isOutputComplete) {
            this.decoder.flush();
            this.decoder.cleanup();
            this.alive = 0;
        }
        return this.alive;
    }
}
