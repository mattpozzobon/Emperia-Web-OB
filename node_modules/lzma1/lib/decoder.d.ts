import { LzOutWindow } from "./lz-window.js";
import { RangeDecoder } from "./range-decoder.js";
import type { BaseStream, BufferWithCount } from "./streams.js";
import { type BitTree } from "./utils.js";
interface LenDecoder {
    choice: number[];
    lowCoder: BitTree[];
    midCoder: BitTree[];
    highCoder: BitTree;
    numPosStates: number;
}
interface LiteralCoder {
    coders: any[];
    numPrevBits: number;
    numPosBits: number;
    posMask: number;
    init?(): void;
}
export declare class Decoder {
    rangeDecoder: RangeDecoder;
    outWindow: LzOutWindow;
    state: number;
    rep0: number;
    rep1: number;
    rep2: number;
    rep3: number;
    prevByte: number;
    nowPos64: [number, number];
    outSize: [number, number];
    posStateMask: number;
    dictSizeCheck: number;
    matchDecoders: number[];
    rep0LongDecoders: number[];
    repDecoders: number[];
    repG0Decoders: number[];
    repG1Decoders: number[];
    repG2Decoders: number[];
    posDecoders: number[];
    literalDecoder: LiteralCoder;
    posSlotDecoders: BitTree[];
    lenDecoder: LenDecoder;
    repLenDecoder: LenDecoder;
    posAlignDecoder: BitTree;
    get literalCoder(): LiteralCoder;
    decoder: Decoder;
    encoder: null;
    alive: number;
    inBytesProcessed: [number, number];
    constructor();
    createLenDecoder(): LenDecoder;
    setDecoderProperties(properties: number[]): boolean;
    copyBlock(len: number): void;
    putByte(b: number): void;
    getByte(distance: number): number;
    getDecoder(pos: number, prevByte: number): any;
    initLiteralDecoder(): void;
    init(): void;
    initLenDecoder(decoder: LenDecoder): void;
    outWindowReleaseStream(): void;
    decodeBit(probs: number[], index: number): 0 | 1;
    decodeDirectBits(numTotalBits: number): number;
    initRangeDecoder(): void;
    rangeBitTreeDecoder(bitTree: BitTree): number;
    reverseDecode(models: number[], startIndex: number, numBitLevels: number): number;
    reverseDecodeAlignDecoder(): number;
    decodeNormalWithRangeDecoder(decoder: any): number;
    decodeWithMatchByteWithRangeDecoder(encoder: any, matchByte: number): number;
    decodeLenWithRangeDecoder(decoder: LenDecoder, posState: number): number;
    codeOneChunk(): 0 | 1 | -1;
    setupForDecoding(inStream: BaseStream, outSize: [number, number], outputBuffer: BufferWithCount): void;
    processChunk(): number;
    writeToOutput(buffer: BufferWithCount, data: number[], offset: number, length: number): void;
    private isBufferWithCount;
    flush(): void;
    /**
     * Cleanup decoder resources
     */
    cleanup(): void;
}
export {};
