{
  "version": 3,
  "sources": ["../../lzma1/lib/utils.js", "../../lzma1/lib/chunker.js", "../../lzma1/lib/lz-window.js", "../../lzma1/lib/range-decoder.js", "../../lzma1/lib/decoder.js", "../../lzma1/lib/len-coder.js", "../../lzma1/lib/lit-coder.js", "../../lzma1/lib/encoder.js", "../../lzma1/lib/lz-in-window.js", "../../lzma1/lib/match-finder-config.js", "../../lzma1/lib/lzma.js", "../../lzma1/lib/index.js"],
  "sourcesContent": ["// Constants for 64-bit arithmetic\nconst MAX_UINT32 = 0x100000000;\nconst MAX_INT32 = 0x7FFFFFFF;\nconst MIN_INT32 = -0x80000000;\n// Additional LZMA constants\nexport const INFINITY_PRICE = 0xFFFFFFF;\nexport const _MAX_UINT32 = 0xFFFFFFFF;\nexport const DICTIONARY_SIZE_THRESHOLD = 0x3FFFFFFF;\n// Range coder constants\nexport const kTopValue = 1 << 24;\nexport const kNumBitModelTotalBits = 11;\nexport const kBitModelTotal = 1 << kNumBitModelTotalBits;\nexport const kNumMoveBits = 5;\nexport const kNumMoveReducingBits = 2;\nexport const kNumBitPriceShiftBits = 6;\n// Common array sizes used throughout LZMA implementation\nexport const MATCH_DECODERS_SIZE = 0xC0; // 192\nexport const REP_DECODERS_SIZE = 12;\nexport const POS_DECODERS_SIZE = 114;\nexport const LITERAL_DECODER_SIZE = 0x300; // 768\nexport const DEFAULT_WINDOW_SIZE = 0x1000; // 4096\nexport const CHOICE_ARRAY_SIZE = 2;\n// Special 64-bit number constants\nexport const N1_LONG_LIT = [0xFFFFFFFF, -MAX_UINT32];\nexport const MIN_VALUE = [0, -0x8000000000000000];\nexport const P0_LONG_LIT = [0, 0];\nexport const P1_LONG_LIT = [1, 0];\nexport const ZERO_64 = [0, 0];\n/**\n * CRC32 lookup table for hash calculations\n * dprint-ignore\n */\nexport const CRC32_TABLE = [\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,\n    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,\n    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,\n    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,\n    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,\n    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,\n    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,\n    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,\n    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,\n    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,\n    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,\n    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,\n    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,\n    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,\n    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,\n    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,\n    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,\n    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,\n    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,\n    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,\n    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,\n    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n];\n/**\n * Pre-computed static instances for common use\n */\nexport const PROB_PRICES = createProbPrices();\nexport const G_FAST_POS = createFastPos();\n/**\n * Initialize array with specified length and default value\n * This is MUCH faster than \"new Array(len)\" in newer versions of v8\n * (starting with Node.js 0.11.15, which uses v8 3.28.73).\n */\nexport function initArray(len, value = 0) {\n    const array = [];\n    // Pre-allocate array by setting the last index\n    array[len - 1] = undefined;\n    // Fill with specified value if needed\n    if (value !== 0) {\n        for (let i = 0; i < len; i++) {\n            array[i] = value;\n        }\n    }\n    return array;\n}\n/**\n * Copy array data with bounds checking and overlap handling\n */\nexport function arraycopy(src, srcOfs, dest, destOfs, len) {\n    // Bounds checking\n    if (srcOfs < 0\n        || destOfs < 0\n        || len < 0\n        || srcOfs + len > src.length\n        || destOfs + len > dest.length) {\n        return;\n    }\n    if (src === dest\n        && srcOfs < destOfs\n        && destOfs < srcOfs + len) {\n        // Overlapping regions - copy backwards\n        for (let i = len - 1; i >= 0; i--) {\n            dest[destOfs + i] = src[srcOfs + i];\n        }\n    }\n    else {\n        // Non-overlapping or safe regions - copy forward\n        for (let i = 0; i < len; i++) {\n            dest[destOfs + i] = src[srcOfs + i];\n        }\n    }\n}\n/**\n * Get bit price using pre-computed probability prices\n */\nexport function getBitPrice(probability, bit) {\n    return PROB_PRICES[((probability - bit ^ -bit) & 2047) >>> 2];\n}\n/**\n * Create a 64-bit number from low and high parts\n */\nexport function create64(valueLow, valueHigh) {\n    let diffHigh, diffLow;\n    valueHigh %= 1.8446744073709552E19;\n    valueLow %= 1.8446744073709552E19;\n    diffHigh = valueHigh % MAX_UINT32;\n    diffLow = Math.floor(valueLow / MAX_UINT32) * MAX_UINT32;\n    valueHigh = valueHigh - diffHigh + diffLow;\n    valueLow = valueLow - diffLow + diffHigh;\n    while (valueLow < 0) {\n        valueLow += MAX_UINT32;\n        valueHigh -= MAX_UINT32;\n    }\n    while (valueLow > 0xFFFFFFFF) {\n        valueLow -= MAX_UINT32;\n        valueHigh += MAX_UINT32;\n    }\n    valueHigh = valueHigh % 1.8446744073709552E19;\n    while (valueHigh > 9223372032559808512) {\n        valueHigh -= 1.8446744073709552E19;\n    }\n    while (valueHigh < -9223372036854775808) {\n        valueHigh += 1.8446744073709552E19;\n    }\n    return [valueLow, valueHigh];\n}\n/**\n * Add two 64-bit numbers\n */\nexport function add64(a, b) {\n    return create64(a[0] + b[0], a[1] + b[1]);\n}\n/**\n * Subtract two 64-bit numbers\n */\nexport function sub64(a, b) {\n    return create64(a[0] - b[0], a[1] - b[1]);\n}\n/**\n * Compare two 64-bit numbers\n */\nexport function compare64(a, b) {\n    if (a[0] == b[0] && a[1] == b[1]) {\n        return 0;\n    }\n    const nega = a[1] < 0;\n    const negb = b[1] < 0;\n    if (nega && !negb) {\n        return -1;\n    }\n    if (!nega && negb) {\n        return 1;\n    }\n    if (sub64(a, b)[1] < 0) {\n        return -1;\n    }\n    return 1;\n}\n/**\n * Extract low bits from 64-bit number\n */\nexport function lowBits64(a) {\n    if (a[0] >= 0x80000000) {\n        return ~~Math.max(Math.min(a[0] - MAX_UINT32, MAX_INT32), MIN_INT32);\n    }\n    return ~~Math.max(Math.min(a[0], MAX_INT32), MIN_INT32);\n}\n/**\n * Create 64-bit number from integer\n */\nexport function fromInt64(value) {\n    if (value >= 0) {\n        return [value, 0];\n    }\n    else {\n        return [value + MAX_UINT32, -MAX_UINT32];\n    }\n}\n/**\n * Right shift 64-bit number\n */\nexport function shr64(a, n) {\n    n &= 0x3F;\n    if (n <= 0x1E) {\n        const shiftFact = 1 << n;\n        return create64(Math.floor(a[0] / shiftFact), a[1] / shiftFact);\n    }\n    const shiftFact = (1 << 0x1E) * (1 << (n - 0x1E));\n    return create64(Math.floor(a[0] / shiftFact), a[1] / shiftFact);\n}\n/**\n * Bit model operations\n */\n/**\n * Initialize bit models with default probability\n */\nexport function initBitModels(probs) {\n    for (let i = probs.length - 1; i >= 0; --i) {\n        probs[i] = 1024;\n    }\n}\n/**\n * Position and state operations\n */\n/**\n * Get length to position state mapping\n */\nexport function getLenToPosState(len) {\n    len -= 2;\n    if (len < 4) {\n        return len;\n    }\n    return 3;\n}\n/**\n * Update state after character encoding/decoding\n */\nexport function stateUpdateChar(index) {\n    if (index < 4) {\n        return 0;\n    }\n    if (index < 10) {\n        return index - 3;\n    }\n    return index - 6;\n}\n/**\n * Bit tree operations\n */\n/**\n * Create a bit tree with specified number of bit levels\n */\nexport function createBitTree(numBitLevels) {\n    return {\n        numBitLevels: numBitLevels,\n        models: initArray(1 << numBitLevels),\n    };\n}\n/**\n * Create probability prices lookup table\n */\nexport function createProbPrices() {\n    const probPrices = [];\n    for (let i = 8; i >= 0; --i) {\n        let start = 1 << (9 - i - 1);\n        let end = 1 << (9 - i);\n        for (let j = start; j < end; ++j) {\n            probPrices[j] = (i << 6) + ((end - j) << 6 >>> (9 - i - 1));\n        }\n    }\n    return probPrices;\n}\n/**\n * Create fast position lookup table\n */\nexport function createFastPos() {\n    const gFastPos = [0, 1];\n    let c = 2;\n    for (let slotFast = 2; slotFast < 22; ++slotFast) {\n        let k = 1 << ((slotFast >> 1) - 1);\n        for (let j = 0; j < k; ++j, ++c) {\n            gFastPos[c] = slotFast;\n        }\n    }\n    return gFastPos;\n}\n", "import { compare64, P0_LONG_LIT, } from \"./utils.js\";\n/**\n * Encoder chunker for handling compression chunk processing\n */\nexport class EncoderChunker {\n    encoder = null;\n    decoder = null;\n    alive = 0;\n    inBytesProcessed = [0, 0];\n    lzma;\n    constructor(lzma) {\n        this.lzma = lzma;\n    }\n    /**\n     * Process one chunk of encoding\n     */\n    processChunk() {\n        if (!this.alive) {\n            throw new Error(\"bad state\");\n        }\n        if (!this.encoder) {\n            throw new Error(\"No decoding\");\n        }\n        this.lzma.codeOneBlock();\n        this.inBytesProcessed = this.encoder.processedInSize[0];\n        if (this.encoder.finished[0]) {\n            this.lzma.releaseStreams();\n            this.alive = 0;\n        }\n        return this.alive;\n    }\n}\n/**\n * Decoder chunker for handling decompression chunk processing\n */\nexport class DecoderChunker {\n    encoder = null;\n    decoder;\n    alive = 0;\n    inBytesProcessed = [0, 0];\n    constructor(decoder) {\n        this.decoder = decoder;\n    }\n    /**\n     * Process one chunk of decoding\n     */\n    processChunk() {\n        if (!this.alive) {\n            throw new Error(\"Bad state\");\n        }\n        if (this.encoder) {\n            throw new Error(\"No encoding\");\n        }\n        const result = this.decoder.codeOneChunk();\n        if (result === -1) {\n            throw new Error(\"Corrupted input\");\n        }\n        this.inBytesProcessed = this.decoder.nowPos64;\n        const isOutputComplete = (compare64(this.decoder.outSize, P0_LONG_LIT) >= 0)\n            && (compare64(this.decoder.nowPos64, this.decoder.outSize) >= 0);\n        if (result || isOutputComplete) {\n            this.decoder.flush();\n            this.decoder.cleanup();\n            this.alive = 0;\n        }\n        return this.alive;\n    }\n}\n", "export class LzOutWindow {\n    buffer = null;\n    pos = 0;\n    streamPos = 0;\n    stream = null;\n    windowSize = 0;\n    // Private Go-style properties\n    w = null;\n    buf = [];\n    constructor(writer = null, windowSize = 4096) {\n        this.w = writer;\n        this.stream = writer;\n        this.windowSize = windowSize;\n        this.buf = new Array(windowSize);\n        this.buffer = this.buf;\n        this.pos = 0;\n        this.streamPos = 0;\n    }\n    /**\n     * Copy a block of data from a previous position (LZ77-style)\n     */\n    copyBlock(distance, length) {\n        if (!this.buffer)\n            return;\n        for (let i = 0; i < length; i++) {\n            // Get byte from previous position\n            let sourcePos = this.pos - distance - 1;\n            if (sourcePos < 0) {\n                sourcePos += this.windowSize;\n            }\n            const byte = this.buffer[sourcePos];\n            this.putByte(byte);\n        }\n    }\n    /**\n     * Put a single byte into the window\n     */\n    putByte(byte) {\n        if (!this.buffer)\n            return;\n        this.buffer[this.pos] = byte;\n        this.pos++;\n        this.streamPos++;\n        if (this.pos >= this.windowSize) {\n            this.flush();\n        }\n    }\n    /**\n     * Get a byte from a relative position\n     */\n    getByte(relativePos) {\n        if (!this.buffer)\n            return 0;\n        let pos = this.pos + relativePos;\n        if (pos < 0) {\n            pos += this.windowSize;\n        }\n        else if (pos >= this.windowSize) {\n            pos -= this.windowSize;\n        }\n        return this.buffer[pos];\n    }\n    /**\n     * Flush buffered data to output writer\n     */\n    flush() {\n        if (this.w && this.buffer && this.pos > 0) {\n            const dataToWrite = this.buffer.slice(0, this.pos);\n            this.w.write(dataToWrite);\n            this.pos = 0;\n        }\n    }\n    /**\n     * Check if the window is empty\n     */\n    isEmpty() {\n        return this.streamPos === 0;\n    }\n    /**\n     * Reset the window\n     */\n    reset() {\n        this.pos = 0;\n        this.streamPos = 0;\n        if (this.buffer) {\n            this.buffer.fill(0);\n        }\n    }\n}\n", "export class RangeDecoder {\n    stream = null;\n    code = 0;\n    rrange = 0;\n    /**\n     * Set input stream for decoding\n     */\n    setStream(stream) {\n        this.stream = stream;\n    }\n    /**\n     * Initialize range decoder\n     */\n    init() {\n        this.code = 0;\n        this.rrange = -1;\n        for (let i = 0; i < 5; ++i) {\n            this.code = this.code << 8 | this.readFromStream();\n        }\n    }\n    /**\n     * Decode a single bit using probability model\n     */\n    decodeBit(probs, index) {\n        let newBound, prob = probs[index];\n        newBound = (this.rrange >>> 11) * prob;\n        if ((this.code ^ -0x80000000) < (newBound ^ -0x80000000)) {\n            this.rrange = newBound;\n            probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;\n            if (!(this.rrange & -0x1000000)) {\n                this.code = this.code << 8 | this.readFromStream();\n                this.rrange <<= 8;\n            }\n            return 0;\n        }\n        else {\n            this.rrange -= newBound;\n            this.code -= newBound;\n            probs[index] = prob - (prob >>> 5) << 16 >> 16;\n            if (!(this.rrange & -0x1000000)) {\n                this.code = this.code << 8 | this.readFromStream();\n                this.rrange <<= 8;\n            }\n            return 1;\n        }\n    }\n    /**\n     * Decode direct bits (without probability model)\n     */\n    decodeDirectBits(numTotalBits) {\n        let result = 0;\n        for (let i = numTotalBits; i != 0; i -= 1) {\n            this.rrange >>>= 1;\n            let t = (this.code - this.rrange) >>> 31;\n            this.code -= this.rrange & (t - 1);\n            result = result << 1 | 1 - t;\n            if (!(this.rrange & -0x1000000)) {\n                this.code = this.code << 8 | this.readFromStream();\n                this.rrange <<= 8;\n            }\n        }\n        return result;\n    }\n    /**\n     * Get current code value (for compatibility)\n     */\n    get currentCode() {\n        return this.code;\n    }\n    /**\n     * Get current range value (for compatibility)\n     */\n    get currentRange() {\n        return this.rrange;\n    }\n    /**\n     * Read a single byte from the input stream\n     */\n    readFromStream() {\n        if (!this.stream) {\n            return 0;\n        }\n        if (this.stream.pos >= this.stream.count) {\n            return -1;\n        }\n        let value;\n        if (this.stream.buf instanceof ArrayBuffer) {\n            value = new Uint8Array(this.stream.buf)[this.stream.pos++];\n        }\n        else if (this.stream.buf instanceof Uint8Array) {\n            value = this.stream.buf[this.stream.pos++];\n        }\n        else {\n            value = this.stream.buf[this.stream.pos++];\n        }\n        return value & 0xFF;\n    }\n}\n", "import { LzOutWindow } from \"./lz-window.js\";\nimport { RangeDecoder } from \"./range-decoder.js\";\nimport { add64, CHOICE_ARRAY_SIZE, compare64, createBitTree, DEFAULT_WINDOW_SIZE, getLenToPosState, initArray, initBitModels, LITERAL_DECODER_SIZE, lowBits64, MATCH_DECODERS_SIZE, POS_DECODERS_SIZE, REP_DECODERS_SIZE, stateUpdateChar, } from \"./utils.js\";\nexport class Decoder {\n    rangeDecoder;\n    outWindow;\n    // Decoder state\n    state = 0;\n    rep0 = 0;\n    rep1 = 0;\n    rep2 = 0;\n    rep3 = 0;\n    prevByte = 0;\n    nowPos64 = [0, 0];\n    outSize = [0, 0];\n    // Decoder configuration\n    posStateMask = 0;\n    dictSizeCheck = 0;\n    // Probability models for different symbols\n    matchDecoders = [];\n    rep0LongDecoders = [];\n    repDecoders = [];\n    repG0Decoders = [];\n    repG1Decoders = [];\n    repG2Decoders = [];\n    posDecoders = [];\n    // Complex decoders\n    literalDecoder;\n    posSlotDecoders = [];\n    lenDecoder;\n    repLenDecoder;\n    posAlignDecoder;\n    // Alias for compatibility with LZMA class\n    get literalCoder() {\n        return this.literalDecoder;\n    }\n    // Chunker properties for compatibility\n    decoder;\n    encoder = null;\n    alive = 0;\n    inBytesProcessed = [0, 0];\n    constructor() {\n        // Initialize range decoder\n        this.rangeDecoder = new RangeDecoder();\n        // Initialize output window using proper LzOutWindow\n        this.outWindow = new LzOutWindow(null, DEFAULT_WINDOW_SIZE);\n        // Initialize probability models\n        this.matchDecoders = initArray(MATCH_DECODERS_SIZE);\n        this.rep0LongDecoders = initArray(MATCH_DECODERS_SIZE);\n        this.repDecoders = initArray(REP_DECODERS_SIZE);\n        this.repG0Decoders = initArray(REP_DECODERS_SIZE);\n        this.repG1Decoders = initArray(REP_DECODERS_SIZE);\n        this.repG2Decoders = initArray(REP_DECODERS_SIZE);\n        this.posDecoders = initArray(POS_DECODERS_SIZE);\n        // Initialize literal decoder\n        this.literalDecoder = {\n            coders: [],\n            numPrevBits: 0,\n            numPosBits: 0,\n            posMask: 0,\n            init: () => this.initLiteralDecoder(),\n        };\n        // Initialize position slot decoders (4 different length-to-position states)\n        for (let i = 0; i < 4; i++) {\n            this.posSlotDecoders[i] = createBitTree(6);\n        }\n        // Initialize length decoders\n        this.lenDecoder = this.createLenDecoder();\n        this.repLenDecoder = this.createLenDecoder();\n        // Initialize position alignment decoder\n        this.posAlignDecoder = createBitTree(4);\n        // Initialize self-reference for chunker compatibility\n        this.decoder = this;\n    }\n    createLenDecoder() {\n        const decoder = {\n            choice: initArray(CHOICE_ARRAY_SIZE),\n            lowCoder: [],\n            midCoder: [],\n            highCoder: createBitTree(0x08),\n            numPosStates: 0,\n        };\n        return decoder;\n    }\n    setDecoderProperties(properties) {\n        if (properties.length < 5) {\n            return false;\n        }\n        const lc = properties[0] % 9;\n        const remainder = Math.floor(properties[0] / 9);\n        const lp = remainder % 5;\n        const pb = Math.floor(remainder / 5);\n        if (pb > 4) {\n            return false;\n        }\n        // Set literal decoder properties\n        this.literalDecoder.numPrevBits = lc;\n        this.literalDecoder.numPosBits = lp;\n        this.literalDecoder.posMask = (1 << lp) - 1;\n        // Set position state mask\n        this.posStateMask = (1 << pb) - 1;\n        // Calculate dictionary size from properties[1-4]\n        let dictSize = 0;\n        for (let i = 0; i < 4; i++) {\n            // Treat bytes as unsigned (0-255) instead of signed (-128 to 127)\n            const unsignedByte = properties[1 + i] & 0xFF;\n            dictSize += unsignedByte << (i * 8);\n        }\n        // Set dictionary size and check value\n        this.dictSizeCheck = Math.max(dictSize, 1);\n        // Initialize output window\n        if (dictSize > 0) {\n            this.outWindow.windowSize = Math.max(dictSize, 4096);\n            this.outWindow.buffer = initArray(this.outWindow.windowSize);\n        }\n        // Initialize literal decoder coders\n        const numStates = 1 << (this.literalDecoder.numPrevBits + this.literalDecoder.numPosBits);\n        this.literalDecoder.coders = [];\n        for (let i = 0; i < numStates; i++) {\n            this.literalDecoder.coders[i] = {\n                decoders: initArray(LITERAL_DECODER_SIZE), // 0x300\n            };\n        }\n        // Initialize length decoders\n        this.lenDecoder.numPosStates = 1 << pb;\n        this.repLenDecoder.numPosStates = 1 << pb;\n        // Initialize low and mid coders for length decoders\n        this.lenDecoder.lowCoder = [];\n        this.lenDecoder.midCoder = [];\n        this.repLenDecoder.lowCoder = [];\n        this.repLenDecoder.midCoder = [];\n        for (let posState = 0; posState < (1 << pb); posState++) {\n            this.lenDecoder.lowCoder[posState] = createBitTree(3);\n            this.lenDecoder.midCoder[posState] = createBitTree(3);\n            this.repLenDecoder.lowCoder[posState] = createBitTree(3);\n            this.repLenDecoder.midCoder[posState] = createBitTree(3);\n        }\n        return true;\n    }\n    // Methods that modify decoder state\n    copyBlock(len) {\n        const outputWindow = this.outWindow;\n        const distance = this.rep0;\n        let pos = outputWindow.pos - distance - 1;\n        if (pos < 0) {\n            pos += outputWindow.windowSize;\n        }\n        for (; len != 0; len -= 1) {\n            if (pos >= outputWindow.windowSize) {\n                pos = 0;\n            }\n            outputWindow.buffer[outputWindow.pos] = outputWindow.buffer[pos];\n            outputWindow.pos += 1;\n            pos += 1;\n            if (outputWindow.pos >= outputWindow.windowSize) {\n                this.flush();\n            }\n        }\n    }\n    putByte(b) {\n        this.outWindow.buffer[this.outWindow.pos] = b;\n        this.outWindow.pos += 1;\n        if (this.outWindow.pos >= this.outWindow.windowSize) {\n            this.flush();\n        }\n    }\n    getByte(distance) {\n        const outputWindow = this.outWindow;\n        let pos = outputWindow.pos - distance - 1;\n        if (pos < 0) {\n            pos += outputWindow.windowSize;\n        }\n        return outputWindow.buffer[pos];\n    }\n    getDecoder(pos, prevByte) {\n        // Calculate index based on position and previous byte\n        const positionMask = pos & this.literalDecoder.posMask;\n        const prevBitsMask = (prevByte & 0xFF) >>> (8 - this.literalDecoder.numPrevBits);\n        const index = (positionMask << this.literalDecoder.numPrevBits) + prevBitsMask;\n        // Return decoder at calculated index\n        return this.literalDecoder.coders[index];\n    }\n    initLiteralDecoder() {\n        let numStates = 1 << (this.literalDecoder.numPrevBits + this.literalDecoder.numPosBits);\n        for (let i = 0; i < numStates; ++i) {\n            // Initialize bit models for each coder\n            for (let j = 0; j < this.literalDecoder.coders[i].decoders.length; j++) {\n                this.literalDecoder.coders[i].decoders[j] = 1024;\n            }\n        }\n    }\n    init() {\n        this.outWindow.streamPos = 0;\n        this.outWindow.pos = 0;\n        initBitModels(this.matchDecoders);\n        initBitModels(this.rep0LongDecoders);\n        initBitModels(this.repDecoders);\n        initBitModels(this.repG0Decoders);\n        initBitModels(this.repG1Decoders);\n        initBitModels(this.repG2Decoders);\n        initBitModels(this.posDecoders);\n        this.initLiteralDecoder();\n        for (let i = 0; i < 4; ++i) {\n            initBitModels(this.posSlotDecoders[i].models);\n        }\n        this.initLenDecoder(this.lenDecoder);\n        this.initLenDecoder(this.repLenDecoder);\n        initBitModels(this.posAlignDecoder.models);\n        this.initRangeDecoder();\n    }\n    initLenDecoder(decoder) {\n        initBitModels(decoder.choice);\n        for (let posState = 0; posState < decoder.numPosStates; ++posState) {\n            initBitModels(decoder.lowCoder[posState].models);\n            initBitModels(decoder.midCoder[posState].models);\n        }\n        initBitModels(decoder.highCoder.models);\n    }\n    outWindowReleaseStream() {\n        this.flush();\n        this.outWindow.stream = null;\n    }\n    decodeBit(probs, index) {\n        return this.rangeDecoder.decodeBit(probs, index);\n    }\n    decodeDirectBits(numTotalBits) {\n        return this.rangeDecoder.decodeDirectBits(numTotalBits);\n    }\n    initRangeDecoder() {\n        this.rangeDecoder.init();\n    }\n    rangeBitTreeDecoder(bitTree) {\n        let bitIndex, m = 1;\n        for (bitIndex = bitTree.numBitLevels; bitIndex != 0; bitIndex -= 1) {\n            m = (m << 1) + this.decodeBit(bitTree.models, m);\n        }\n        return m - (1 << bitTree.numBitLevels);\n    }\n    reverseDecode(models, startIndex, numBitLevels) {\n        let symbol = 0;\n        for (let bitIndex = 0, m = 1, bit; bitIndex < numBitLevels; ++bitIndex) {\n            bit = this.decodeBit(models, startIndex + m);\n            m <<= 1;\n            m += bit;\n            symbol |= bit << bitIndex;\n        }\n        return symbol;\n    }\n    reverseDecodeAlignDecoder() {\n        let symbol = 0;\n        for (let m = 1, bitIndex = 0, bit; bitIndex < this.posAlignDecoder.numBitLevels; ++bitIndex) {\n            bit = this.decodeBit(this.posAlignDecoder.models, m);\n            m <<= 1;\n            m += bit;\n            symbol |= bit << bitIndex;\n        }\n        return symbol;\n    }\n    // Update the placeholder implementations with actual logic\n    decodeNormalWithRangeDecoder(decoder) {\n        let symbol = 1;\n        do {\n            symbol = symbol << 1 | this.decodeBit(decoder.decoders, symbol);\n        } while (symbol < 0x100);\n        return symbol << 24 >> 24;\n    }\n    decodeWithMatchByteWithRangeDecoder(encoder, matchByte) {\n        let bit, matchBit, symbol = 1;\n        do {\n            matchBit = (matchByte >> 7) & 1;\n            matchByte <<= 1;\n            bit = this.decodeBit(encoder.decoders, ((1 + matchBit) << 8) + symbol);\n            symbol = symbol << 1 | bit;\n            if (matchBit != bit) {\n                while (symbol < 0x100) {\n                    symbol = symbol << 1 | this.decodeBit(encoder.decoders, symbol);\n                }\n                break;\n            }\n        } while (symbol < 0x100);\n        return symbol << 24 >> 24;\n    }\n    decodeLenWithRangeDecoder(decoder, posState) {\n        if (!this.decodeBit(decoder.choice, 0)) {\n            return this.rangeBitTreeDecoder(decoder.lowCoder[posState]);\n        }\n        let symbol = 0x08;\n        if (!this.decodeBit(decoder.choice, 1)) {\n            symbol += this.rangeBitTreeDecoder(decoder.midCoder[posState]);\n        }\n        else {\n            symbol += 0x08 + this.rangeBitTreeDecoder(decoder.highCoder);\n        }\n        return symbol;\n    }\n    codeOneChunk() {\n        let decoder2, distance, len, numDirectBits, positionSlot;\n        let posState = lowBits64(this.nowPos64) & this.posStateMask;\n        if (!this.decodeBit(this.matchDecoders, (this.state << 4) + posState)) {\n            decoder2 = this.getDecoder(lowBits64(this.nowPos64), this.prevByte);\n            if (this.state < 7) {\n                this.prevByte = this.decodeNormalWithRangeDecoder(decoder2);\n            }\n            else {\n                this.prevByte = this.decodeWithMatchByteWithRangeDecoder(decoder2, this.getByte(this.rep0));\n            }\n            this.putByte(this.prevByte);\n            this.state = stateUpdateChar(this.state);\n            this.nowPos64 = add64(this.nowPos64, [1, 0]);\n        }\n        else {\n            if (this.decodeBit(this.repDecoders, this.state)) {\n                len = 0;\n                if (!this.decodeBit(this.repG0Decoders, this.state)) {\n                    if (!this.decodeBit(this.rep0LongDecoders, (this.state << 4) + posState)) {\n                        this.state = this.state < 7 ? 9 : 11;\n                        len = 1;\n                    }\n                }\n                else {\n                    if (!this.decodeBit(this.repG1Decoders, this.state)) {\n                        distance = this.rep1;\n                    }\n                    else {\n                        if (!this.decodeBit(this.repG2Decoders, this.state)) {\n                            distance = this.rep2;\n                        }\n                        else {\n                            distance = this.rep3;\n                            this.rep3 = this.rep2;\n                        }\n                        this.rep2 = this.rep1;\n                    }\n                    this.rep1 = this.rep0;\n                    this.rep0 = distance;\n                }\n                if (!len) {\n                    len = this.decodeLenWithRangeDecoder(this.repLenDecoder, posState) + 2;\n                    this.state = this.state < 7 ? 0x08 : 11;\n                }\n            }\n            else {\n                this.rep3 = this.rep2;\n                this.rep2 = this.rep1;\n                this.rep1 = this.rep0;\n                len = 2 + this.decodeLenWithRangeDecoder(this.lenDecoder, posState);\n                this.state = this.state < 7 ? 7 : 10;\n                positionSlot = this.rangeBitTreeDecoder(this.posSlotDecoders[getLenToPosState(len)]);\n                if (positionSlot >= 4) {\n                    numDirectBits = (positionSlot >> 1) - 1;\n                    this.rep0 = (2 | (positionSlot & 1)) << numDirectBits;\n                    if (positionSlot < 14) {\n                        this.rep0 += this.reverseDecode(this.posDecoders, this.rep0 - positionSlot - 1, numDirectBits);\n                    }\n                    else {\n                        this.rep0 += this.decodeDirectBits(numDirectBits - 4) << 4;\n                        this.rep0 += this.reverseDecodeAlignDecoder();\n                        if (this.rep0 < 0) {\n                            if (this.rep0 == -1) {\n                                return 1;\n                            }\n                            return -1;\n                        }\n                    }\n                }\n                else {\n                    this.rep0 = positionSlot;\n                }\n            }\n            if (compare64([this.rep0, 0], this.nowPos64) >= 0 || this.rep0 >= this.dictSizeCheck) {\n                return -1;\n            }\n            this.copyBlock(len);\n            this.nowPos64 = add64(this.nowPos64, [len, 0]);\n            this.prevByte = this.getByte(0);\n        }\n        return 0;\n    }\n    // Setup decoder for chunk processing\n    setupForDecoding(inStream, outSize, outputBuffer) {\n        this.rangeDecoder.setStream(inStream);\n        this.outSize = outSize;\n        this.outWindowReleaseStream();\n        this.outWindow.stream = outputBuffer;\n        this.init();\n        this.state = 0;\n        this.rep0 = 0;\n        this.rep1 = 0;\n        this.rep2 = 0;\n        this.rep3 = 0;\n        this.outSize = outSize;\n        this.nowPos64 = [0, 0];\n        this.prevByte = 0;\n        this.decoder = this;\n        this.encoder = null;\n        this.alive = 1;\n    }\n    // Process chunk and return alive status\n    processChunk() {\n        if (!this.alive) {\n            throw new Error(\"Bad state\");\n        }\n        if (this.encoder) {\n            throw new Error(\"No encoding\");\n        }\n        const result = this.codeOneChunk();\n        if (result === -1) {\n            throw new Error(\"Corrupted input\");\n        }\n        const isOutputComplete = (compare64(this.outSize, [0, 0]) >= 0)\n            && (compare64(this.nowPos64, this.outSize) >= 0);\n        if (result || isOutputComplete) {\n            this.flush();\n            this.outWindowReleaseStream();\n            this.rangeDecoder.setStream(null);\n            this.alive = 0;\n        }\n        return this.alive;\n    }\n    writeToOutput(buffer, data, offset, length) {\n        // Ensure buffer has enough capacity\n        const requiredSize = buffer.count + length;\n        if (requiredSize > buffer.buf.length) {\n            const newSize = Math.max(buffer.buf.length * 2, requiredSize);\n            const newBuf = new Array(newSize);\n            for (let i = 0; i < buffer.count; i++) {\n                newBuf[i] = buffer.buf[i];\n            }\n            buffer.buf = newBuf;\n        }\n        // Copy data\n        for (let i = 0; i < length; i++) {\n            buffer.buf[buffer.count + i] = data[offset + i];\n        }\n        buffer.count += length;\n    }\n    isBufferWithCount(x) {\n        const s = x;\n        return !!s && Array.isArray(s.buf) && typeof s.count === \"number\" && typeof s.write === \"function\";\n    }\n    flush() {\n        const size = this.outWindow.pos - this.outWindow.streamPos;\n        if (!size) {\n            return;\n        }\n        if (this.outWindow.stream && this.outWindow.buffer) {\n            const outputBuffer = this.outWindow.stream;\n            if (this.isBufferWithCount(outputBuffer)) {\n                this.writeToOutput(outputBuffer, this.outWindow.buffer, this.outWindow.streamPos, size);\n            }\n            else if (typeof outputBuffer.write === \"function\") {\n                // Fallback: write directly if it's a plain Writer\n                const slice = this.outWindow.buffer.slice(this.outWindow.streamPos, this.outWindow.streamPos + size);\n                outputBuffer.write(slice);\n            }\n        }\n        if (this.outWindow.pos >= this.outWindow.windowSize) {\n            this.outWindow.pos = 0;\n        }\n        this.outWindow.streamPos = this.outWindow.pos;\n    }\n    /**\n     * Cleanup decoder resources\n     */\n    cleanup() {\n        this.outWindow.stream = null;\n        this.rangeDecoder.stream = null;\n    }\n}\n", "import { createBitTree, getBitPrice, initArray, initBitModels, } from \"./utils.js\";\n/**\n * Length encoder class for LZMA compression\n * Handles encoding of match lengths with price optimization\n */\nexport class LenEncoder {\n    // Choice probability arrays for length range selection\n    choice = initArray(2);\n    // Low range coders (for lengths 2-9)\n    lowCoder = [];\n    // Mid range coders (for lengths 10-17)\n    midCoder = [];\n    // High range coder (for lengths 18+)\n    highCoder = createBitTree(8);\n    // Price optimization properties\n    tableSize = 0;\n    prices = [];\n    counters = [];\n    constructor() {\n        // Initialize low and mid coders for all position states (up to 16)\n        for (let posState = 0; posState < 16; ++posState) {\n            this.lowCoder[posState] = createBitTree(3);\n            this.midCoder[posState] = createBitTree(3);\n        }\n    }\n    /**\n     * Initialize the encoder with specified number of position states\n     */\n    init(numPosStates) {\n        // Initialize choice probability models\n        initBitModels(this.choice);\n        // Initialize low and mid coders for each position state\n        for (let posState = 0; posState < numPosStates; ++posState) {\n            initBitModels(this.lowCoder[posState].models);\n            initBitModels(this.midCoder[posState].models);\n        }\n        // Initialize high coder\n        initBitModels(this.highCoder.models);\n    }\n    /**\n     * Encode a length value using the provided range encoder\n     */\n    encode(symbol, posState, rangeEncoder) {\n        if (symbol < 8) {\n            // Length 2-9: use low coder\n            rangeEncoder.encodeBit(this.choice, 0, 0);\n            rangeEncoder.encodeBitTree(this.lowCoder[posState], symbol);\n        }\n        else {\n            symbol -= 8;\n            rangeEncoder.encodeBit(this.choice, 0, 1);\n            if (symbol < 8) {\n                // Length 10-17: use mid coder\n                rangeEncoder.encodeBit(this.choice, 1, 0);\n                rangeEncoder.encodeBitTree(this.midCoder[posState], symbol);\n            }\n            else {\n                // Length 18+: use high coder\n                rangeEncoder.encodeBit(this.choice, 1, 1);\n                rangeEncoder.encodeBitTree(this.highCoder, symbol - 8);\n            }\n        }\n    }\n    /**\n     * Encode with price table update\n     */\n    encodeWithUpdate(symbol, posState, rangeEncoder) {\n        this.encode(symbol, posState, rangeEncoder);\n        if (this.counters && (this.counters[posState] -= 1) == 0) {\n            // Reset counter and update prices if needed\n            this.counters[posState] = this.tableSize;\n        }\n    }\n    /**\n     * Get price for encoding a symbol at the given position state\n     */\n    getPrice(symbol, posState) {\n        return this.prices[posState * 0x110 + symbol];\n    }\n    /**\n     * Initialize as a price table encoder\n     */\n    initPriceTable() {\n        this.prices = [];\n        this.counters = [];\n    }\n    /**\n     * Set table size for price optimization\n     */\n    setTableSize(size) {\n        this.tableSize = size;\n    }\n    /**\n     * Set table size and update internal counters\n     */\n    setTableSizeAndInitCounters(size, numPosStates) {\n        this.tableSize = size;\n        if (this.counters) {\n            for (let posState = 0; posState < numPosStates; ++posState) {\n                this.counters[posState] = size;\n            }\n        }\n    }\n    /**\n     * Get table size\n     */\n    getTableSize() {\n        return this.tableSize;\n    }\n    /**\n     * Update price tables for all position states\n     */\n    updateTables(numPosStates) {\n        if (!this.prices || !this.counters) {\n            this.initPriceTable();\n        }\n        for (let posState = 0; posState < numPosStates; ++posState) {\n            this.setPrices(posState, this.tableSize, this.prices, 0);\n            if (this.counters) {\n                this.counters[posState] = this.tableSize;\n            }\n        }\n    }\n    // Private methods for internal state management\n    /**\n     * Calculate price for bit tree encoder\n     */\n    getBitTreePrice(encoder, symbol) {\n        let bit, bitIndex, m = 1, price = 0;\n        for (bitIndex = encoder.numBitLevels; bitIndex != 0;) {\n            bitIndex -= 1;\n            bit = symbol >>> bitIndex & 1;\n            price += this.getBitPrice(encoder.models[m], bit);\n            m = (m << 1) + bit;\n        }\n        return price;\n    }\n    /**\n     * Get price for a single bit\n     */\n    getBitPrice(prob, symbol) {\n        return getBitPrice(prob, symbol);\n    }\n    /**\n     * Set prices for all symbols in a position state range\n     */\n    setPrices(posState, numSymbols, prices, priceIndex) {\n        const a0 = this.getBitPrice(this.choice[0], 0);\n        const a1 = this.getBitPrice(this.choice[0], 1);\n        const b0 = a1 + this.getBitPrice(this.choice[1], 0);\n        const b1 = a1 + this.getBitPrice(this.choice[1], 1);\n        let i = 0;\n        const st = priceIndex + posState * 0x110;\n        // Set prices for low range (lengths 2-9)\n        for (i = 0; i < 8; ++i) {\n            if (i >= numSymbols)\n                return;\n            prices[st + i] = a0 + this.getBitTreePrice(this.lowCoder[posState], i);\n        }\n        // Set prices for mid range (lengths 10-17)\n        for (; i < 16; ++i) {\n            if (i >= numSymbols)\n                return;\n            prices[st + i] = b0 + this.getBitTreePrice(this.midCoder[posState], i - 8);\n        }\n        // Set prices for high range (lengths 18+)\n        for (; i < numSymbols; ++i) {\n            prices[st + i] = b1 + this.getBitTreePrice(this.highCoder, i - 8 - 8);\n        }\n    }\n}\n", "import { getBitPrice, initArray, } from \"./utils.js\";\nexport class LitSubCoder {\n    coders;\n    constructor() {\n        this.coders = initArray(0x300, 0x400);\n    }\n    /**\n     * Decode normal literal symbol\n     */\n    decodeNormal(rd) {\n        let symbol = 1;\n        while (symbol < 0x100) {\n            const i = rd.decodeBit(this.coders, symbol);\n            symbol = (symbol << 1) | i;\n        }\n        return symbol & 0xFF;\n    }\n    /**\n     * Decode literal symbol with match byte context\n     */\n    decodeWithMatchByte(rd, matchByte) {\n        let uMatchByte = matchByte;\n        let symbol = 1;\n        while (symbol < 0x100) {\n            const matchBit = (uMatchByte >> 7) & 1;\n            uMatchByte <<= 1;\n            const bit = rd.decodeBit(this.coders, ((1 + matchBit) << 8) + symbol);\n            symbol = (symbol << 1) | bit;\n            if (matchBit !== bit) {\n                while (symbol < 0x100) {\n                    const i = rd.decodeBit(this.coders, symbol);\n                    symbol = (symbol << 1) | i;\n                }\n                break;\n            }\n        }\n        return symbol & 0xFF;\n    }\n    /**\n     * Encode literal symbol\n     */\n    encode(re, symbol) {\n        let context = 1;\n        for (let i = 7; i >= 0; i--) {\n            const bit = (symbol >> i) & 1;\n            re.encodeBit(this.coders, context, bit);\n            context = (context << 1) | bit;\n        }\n    }\n    /**\n     * Encode literal symbol with match byte context\n     */\n    encodeMatched(re, matchByte, symbol) {\n        let uMatchByte = matchByte;\n        let context = 1;\n        let same = true;\n        for (let i = 7; i >= 0; i--) {\n            const bit = (symbol >> i) & 1;\n            let state = context;\n            if (same) {\n                const matchBit = (uMatchByte >> i) & 1;\n                state += (1 + matchBit) << 8;\n                same = matchBit === bit;\n            }\n            re.encodeBit(this.coders, state, bit);\n            context = (context << 1) | bit;\n        }\n    }\n    /**\n     * Get price for encoding literal symbol\n     */\n    getPrice(matchMode, matchByte, symbol) {\n        let uMatchByte = matchByte;\n        let price = 0;\n        let context = 1;\n        let i = 7;\n        if (matchMode) {\n            while (i >= 0) {\n                const matchBit = (uMatchByte >> i) & 1;\n                const bit = (symbol >> i) & 1;\n                price += getBitPrice(this.coders[(1 + matchBit) << 8 + context], bit);\n                context = (context << 1) | bit;\n                if (matchBit !== bit) {\n                    i--;\n                    break;\n                }\n                i--;\n            }\n        }\n        while (i >= 0) {\n            const bit = (symbol >> i) & 1;\n            price += getBitPrice(this.coders[context], bit);\n            context = (context << 1) | bit;\n            i--;\n        }\n        return price;\n    }\n    /**\n     * Reset coder to initial state\n     */\n    reset() {\n        this.coders.fill(1024);\n    }\n    /**\n     * Get decoders array (for compatibility with LiteralDecoderEncoder2)\n     */\n    get decoders() {\n        return this.coders;\n    }\n}\nexport class LitCoder {\n    _coders;\n    _numPrevBits;\n    _posMask;\n    constructor(numPosBits, numPrevBits) {\n        const numStates = 1 << (numPrevBits + numPosBits);\n        this._coders = [];\n        this._numPrevBits = numPrevBits;\n        this._posMask = (1 << numPosBits) - 1;\n        for (let i = 0; i < numStates; i++) {\n            this._coders[i] = new LitSubCoder();\n        }\n    }\n    /**\n     * Get sub-coder for position and previous byte\n     */\n    getSubCoder(pos, prevByte) {\n        return this._coders[((pos & this._posMask) << this._numPrevBits)\n            + (prevByte >> (8 - this._numPrevBits))];\n    }\n    /**\n     * Reset all sub-coders\n     */\n    reset() {\n        this._coders.forEach((coder) => coder.reset());\n    }\n    /**\n     * Get number of previous bits (for compatibility)\n     */\n    get numPrevBits() {\n        return this._numPrevBits;\n    }\n    /**\n     * Get number of position bits (for compatibility)\n     */\n    get numPosBits() {\n        // Calculate from posMask\n        return Math.log2(this._posMask + 1);\n    }\n    /**\n     * Get position mask (for compatibility)\n     */\n    get posMask() {\n        return this._posMask;\n    }\n    /**\n     * Get coders array (for compatibility)\n     */\n    get coders() {\n        return this._coders;\n    }\n}\n", "import { LenEncoder, } from \"./len-coder.js\";\nimport { LitCoder } from \"./lit-coder.js\";\nimport { add64, compare64, create64, createBitTree, fromInt64, G_FAST_POS, getBitPrice, getLenToPosState, initArray, initBitModels, lowBits64, PROB_PRICES, } from \"./utils.js\";\nconst bitTreePriceCache = new Map();\n/**\n * Calculate price for direct bit encoding\n */\nfunction getDirectBitsPrice(numBits) {\n    return numBits << 6;\n}\n/**\n * Get price for bit tree encoding with caching\n */\nfunction getBitTreePrice(bitTree, symbol) {\n    const cacheKey = `${bitTree.numBitLevels}-${symbol}`;\n    if (bitTreePriceCache.has(cacheKey)) {\n        return bitTreePriceCache.get(cacheKey);\n    }\n    let price = 0;\n    let modelIndex = 1;\n    for (let bitIndex = bitTree.numBitLevels; bitIndex > 0; bitIndex--) {\n        const bit = (symbol >>> (bitIndex - 1)) & 1;\n        price += getBitPrice(bitTree.models[modelIndex], bit);\n        modelIndex = (modelIndex << 1) + bit;\n    }\n    if (bitTreePriceCache.size < 10000) {\n        bitTreePriceCache.set(cacheKey, price);\n    }\n    return price;\n}\n/**\n * LZMA Encoder State - Encapsulates all encoder state management\n */\nclass EncoderState {\n    // Core state\n    state = 0;\n    previousByte = 0;\n    position = [0, 0];\n    // Repetition distances (LZ77 back-references)\n    repDistances = [0, 0, 0, 0];\n    // Match finding state\n    longestMatchLength = 0;\n    longestMatchWasFound = false;\n    additionalOffset = 0;\n    // Probability models for different encoding decisions\n    isMatch = initArray(0xC0);\n    isRep = initArray(0x0C);\n    isRepG0 = initArray(0x0C);\n    isRepG1 = initArray(0x0C);\n    isRepG2 = initArray(0x0C);\n    isRep0Long = initArray(0xC0);\n    /**\n     * Initialize all probability models to default values\n     */\n    initModels() {\n        initBitModels(this.isMatch);\n        initBitModels(this.isRep);\n        initBitModels(this.isRepG0);\n        initBitModels(this.isRepG1);\n        initBitModels(this.isRepG2);\n        initBitModels(this.isRep0Long);\n    }\n    /**\n     * Update repetition distances when a new match is found\n     */\n    updateRepDistances(newDistance, repIndex) {\n        if (repIndex === 0) {\n            // New match becomes rep0, shift others\n            this.repDistances[3] = this.repDistances[2];\n            this.repDistances[2] = this.repDistances[1];\n            this.repDistances[1] = this.repDistances[0];\n            this.repDistances[0] = newDistance;\n        }\n        else {\n            // Move specific rep to front, shift others\n            const temp = this.repDistances[repIndex];\n            for (let i = repIndex; i > 0; i--) {\n                this.repDistances[i] = this.repDistances[i - 1];\n            }\n            this.repDistances[0] = temp;\n        }\n    }\n}\n/**\n * Position Encoder - Handles position slot and alignment encoding\n */\nclass PositionEncoder {\n    posSlotEncoder = [];\n    posEncoders = initArray(0x72);\n    posAlignEncoder;\n    constructor() {\n        // Initialize position slot encoders for different length states\n        for (let lenState = 0; lenState < 4; lenState++) {\n            this.posSlotEncoder[lenState] = createBitTree(6);\n        }\n        this.posAlignEncoder = createBitTree(4);\n    }\n    /**\n     * Initialize all position models\n     */\n    init() {\n        for (const encoder of this.posSlotEncoder) {\n            initBitModels(encoder.models);\n        }\n        initBitModels(this.posEncoders);\n        initBitModels(this.posAlignEncoder.models);\n    }\n    /**\n     * Encode position using optimal method\n     */\n    encodePosition(distance, lenState, rangeEncoder) {\n        const posSlot = this.getPosSlot(distance);\n        rangeEncoder.encodeBitTree(this.posSlotEncoder[lenState], posSlot);\n        if (posSlot >= 4) {\n            const footerBits = (posSlot >> 1) - 1;\n            const baseVal = (2 | (posSlot & 1)) << footerBits;\n            const posReduced = distance - baseVal;\n            if (posSlot < 14) {\n                // Use position encoders for middle range\n                this.encodeReverseBits(posReduced, footerBits, rangeEncoder);\n            }\n            else {\n                // Use direct bits for high range + alignment\n                rangeEncoder.encodeDirectBits(posReduced >> 4, footerBits - 4);\n                rangeEncoder.encodeBitTree(this.posAlignEncoder, posReduced & 0x0F);\n            }\n        }\n    }\n    /**\n     * Calculate price for encoding a position\n     */\n    getPositionPrice(distance, lenState) {\n        const posSlot = this.getPosSlot(distance);\n        let price = getBitTreePrice(this.posSlotEncoder[lenState], posSlot);\n        if (posSlot >= 4) {\n            const footerBits = (posSlot >> 1) - 1;\n            const baseVal = (2 | (posSlot & 1)) << footerBits;\n            const posReduced = distance - baseVal;\n            if (posSlot < 14) {\n                price += this.getReverseBitsPrice(posReduced, footerBits);\n            }\n            else {\n                price += getDirectBitsPrice(footerBits - 4);\n                price += getBitTreePrice(this.posAlignEncoder, posReduced & 0x0F);\n            }\n        }\n        return price;\n    }\n    getPosSlot(distance) {\n        if (distance < 4)\n            return distance;\n        if (distance < (1 << (31 - 11))) {\n            return G_FAST_POS[distance >> 6] + 12;\n        }\n        return G_FAST_POS[distance >> 26] + 52;\n    }\n    encodeReverseBits(value, numBits, rangeEncoder) {\n        let modelIndex = 1;\n        for (let i = 0; i < numBits; i++) {\n            const bit = value & 1;\n            rangeEncoder.encodeBit(this.posEncoders, modelIndex, bit);\n            modelIndex = (modelIndex << 1) | bit;\n            value >>>= 1;\n        }\n    }\n    getReverseBitsPrice(value, numBits) {\n        let price = 0;\n        let modelIndex = 1;\n        for (let i = 0; i < numBits; i++) {\n            const bit = value & 1;\n            price += getBitPrice(this.posEncoders[modelIndex], bit);\n            modelIndex = (modelIndex << 1) | bit;\n            value >>>= 1;\n        }\n        return price;\n    }\n}\n/**\n * LZMA Encoder class that handles compression operations\n */\nexport class Encoder {\n    encoderState = new EncoderState();\n    positionEncoder = new PositionEncoder();\n    // Core state properties\n    _state = 0;\n    _previousByte = 0;\n    _distTableSize = 0;\n    _longestMatchWasFound = 0;\n    _optimumEndIndex = 0;\n    _optimumCurrentIndex = 0;\n    _additionalOffset = 0;\n    // Dictionary and match finding\n    _dictionarySize = 0;\n    _matchFinder = null;\n    _dictionarySizePrev = 0;\n    _numFastBytes = 0;\n    // Literal encoding configuration\n    _numLiteralContextBits = 0;\n    _numLiteralPosStateBits = 0;\n    _posStateBits = 0;\n    _posStateMask = 0;\n    // Stream and processing state\n    _needReleaseMFStream = 0;\n    _inStream = null;\n    _finished = 0;\n    nowPos64 = [0, 0];\n    // Distance and repetition arrays\n    _repDistances = initArray(4);\n    _optimum = [];\n    // Range encoder\n    _rangeEncoder = {\n        stream: {\n            buf: [],\n            count: 0,\n        },\n        rrange: 0,\n        cache: 0,\n        low: [0, 0],\n        cacheSize: 0,\n        position: [0, 0],\n        encodeBit: () => { },\n        encodeBitTree: () => { },\n        encodeDirectBits: () => { },\n    };\n    // Bit model arrays for different types of encoding decisions\n    _isMatch = initArray(0xC0);\n    _isRep = initArray(0x0C);\n    _isRepG0 = initArray(0x0C);\n    _isRepG1 = initArray(0x0C);\n    _isRepG2 = initArray(0x0C);\n    _isRep0Long = initArray(0xC0);\n    // Position and alignment encoders\n    _posSlotEncoder = [];\n    _posEncoders = initArray(0x72);\n    _posAlignEncoder = null;\n    // Length encoders\n    _lenEncoder = null;\n    _repMatchLenEncoder = null;\n    // Literal encoder\n    _literalEncoder = null;\n    // Distance and price arrays\n    _matchDistances = [];\n    _posSlotPrices = [];\n    _distancesPrices = [];\n    _alignPrices = initArray(0x10);\n    _matchPriceCount = 0;\n    _alignPriceCount = 0;\n    // Optimization arrays\n    reps = initArray(4);\n    repLens = initArray(4);\n    // Processing counters\n    processedInSize = [[0, 0]];\n    processedOutSize = [[0, 0]];\n    finished = [0];\n    properties = initArray(5);\n    tempPrices = initArray(0x80); // 128\n    // Match finding properties\n    _longestMatchLength = 0;\n    _matchFinderType = 1;\n    _numDistancePairs = 0;\n    _numFastBytesPrev = -1;\n    backRes = 0;\n    constructor() {\n        // Encoder is initialized with default values above\n        // Additional initialization will be done through specific init methods\n    }\n    /**\n     * Initialize basic encoder state\n     */\n    baseInit() {\n        this._state = 0;\n        this._previousByte = 0;\n        for (let i = 0; i < 4; ++i) {\n            this._repDistances[i] = 0;\n        }\n    }\n    /**\n     * Get optimum array\n     */\n    getOptimum() {\n        return this._optimum;\n    }\n    /**\n     * Get back result\n     */\n    getBackRes() {\n        return this.backRes;\n    }\n    setBackRes(backRes) {\n        this.backRes = backRes;\n    }\n    init() {\n        this.baseInit();\n        this.encoderState.initModels();\n        this.positionEncoder.init();\n        // Initialize optimum array properly\n        this._optimum = [];\n        for (let i = 0; i < 0x1000; i++) {\n            this._optimum[i] = {};\n        }\n        this.initEncoderState();\n        initBitModels(this._isMatch);\n        initBitModels(this._isRep0Long);\n        initBitModels(this._isRep);\n        initBitModels(this._isRepG0);\n        initBitModels(this._isRepG1);\n        initBitModels(this._isRepG2);\n        initBitModels(this._posEncoders);\n        this.initLiteralEncoder();\n        for (let i = 0; i < 4; ++i) {\n            initBitModels(this._posSlotEncoder[i].models);\n        }\n        if (this._lenEncoder) {\n            this._lenEncoder.init(1 << this._posStateBits);\n        }\n        if (this._repMatchLenEncoder) {\n            this._repMatchLenEncoder.init(1 << this._posStateBits);\n        }\n        if (this._posAlignEncoder) {\n            initBitModels(this._posAlignEncoder.models);\n        }\n        this._longestMatchWasFound = 0;\n        this._optimumEndIndex = 0;\n        this._optimumCurrentIndex = 0;\n        this._additionalOffset = 0;\n    }\n    /**\n     * Initialize encoder range coder\n     */\n    initEncoderState() {\n        this._rangeEncoder.low = [0, 0];\n        this._rangeEncoder.rrange = 0xFFFFFFFF;\n        this._rangeEncoder.cacheSize = 1;\n        this._rangeEncoder.cache = 0;\n        this._rangeEncoder.position = [0, 0];\n    }\n    /**\n     * Initialize literal encoder\n     */\n    initLiteralEncoder() {\n        const totalStates = 1 << (this._literalEncoder.numPrevBits + this._literalEncoder.numPosBits);\n        for (let i = 0; i < totalStates; ++i) {\n            initBitModels(this._literalEncoder.coders[i].decoders);\n        }\n    }\n    /**\n     * Create optimum structures\n     */\n    createOptimumStructures() {\n        for (let i = 0; i < 0x1000; ++i) {\n            this._optimum[i] = {};\n        }\n        for (let i = 0; i < 4; ++i) {\n            this._posSlotEncoder[i] = createBitTree(6);\n        }\n    }\n    /**\n     * Create length price table encoder\n     */\n    createLenPriceTableEncoder() {\n        const encoder = new LenEncoder();\n        encoder.initPriceTable();\n        return encoder;\n    }\n    /**\n     * Create literal encoder encoder2\n     */\n    createLiteralEncoderEncoder2() {\n        const encoder = {\n            decoders: initArray(0x300),\n        };\n        return encoder;\n    }\n    /**\n     * Create literal encoder\n     */\n    createLiteralEncoder() {\n        // Check if we need to recreate the encoder\n        if (this._literalEncoder != null\n            && this._literalEncoder.numPrevBits == this._numLiteralContextBits\n            && this._literalEncoder.numPosBits == this._numLiteralPosStateBits) {\n            return;\n        }\n        // Replace #LZMA_Encoder_LiteralEncoder_Create with LitCoder instantiation\n        this._literalEncoder = new LitCoder(this._numLiteralPosStateBits, this._numLiteralContextBits);\n    }\n    /**\n     * Initialize completely with proper encoder state\n     */\n    initialize() {\n        // Initialize encoder structures first\n        this._lenEncoder = this.createLenPriceTableEncoder();\n        this._repMatchLenEncoder = this.createLenPriceTableEncoder();\n        this._posAlignEncoder = createBitTree(0x04);\n        // Initialize optimum array\n        this._optimum = [];\n        this.createOptimumStructures();\n        // Create literal encoder\n        this.createLiteralEncoder();\n        // Now call init to set up the state\n        this.init();\n    }\n    /**\n     * Configure encoder settings\n     */\n    configure(mode) {\n        this.setDictionarySize(0x1 << mode.searchDepth);\n        this._numFastBytes = mode.filterStrength;\n        this._matchFinderType = mode.modeIndex;\n        // lc is always 3, lp is always 0, pb is always 2\n        this._numLiteralContextBits = 0x3;\n        this._numLiteralPosStateBits = 0x0;\n        this._posStateBits = 0x2;\n        this._posStateMask = 0x3;\n    }\n    /**\n     * Set dictionary size\n     */\n    setDictionarySize(dictionarySize) {\n        this._dictionarySize = dictionarySize;\n        let dicLogSize = 0;\n        for (; dictionarySize > (1 << dicLogSize); ++dicLogSize)\n            ;\n        this._distTableSize = dicLogSize * 2;\n    }\n    /**\n     * Encode a bit using range coder\n     */\n    encodeBit(probs, index, symbol) {\n        const rangeEncoder = this._rangeEncoder;\n        let newBound, prob = probs[index];\n        newBound = (rangeEncoder.rrange >>> 11) * prob;\n        if (!symbol) {\n            rangeEncoder.rrange = newBound;\n            probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;\n        }\n        else {\n            // Need helper methods for 64-bit arithmetic\n            rangeEncoder.low = add64(rangeEncoder.low, this.and64(fromInt64(newBound), [0xFFFFFFFF, 0]));\n            rangeEncoder.rrange -= newBound;\n            probs[index] = prob - (prob >>> 5) << 16 >> 16;\n        }\n        if (!(rangeEncoder.rrange & -0x1000000)) {\n            rangeEncoder.rrange <<= 8;\n            this.shiftLow();\n        }\n    }\n    /**\n     * Encode bit tree\n     */\n    encodeBitTree(encoder, symbol) {\n        let bit, bitIndex, m = 1;\n        for (bitIndex = encoder.numBitLevels; bitIndex != 0;) {\n            bitIndex -= 1;\n            bit = symbol >>> bitIndex & 1;\n            this.encodeBit(encoder.models, m, bit);\n            m = m << 1 | bit;\n        }\n    }\n    /**\n     * Encode literal\n     */\n    encodeLiteral(encoder, symbol) {\n        let bit, context = 1;\n        for (let i = 7; i >= 0; --i) {\n            bit = (symbol >> i) & 1;\n            this.encodeBit(encoder.decoders, context, bit);\n            context = context << 1 | bit;\n        }\n    }\n    /**\n     * Encode matched literal\n     */\n    encodeMatched(encoder, matchByte, symbol) {\n        let bit, matchBit, state, same = true, context = 1;\n        for (let i = 7; i >= 0; --i) {\n            bit = (symbol >> i) & 1;\n            state = context;\n            if (same) {\n                matchBit = (matchByte >> i) & 1;\n                state += (1 + matchBit) << 8;\n                same = matchBit === bit;\n            }\n            this.encodeBit(encoder.decoders, state, bit);\n            context = context << 1 | bit;\n        }\n    }\n    /**\n     * Encode length using direct method calls\n     */\n    encodeLength(encoder, symbol, posState) {\n        encoder.encode(symbol, posState, this);\n    }\n    /**\n     * Encode direct bits\n     */\n    encodeDirectBits(valueToEncode, numTotalBits) {\n        const rangeEncoder = this._rangeEncoder;\n        for (let i = numTotalBits - 1; i >= 0; i -= 1) {\n            rangeEncoder.rrange >>>= 1;\n            if ((valueToEncode >>> i & 1) == 1) {\n                rangeEncoder.low = add64(rangeEncoder.low, fromInt64(rangeEncoder.rrange));\n            }\n            if (!(rangeEncoder.rrange & -0x1000000)) {\n                rangeEncoder.rrange <<= 8;\n                this.shiftLow();\n            }\n        }\n    }\n    /**\n     * Reverse encode\n     */\n    reverseEncode(symbol) {\n        const posAlignEncoder = this._posAlignEncoder;\n        if (!posAlignEncoder)\n            return;\n        let bit, m = 1;\n        for (let i = 0; i < posAlignEncoder.numBitLevels; ++i) {\n            bit = symbol & 1;\n            this.encodeBit(posAlignEncoder.models, m, bit);\n            m = m << 1 | bit;\n            symbol >>= 1;\n        }\n    }\n    /**\n     * Reverse encode range\n     */\n    reverseEncodeRange(startIndex, numBitLevels, symbol) {\n        let bit, m = 1;\n        for (let i = 0; i < numBitLevels; ++i) {\n            bit = symbol & 1;\n            this.encodeBit(this._posEncoders, startIndex + m, bit);\n            m = m << 1 | bit;\n            symbol >>= 1;\n        }\n    }\n    /**\n     * Write end marker\n     */\n    writeEndMarker(positionState) {\n        this.encodeBit(this._isMatch, (this._state << 4) + positionState, 1);\n        this.encodeBit(this._isRep, this._state, 0);\n        this._state = this._state < 7 ? 7 : 10;\n        this.encodeLength(this._lenEncoder, 0, positionState);\n        const posSlot = 63;\n        const lenToPosState = getLenToPosState(2); // Length to position state for minimum length\n        this.encodeBitTree(this._posSlotEncoder[lenToPosState], posSlot);\n        this.encodeDirectBits(67108863, 26);\n        this.reverseEncode(15);\n    }\n    /**\n     * Encode length with price table update\n     */\n    encodeLengthWithPriceUpdate(encoder, symbol, posState) {\n        encoder.encodeWithUpdate(symbol, posState, this);\n    }\n    and64(a, b) {\n        const highBits = ~~Math.max(Math.min(a[1] / 0x100000000, 0x7FFFFFFF), -0x80000000) & ~~Math.max(Math.min(b[1] / 0x100000000, 0x7FFFFFFF), -0x80000000);\n        const lowBits = lowBits64(a) & lowBits64(b);\n        let high = highBits * 0x100000000;\n        let low = lowBits;\n        if (lowBits < 0) {\n            low += 0x100000000;\n        }\n        return [low, high];\n    }\n    shru64(a, n) {\n        n &= 0x3F;\n        let shiftFact = this.pwrAsDouble(n);\n        let sr = create64(Math.floor(a[0] / shiftFact), a[1] / shiftFact);\n        if (a[1] < 0) {\n            sr = add64(sr, this.shl64([2, 0], 0x3F - n));\n        }\n        return sr;\n    }\n    shl64(a, n) {\n        let diff, newHigh, newLow, twoToN;\n        n &= 0x3F;\n        if (a[0] == 0 && a[1] == -9223372036854775808) {\n            if (!n) {\n                return a;\n            }\n            return [0, 0];\n        }\n        if (a[1] < 0) {\n            throw new Error(\"Neg\");\n        }\n        twoToN = this.pwrAsDouble(n);\n        newHigh = a[1] * twoToN % 1.8446744073709552E19;\n        newLow = a[0] * twoToN;\n        diff = newLow - newLow % 0x100000000;\n        newHigh += diff;\n        newLow -= diff;\n        if (newHigh >= 9223372036854775807) {\n            newHigh -= 1.8446744073709552E19;\n        }\n        return [newLow, newHigh];\n    }\n    pwrAsDouble(n) {\n        if (n <= 0x1E) {\n            return 1 << n;\n        }\n        return this.pwrAsDouble(0x1E) * this.pwrAsDouble(n - 0x1E);\n    }\n    /**\n     * Shift low helper (proper implementation) - public method for external access\n     */\n    shiftLow() {\n        const rangeEncoder = this._rangeEncoder;\n        const LowHi = lowBits64(this.shru64(rangeEncoder.low, 32));\n        if (LowHi != 0 || compare64(rangeEncoder.low, [4278190080, 0]) < 0) {\n            rangeEncoder.position = add64(rangeEncoder.position, fromInt64(rangeEncoder.cacheSize));\n            let temp = rangeEncoder.cache;\n            do {\n                this.writeToStream(rangeEncoder.stream, temp + LowHi);\n                temp = 255;\n            } while ((rangeEncoder.cacheSize -= 1) != 0);\n            rangeEncoder.cache = lowBits64(rangeEncoder.low) >>> 24;\n        }\n        rangeEncoder.cacheSize += 1;\n        rangeEncoder.low = this.shl64(this.and64(rangeEncoder.low, [16777215, 0]), 8);\n    }\n    /**\n     * Write byte to stream\n     */\n    writeToStream(stream, b) {\n        if (!stream)\n            return;\n        // Ensure buffer has enough capacity\n        if (stream.count >= stream.buf.length) {\n            const newSize = Math.max(stream.buf.length * 2, stream.count + 1);\n            const newBuf = new Array(newSize);\n            for (let i = 0; i < stream.count; i++) {\n                newBuf[i] = stream.buf[i];\n            }\n            stream.buf = newBuf;\n        }\n        stream.buf[stream.count++] = b << 24 >> 24;\n    }\n    initRangeEncoder() {\n        this._rangeEncoder.position = [0, 0];\n        this._rangeEncoder.low = [0, 0];\n        this._rangeEncoder.rrange = -1;\n        this._rangeEncoder.cacheSize = 1;\n        this._rangeEncoder.cache = 0;\n    }\n    /**\n     * Fill alignment prices for position alignment encoder\n     */\n    fillAlignPrices() {\n        for (let i = 0; i < 16; ++i) {\n            this._alignPrices[i] = this.reverseGetPrice(this._posAlignEncoder, i);\n        }\n        this._alignPriceCount = 0;\n    }\n    /**\n     * Fill distance prices for position encoders\n     */\n    fillDistancesPrices() {\n        let baseVal, bitTreeEncoder, footerBits, posSlot, st, st2;\n        for (let i = 4; i < 0x80; ++i) {\n            posSlot = this.getPosSlot(i);\n            footerBits = (posSlot >> 1) - 1;\n            baseVal = (2 | (posSlot & 1)) << footerBits;\n            this.tempPrices[i] = this.reverseGetPriceArray(this._posEncoders, baseVal - posSlot - 1, footerBits, i - baseVal);\n        }\n        for (let lenToPosState = 0; lenToPosState < 4; ++lenToPosState) {\n            bitTreeEncoder = this._posSlotEncoder[lenToPosState];\n            st = lenToPosState << 6;\n            for (posSlot = 0; posSlot < this._distTableSize; posSlot += 1) {\n                this._posSlotPrices[st + posSlot] = this.rangeCoder_Encoder_GetPrice_1(bitTreeEncoder, posSlot);\n            }\n            for (posSlot = 14; posSlot < this._distTableSize; posSlot += 1) {\n                this._posSlotPrices[st + posSlot] += (posSlot >> 1) - 1 - 4 << 6;\n            }\n            st2 = lenToPosState * 0x80;\n            for (let i = 0; i < 4; ++i) {\n                this._distancesPrices[st2 + i] = this._posSlotPrices[st + i];\n            }\n            for (let i = 4; i < 0x80; ++i) {\n                this._distancesPrices[st2 + i] = this._posSlotPrices[st + this.getPosSlot(i)] + this.tempPrices[i];\n            }\n        }\n        this._matchPriceCount = 0;\n    }\n    /**\n     * Get position slot for a distance value\n     */\n    getPosSlot(pos) {\n        if (pos < 0x800) {\n            return G_FAST_POS[pos];\n        }\n        if (pos < 0x200000) {\n            return G_FAST_POS[pos >> 10] + 20;\n        }\n        return G_FAST_POS[pos >> 20] + 40;\n    }\n    /**\n     * Get reverse price for bit tree encoder\n     */\n    reverseGetPrice(encoder, symbol) {\n        let bit, m = 1, price = 0;\n        for (let i = encoder.numBitLevels; i != 0; i -= 1) {\n            bit = symbol & 1;\n            symbol >>>= 1;\n            price += this.getPrice(encoder.models[m], bit);\n            m = m << 1 | bit;\n        }\n        return price;\n    }\n    /**\n     * Get reverse price for array of models\n     */\n    reverseGetPriceArray(Models, startIndex, NumBitLevels, symbol) {\n        let bit, m = 1, price = 0;\n        for (let i = NumBitLevels; i != 0; i -= 1) {\n            bit = symbol & 1;\n            symbol >>>= 1;\n            price += PROB_PRICES[((Models[startIndex + m] - bit ^ -bit) & 2047) >>> 2];\n            m = m << 1 | bit;\n        }\n        return price;\n    }\n    /**\n     * Get price for probability model (optimized)\n     */\n    getPrice(Prob, symbol) {\n        return getBitPrice(Prob, symbol);\n    }\n    /**\n     * Get price for bit tree encoder (optimized)\n     */\n    rangeCoder_Encoder_GetPrice_1(encoder, symbol) {\n        return getBitTreePrice(encoder, symbol);\n    }\n    /**\n     * Create encoder optimization structures (optimized)\n     */\n    createEncoderStructures() {\n        // Pre-allocate optimum array with proper size\n        // Initialize optimum array properly\n        this._optimum = [];\n        for (let i = 0; i < 0x1000; i++) {\n            this._optimum[i] = {};\n        }\n        for (let i = 0; i < 0x1000; ++i) {\n            this._optimum[i] = {};\n        }\n        // Initialize position slot encoders\n        this._posSlotEncoder = new Array(4);\n        for (let i = 0; i < 4; ++i) {\n            this._posSlotEncoder[i] = createBitTree(6);\n        }\n    }\n    /**\n     * Create match finder and encoder structures (replaces #Create_2)\n     */\n    createMatchFinderAndStructures() {\n        // Create match finder if needed\n        if (!this._matchFinder) {\n            const binTree = {};\n            let numHashBytes = 4;\n            if (!this._matchFinderType) {\n                numHashBytes = 2;\n            }\n            // Set match finder type (replaces #SetType)\n            binTree.HASH_ARRAY = numHashBytes > 2;\n            if (binTree.HASH_ARRAY) {\n                binTree.kNumHashDirectBytes = 0;\n                binTree.kMinMatchCheck = 4;\n                binTree.kFixHashSize = 66560;\n            }\n            else {\n                binTree.kNumHashDirectBytes = 2;\n                binTree.kMinMatchCheck = 3;\n                binTree.kFixHashSize = 0;\n            }\n            // Initialize other match finder properties\n            binTree._cyclicBufferSize = 0;\n            binTree._cyclicBufferPos = 0;\n            binTree._streamPos = 0;\n            binTree._cutValue = 0xff;\n            binTree._matchMaxLen = 0;\n            binTree._streamEndWasReached = 0;\n            binTree._pos = 0;\n            binTree._posLimit = 0;\n            binTree._son = [];\n            binTree._hash = [];\n            binTree._bufferBase = [];\n            binTree._blockSize = 0;\n            binTree._keepSizeAfter = 0;\n            binTree._keepSizeBefore = 0;\n            binTree._pointerToLastSafePosition = 0;\n            this._matchFinder = binTree;\n        }\n        // Create literal encoder if needed\n        this.createLiteralEncoder();\n        // Check if we need to recreate structures\n        if (this._dictionarySize == this._dictionarySizePrev\n            && this._numFastBytesPrev == this._numFastBytes) {\n            return;\n        }\n        // This would call equivalent of #Create_3(0x1000, 0x0112) logic\n        // For now, we'll handle the basic setup\n        this._dictionarySizePrev = this._dictionarySize;\n        this._numFastBytesPrev = this._numFastBytes;\n    }\n    /**\n     * Get literal encoder subcoder (utility method)\n     */\n    getSubCoderUtility(pos, prevByte) {\n        // Calculate position mask bits\n        const posBits = pos & this._literalEncoder.posMask;\n        const posShifted = posBits << this._literalEncoder.numPrevBits;\n        // Calculate previous byte bits\n        const prevByteShift = 0x08 - this._literalEncoder.numPrevBits;\n        const prevByteBits = (prevByte & 0xFF) >>> prevByteShift;\n        // Combine position and prevByte bits to get final index\n        const coderIndex = posShifted + prevByteBits;\n        return this._literalEncoder.coders[coderIndex];\n    }\n}\n", "import { arraycopy } from \"./utils.js\";\n/**\n * LzInWindow - Input Window helper for LZMA encoding\n *\n * This class manages the input window operations for LZMA encoding,\n * including buffer management, position tracking, and input stream reading.\n */\nexport class LzInWindow {\n    matchFinder;\n    constructor(matchFinder) {\n        this.matchFinder = matchFinder;\n    }\n    /**\n     * Get a byte at the specified index relative to current position\n     */\n    getIndexByte(index) {\n        const byte = this.matchFinder._bufferBase[this.matchFinder._bufferOffset + this.matchFinder._pos + index];\n        return byte;\n    }\n    /**\n     * Calculate match length between current position and a previous position\n     */\n    getMatchLen(index, distance, limit) {\n        if (this.matchFinder._streamEndWasReached) {\n            if (this.matchFinder._pos + index + limit > this.matchFinder._streamPos) {\n                limit = this.matchFinder._streamPos - (this.matchFinder._pos + index);\n            }\n        }\n        ++distance;\n        let i;\n        const pby = this.matchFinder._bufferOffset + this.matchFinder._pos + index;\n        for (i = 0; i < limit\n            && this.matchFinder._bufferBase[pby + i]\n                == this.matchFinder._bufferBase[pby + i - distance]; ++i)\n            ;\n        return i;\n    }\n    /**\n     * Get number of available bytes in the input window\n     */\n    getNumAvailableBytes() {\n        return this.matchFinder._streamPos - this.matchFinder._pos;\n    }\n    /**\n     * Move buffer block when reaching buffer boundaries\n     */\n    moveBlock() {\n        let offset = this.matchFinder._bufferOffset + this.matchFinder._pos - this.matchFinder._keepSizeBefore;\n        if (offset > 0) {\n            --offset;\n        }\n        const numBytes = this.matchFinder._bufferOffset + this.matchFinder._streamPos - offset;\n        for (let i = 0; i < numBytes; ++i) {\n            this.matchFinder._bufferBase[i] = this.matchFinder._bufferBase[offset + i];\n        }\n        this.matchFinder._bufferOffset -= offset;\n    }\n    /**\n     * Move position by one and handle buffer management\n     */\n    movePos() {\n        this.matchFinder._pos += 1;\n        if (this.matchFinder._pos > this.matchFinder._posLimit) {\n            const pointerToPosition = this.matchFinder._bufferOffset + this.matchFinder._pos;\n            if (pointerToPosition > this.matchFinder._pointerToLastSafePosition) {\n                this.moveBlock();\n            }\n            this.readBlock();\n        }\n    }\n    /**\n     * Read a block of data from the input stream\n     */\n    readBlock() {\n        if (this.matchFinder._streamEndWasReached) {\n            return;\n        }\n        while (true) {\n            const size = -this.matchFinder._bufferOffset + this.matchFinder._blockSize - this.matchFinder._streamPos;\n            if (!size) {\n                return;\n            }\n            const bytesRead = this.readFromStream(this.matchFinder._bufferOffset + this.matchFinder._streamPos, size);\n            if (bytesRead == -1) {\n                this.matchFinder._posLimit = this.matchFinder._streamPos;\n                const pointerToPosition = this.matchFinder._bufferOffset + this.matchFinder._posLimit;\n                if (pointerToPosition > this.matchFinder._pointerToLastSafePosition) {\n                    this.matchFinder._posLimit = this.matchFinder._pointerToLastSafePosition - this.matchFinder._bufferOffset;\n                }\n                this.matchFinder._streamEndWasReached = 1;\n                return;\n            }\n            this.matchFinder._streamPos += bytesRead;\n            if (this.matchFinder._streamPos >= this.matchFinder._pos + this.matchFinder._keepSizeAfter) {\n                this.matchFinder._posLimit = this.matchFinder._streamPos - this.matchFinder._keepSizeAfter;\n            }\n        }\n    }\n    /**\n     * Reduce all position offsets by the specified value\n     */\n    reduceOffsets(subValue) {\n        this.matchFinder._bufferOffset += subValue;\n        this.matchFinder._posLimit -= subValue;\n        this.matchFinder._pos -= subValue;\n        this.matchFinder._streamPos -= subValue;\n    }\n    /**\n     * Read data from the input stream into the buffer\n     */\n    readFromStream(off, len) {\n        const stream = this.matchFinder._stream;\n        const buffer = this.matchFinder._bufferBase;\n        if (stream.pos >= stream.count) {\n            return -1;\n        }\n        let srcBuf;\n        if (stream.buf instanceof Uint8Array) {\n            srcBuf = Array.from(stream.buf);\n        }\n        else if (stream.buf instanceof ArrayBuffer) {\n            srcBuf = Array.from(new Uint8Array(stream.buf));\n        }\n        else {\n            srcBuf = stream.buf;\n        }\n        len = Math.min(len, stream.count - stream.pos);\n        arraycopy(srcBuf, stream.pos, buffer, off, len);\n        stream.pos += len;\n        return len;\n    }\n}\n", "import { DICTIONARY_SIZE_THRESHOLD, initArray, } from \"./utils.js\";\n/**\n * Match finder configuration helpers\n * Pure functions extracted from LZMA class for better modularity\n */\n/**\n * Compute window reservation size for match finder buffer allocation\n */\nexport function computeWindowReservSize(dictionarySize, keepBefore, numFastBytes, keepAfter) {\n    return ~~((dictionarySize + keepBefore + numFastBytes + keepAfter) / 2) + 0x100;\n}\n/**\n * Ensure cyclic buffer is properly sized and allocated\n */\nexport function ensureCyclicBuffer(matchFinder, dictionarySize) {\n    const cyclicBufferSize = dictionarySize + 1;\n    if (matchFinder._cyclicBufferSize !== cyclicBufferSize) {\n        const doubledCyclicBufferSize = (matchFinder._cyclicBufferSize = cyclicBufferSize) * 2;\n        matchFinder._son = initArray(doubledCyclicBufferSize);\n    }\n}\n/**\n * Compute hash size for match finder hash table\n */\nexport function computeHashSize(dictionarySize, hashArrayEnabled) {\n    let hs = 0x10000;\n    let hashMask = 0;\n    if (hashArrayEnabled) {\n        hs = dictionarySize - 1;\n        hs |= hs >> 1;\n        hs |= hs >> 2;\n        hs |= hs >> 4;\n        hs |= hs >> 0x08;\n        hs >>= 1;\n        hs |= 0xFFFF;\n        if (hs > 0x1000000) {\n            hs >>= 1;\n        }\n        hashMask = hs;\n        hs += 1;\n        // Add kFixHashSize (assumed to be available on matchFinder)\n        // This will be passed in from the calling context\n    }\n    return { hashMask, hashSizeSum: hs };\n}\n/**\n * Set cut value for match finder based on fast bytes setting\n */\nexport function setCutValue(numFastBytes) {\n    return 0x10 + (numFastBytes >> 1);\n}\n/**\n * Set maximum match length for match finder\n */\nexport function setMatchMaxLen(numFastBytes) {\n    return numFastBytes;\n}\n/**\n * Check if dictionary size is below threshold requiring special handling\n */\nexport function isDictionarySizeBelowThreshold(dictionarySize) {\n    return dictionarySize < DICTIONARY_SIZE_THRESHOLD;\n}\n", "import { DecoderChunker, EncoderChunker, } from \"./chunker.js\";\nimport { Decoder } from \"./decoder.js\";\nimport { Encoder, } from \"./encoder.js\";\nimport { LzInWindow } from \"./lz-in-window.js\";\nimport { computeHashSize, computeWindowReservSize, ensureCyclicBuffer, isDictionarySizeBelowThreshold, setCutValue, setMatchMaxLen, } from \"./match-finder-config.js\";\nimport { _MAX_UINT32, add64, arraycopy, compare64, CRC32_TABLE, createBitTree, DICTIONARY_SIZE_THRESHOLD, fromInt64, G_FAST_POS, getBitPrice, getLenToPosState, INFINITY_PRICE, initArray, lowBits64, N1_LONG_LIT, P0_LONG_LIT, P1_LONG_LIT, PROB_PRICES, shr64, stateUpdateChar, sub64, } from \"./utils.js\";\n/**\n * Compression modes\n */\nexport const MODES = {\n    1: { searchDepth: 0x10, filterStrength: 0x40, modeIndex: 0x00 },\n    2: { searchDepth: 0x14, filterStrength: 0x40, modeIndex: 0x00 },\n    3: { searchDepth: 0x13, filterStrength: 0x40, modeIndex: 0x01 },\n    4: { searchDepth: 0x14, filterStrength: 0x40, modeIndex: 0x01 },\n    5: { searchDepth: 0x15, filterStrength: 0x80, modeIndex: 0x01 },\n    6: { searchDepth: 0x16, filterStrength: 0x80, modeIndex: 0x01 },\n    7: { searchDepth: 0x17, filterStrength: 0x80, modeIndex: 0x01 },\n    8: { searchDepth: 0x18, filterStrength: 0xFF, modeIndex: 0x01 },\n    9: { searchDepth: 0x19, filterStrength: 0xFF, modeIndex: 0x01 },\n};\nexport class LZMA {\n    #encoder;\n    #decoder;\n    #lzInWindow = null;\n    #compressor;\n    #decompressor;\n    constructor() {\n        this.#encoder = new Encoder();\n        this.#decoder = new Decoder();\n        this.#compressor = this.#initCompressor();\n        this.#decompressor = this.#initDecompressor();\n    }\n    #initCompressor() {\n        const encoderChunker = new EncoderChunker(this);\n        return {\n            chunker: encoderChunker,\n            output: {\n                buf: initArray(32),\n                count: 0,\n                write: () => { },\n            },\n        };\n    }\n    #initDecompressor() {\n        const decoderChunker = new DecoderChunker(this.#decoder);\n        return {\n            chunker: decoderChunker,\n            output: {\n                buf: initArray(0x20),\n                count: 0,\n                write: () => { },\n            },\n        };\n    }\n    #read(inputStream) {\n        if (inputStream.pos >= inputStream.count) {\n            return -1;\n        }\n        let value;\n        if (inputStream.buf instanceof ArrayBuffer) {\n            value = new Uint8Array(inputStream.buf)[inputStream.pos++];\n        }\n        else if (inputStream.buf instanceof Uint8Array) {\n            value = inputStream.buf[inputStream.pos++];\n        }\n        else {\n            value = inputStream.buf[inputStream.pos++];\n        }\n        return value & 0xFF;\n    }\n    #toByteArray(output) {\n        const data = output.buf.slice(0, output.count);\n        return data;\n    }\n    #write(buffer, b) {\n        if (!buffer)\n            return;\n        if (buffer.count >= buffer.buf.length) {\n            const newSize = Math.max(buffer.buf.length * 2, buffer.count + 1);\n            const newBuf = new Array(newSize);\n            for (let i = 0; i < buffer.count; i++) {\n                newBuf[i] = buffer.buf[i];\n            }\n            buffer.buf = newBuf;\n        }\n        buffer.buf[buffer.count++] = b << 24 >> 24;\n    }\n    #write_0(buffer, buf, off, len) {\n        const requiredSize = buffer.count + len;\n        if (requiredSize > buffer.buf.length) {\n            const newSize = Math.max(buffer.buf.length * 2, requiredSize);\n            const newBuf = new Array(newSize);\n            for (let i = 0; i < buffer.count; i++) {\n                newBuf[i] = buffer.buf[i];\n            }\n            buffer.buf = newBuf;\n        }\n        arraycopy(buf, off, buffer.buf, buffer.count, len);\n        buffer.count += len;\n    }\n    #getChars(inputString, srcBegin, srcEnd, dst, dstBegin) {\n        for (let srcIdx = srcBegin; srcIdx < srcEnd; ++srcIdx) {\n            dst[dstBegin++] = inputString.charCodeAt(srcIdx);\n        }\n    }\n    #configure(mode) {\n        this.#encoder.initialize();\n        this.#encoder.configure(mode);\n    }\n    #initCompression(input, len, mode) {\n        if (compare64(len, N1_LONG_LIT) < 0) {\n            throw new Error(\"invalid length \" + len);\n        }\n        this.#compressor.length_0 = len;\n        this.#Encoder();\n        this.#configure(mode);\n        this.writeHeaderProperties();\n        for (let i = 0; i < 64; i += 8) {\n            this.#write(this.#compressor.output, lowBits64(shr64(len, i)) & 0xFF);\n        }\n        this.#encoder._needReleaseMFStream = 0;\n        this.#encoder._inStream = input;\n        this.#encoder._finished = 0;\n        this.#Create_2();\n        this.#encoder._rangeEncoder.stream = this.#compressor.output;\n        this.#encoder.init();\n        this.#encoder.fillDistancesPrices();\n        this.#encoder.fillAlignPrices();\n        this.#encoder._lenEncoder.setTableSize(this.#encoder._numFastBytes + 1 - 2);\n        this.#encoder._lenEncoder.updateTables(1 << this.#encoder._posStateBits);\n        this.#encoder._repMatchLenEncoder.setTableSize(this.#encoder._numFastBytes + 1 - 2);\n        this.#encoder._repMatchLenEncoder.updateTables(1 << this.#encoder._posStateBits);\n        this.#encoder.nowPos64 = P0_LONG_LIT;\n        this.#compressor.chunker.encoder = this.#encoder;\n        this.#compressor.chunker.alive = 1;\n    }\n    #byteArrayCompressor(data, mode) {\n        const inputSize = data instanceof ArrayBuffer ? data.byteLength : data.length;\n        const estimatedOutputSize = Math.max(32, Math.ceil(inputSize * 1.2));\n        this.#compressor.output = {\n            buf: initArray(estimatedOutputSize),\n            count: 0,\n            write: () => { },\n        };\n        const inputBuffer = {\n            pos: 0,\n            buf: data instanceof ArrayBuffer\n                ? new Uint8Array(data)\n                : data,\n            count: data instanceof ArrayBuffer\n                ? new Uint8Array(data).length\n                : data.length,\n        };\n        this.#initCompression(inputBuffer, fromInt64(data instanceof ArrayBuffer ? data.byteLength : data.length), mode);\n    }\n    #initDecompression(input) {\n        let hex_length = \"\", properties = [], r, tmp_length;\n        for (let i = 0; i < 5; ++i) {\n            r = this.#read(input);\n            if (r == -1) {\n                throw new Error(\"truncated input\");\n            }\n            properties[i] = r << 24 >> 24;\n        }\n        const isDecoderInitialized = !this.#decoder.setDecoderProperties(properties)\n            ? 1\n            : 0;\n        if (isDecoderInitialized) {\n            throw new Error(\"corrupted input\");\n        }\n        for (let i = 0; i < 64; i += 8) {\n            r = this.#read(input);\n            if (r == -1) {\n                throw new Error(\"truncated input\");\n            }\n            r = r.toString(0x10);\n            if (r.length == 1)\n                r = \"0\" + r;\n            hex_length = r + \"\" + hex_length;\n        }\n        /**\n         * Was the length set in the header (if it was compressed from a stream, the\n         * length is all f\"s).\n         */\n        if (/^0+$|^f+$/i.test(hex_length)) {\n            this.#compressor.length_0 = N1_LONG_LIT;\n        }\n        else {\n            /**\n             * NOTE: If there is a problem with the decoder because of the length,\n             * you can always set the length to -1 (N1_longLit) which means unknown.\n             */\n            tmp_length = parseInt(hex_length, 0x10);\n            if (tmp_length > _MAX_UINT32) {\n                this.#compressor.length_0 = N1_LONG_LIT;\n            }\n            else {\n                this.#compressor.length_0 = fromInt64(tmp_length);\n            }\n        }\n        this.#decompressor.chunker = this.#CodeInChunks(input, this.#compressor.length_0);\n    }\n    #byteArrayDecompressor(data) {\n        const inputDataSize = data instanceof ArrayBuffer ? data.byteLength : data.length;\n        const minBufferSize = 0x20; // 32 bytes minimum\n        const estimatedOutputSize = inputDataSize * 2; // Estimate 2x expansion for decompression\n        const initialBufferSize = Math.max(minBufferSize, estimatedOutputSize);\n        this.#decompressor.output = {\n            buf: initArray(initialBufferSize),\n            count: 0,\n            write: () => { },\n        };\n        const inputBuffer = {\n            buf: data,\n            pos: 0,\n            count: data instanceof ArrayBuffer ? data.byteLength : data.length,\n        };\n        this.#initDecompression(inputBuffer);\n    }\n    #Create_4(keepSizeBefore, keepSizeAfter, keepSizeReserv) {\n        let blockSize;\n        this.#encoder._matchFinder._keepSizeBefore = keepSizeBefore;\n        this.#encoder._matchFinder._keepSizeAfter = keepSizeAfter;\n        blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;\n        if (this.#encoder._matchFinder._bufferBase == null || this.#encoder._matchFinder._blockSize != blockSize) {\n            this.#encoder._matchFinder._bufferBase = initArray(blockSize);\n            this.#encoder._matchFinder._blockSize = blockSize;\n        }\n        this.#encoder._matchFinder._pointerToLastSafePosition = this.#encoder._matchFinder._blockSize - keepSizeAfter;\n    }\n    #MovePos_1() {\n        const matchFinder = this.#compressor.chunker.encoder._matchFinder;\n        let pointerToPostion;\n        matchFinder._pos += 1;\n        if (matchFinder._pos > matchFinder._posLimit) {\n            pointerToPostion = matchFinder._bufferOffset + matchFinder._pos;\n            if (pointerToPostion > matchFinder._pointerToLastSafePosition) {\n                this.#lzInWindow.moveBlock();\n            }\n            this.#lzInWindow.readBlock();\n        }\n    }\n    #Create_3(keepAddBufferBefore, keepAddBufferAfter) {\n        const dictionarySize = this.#encoder._dictionarySize;\n        const numFastBytes = this.#encoder._numFastBytes;\n        if (isDictionarySizeBelowThreshold(dictionarySize)) {\n            this.#encoder._matchFinder._cutValue = setCutValue(numFastBytes);\n            const windowReservSize = computeWindowReservSize(dictionarySize, keepAddBufferBefore, numFastBytes, keepAddBufferAfter);\n            this.#Create_4(dictionarySize + keepAddBufferBefore, numFastBytes + keepAddBufferAfter, windowReservSize);\n            this.#encoder._matchFinder._matchMaxLen = setMatchMaxLen(numFastBytes);\n            ensureCyclicBuffer(this.#encoder._matchFinder, dictionarySize);\n            const { hashMask, hashSizeSum } = computeHashSize(dictionarySize, this.#encoder._matchFinder.HASH_ARRAY);\n            if (this.#encoder._matchFinder.HASH_ARRAY) {\n                this.#encoder._matchFinder._hashMask = hashMask;\n                const finalHashSizeSum = hashSizeSum + this.#encoder._matchFinder.kFixHashSize;\n                if (finalHashSizeSum !== this.#encoder._matchFinder._hashSizeSum) {\n                    this.#encoder._matchFinder._hashSizeSum = finalHashSizeSum;\n                    this.#encoder._matchFinder._hash = initArray(finalHashSizeSum);\n                }\n            }\n            else {\n                if (hashSizeSum !== this.#encoder._matchFinder._hashSizeSum) {\n                    this.#encoder._matchFinder._hashSizeSum = hashSizeSum;\n                    this.#encoder._matchFinder._hash = initArray(hashSizeSum);\n                }\n            }\n        }\n    }\n    #GetMatches() {\n        let count, cur, curMatch, curMatch2, curMatch3, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, maxLen, offset, pby1, ptr0, ptr1, temp;\n        const matchFinder = this.#compressor.chunker.encoder._matchFinder;\n        const distances = this.#compressor.chunker.encoder._matchDistances;\n        if (matchFinder._pos + matchFinder._matchMaxLen <= matchFinder._streamPos) {\n            lenLimit = matchFinder._matchMaxLen;\n        }\n        else {\n            lenLimit = matchFinder._streamPos - matchFinder._pos;\n            if (lenLimit < matchFinder.kMinMatchCheck) {\n                this.#MovePos_0();\n                return 0;\n            }\n        }\n        offset = 0;\n        matchMinPos = matchFinder._pos > matchFinder._cyclicBufferSize\n            ? matchFinder._pos - matchFinder._cyclicBufferSize\n            : 0;\n        cur = matchFinder._bufferOffset + matchFinder._pos;\n        maxLen = 1;\n        hash2Value = 0;\n        hash3Value = 0;\n        if (matchFinder.HASH_ARRAY) {\n            temp = CRC32_TABLE[matchFinder._bufferBase[cur] & 0xFF] ^ (matchFinder._bufferBase[cur + 1] & 0xFF);\n            hash2Value = temp & 0x3FF;\n            temp ^= (matchFinder._bufferBase[cur + 2] & 0xFF) << 0x08;\n            hash3Value = temp & 0xFFFF;\n            hashValue = (temp ^ (CRC32_TABLE[matchFinder._bufferBase[cur + 3] & 0xFF] << 5)) & matchFinder._hashMask;\n        }\n        else {\n            hashValue = (matchFinder._bufferBase[cur] & 0xFF) ^ ((matchFinder._bufferBase[cur + 1] & 0xFF) << 0x08);\n        }\n        curMatch = matchFinder._hash[matchFinder.kFixHashSize + hashValue] || 0;\n        if (matchFinder.HASH_ARRAY) {\n            curMatch2 = matchFinder._hash[hash2Value] || 0;\n            curMatch3 = matchFinder._hash[0x400 + hash3Value] || 0;\n            matchFinder._hash[hash2Value] = matchFinder._pos;\n            matchFinder._hash[0x400 + hash3Value] = matchFinder._pos;\n            if (curMatch2 > matchMinPos) {\n                if (matchFinder._bufferBase[matchFinder._bufferOffset + curMatch2] == matchFinder._bufferBase[cur]) {\n                    distances[offset++] = maxLen = 2;\n                    distances[offset++] = matchFinder._pos - curMatch2 - 1;\n                }\n            }\n            if (curMatch3 > matchMinPos) {\n                if (matchFinder._bufferBase[matchFinder._bufferOffset + curMatch3] == matchFinder._bufferBase[cur]) {\n                    if (curMatch3 == curMatch2) {\n                        offset -= 2;\n                    }\n                    distances[offset++] = maxLen = 3;\n                    distances[offset++] = matchFinder._pos - curMatch3 - 1;\n                    curMatch2 = curMatch3;\n                }\n            }\n            if (offset != 0 && curMatch2 == curMatch) {\n                offset -= 2;\n                maxLen = 1;\n            }\n        }\n        matchFinder._hash[matchFinder.kFixHashSize + hashValue] = matchFinder._pos;\n        ptr0 = (matchFinder._cyclicBufferPos << 1) + 1;\n        ptr1 = matchFinder._cyclicBufferPos << 1;\n        len0 = len1 = matchFinder.kNumHashDirectBytes;\n        if (matchFinder.kNumHashDirectBytes != 0) {\n            if (curMatch > matchMinPos) {\n                if (matchFinder._bufferBase[matchFinder._bufferOffset + curMatch + matchFinder.kNumHashDirectBytes] != matchFinder._bufferBase[cur + matchFinder.kNumHashDirectBytes]) {\n                    distances[offset++] = maxLen = matchFinder.kNumHashDirectBytes;\n                    distances[offset++] = matchFinder._pos - curMatch - 1;\n                }\n            }\n        }\n        count = matchFinder._cutValue;\n        while (1) {\n            if (curMatch <= matchMinPos || count == 0) {\n                count -= 1;\n                matchFinder._son[ptr0] = matchFinder._son[ptr1] = 0;\n                break;\n            }\n            delta = matchFinder._pos - curMatch;\n            cyclicPos = (delta <= matchFinder._cyclicBufferPos\n                ? matchFinder._cyclicBufferPos - delta\n                : matchFinder._cyclicBufferPos - delta + matchFinder._cyclicBufferSize) << 1;\n            pby1 = matchFinder._bufferOffset + curMatch;\n            len = len0 < len1 ? len0 : len1;\n            if (matchFinder._bufferBase[pby1 + len] == matchFinder._bufferBase[cur + len]) {\n                while ((len += 1) != lenLimit) {\n                    if (matchFinder._bufferBase[pby1 + len] != matchFinder._bufferBase[cur + len]) {\n                        break;\n                    }\n                }\n                if (maxLen < len) {\n                    distances[offset++] = maxLen = len;\n                    distances[offset++] = delta - 1;\n                    if (len == lenLimit) {\n                        matchFinder._son[ptr1] = matchFinder._son[cyclicPos];\n                        matchFinder._son[ptr0] = matchFinder._son[cyclicPos + 1];\n                        break;\n                    }\n                }\n            }\n            if ((matchFinder._bufferBase[pby1 + len] & 0xFF) < (matchFinder._bufferBase[cur + len] & 0xFF)) {\n                matchFinder._son[ptr1] = curMatch;\n                ptr1 = cyclicPos + 1;\n                curMatch = matchFinder._son[ptr1];\n                len1 = len;\n            }\n            else {\n                matchFinder._son[ptr0] = curMatch;\n                ptr0 = cyclicPos;\n                curMatch = matchFinder._son[ptr0];\n                len0 = len;\n            }\n        }\n        this.#MovePos_0();\n        return offset;\n    }\n    #Init_5() {\n        this.#compressor.chunker.encoder._matchFinder._bufferOffset = 0;\n        this.#compressor.chunker.encoder._matchFinder._pos = 0;\n        this.#compressor.chunker.encoder._matchFinder._streamPos = 0;\n        this.#compressor.chunker.encoder._matchFinder._streamEndWasReached = 0;\n        this.#lzInWindow.readBlock();\n        this.#compressor.chunker.encoder._matchFinder._cyclicBufferPos = 0;\n        this.#lzInWindow.reduceOffsets(-1);\n    }\n    #MovePos_0() {\n        let subValue;\n        const matchFinder = this.#compressor.chunker.encoder._matchFinder;\n        if ((matchFinder._cyclicBufferPos += 1) >= matchFinder._cyclicBufferSize) {\n            matchFinder._cyclicBufferPos = 0;\n        }\n        this.#MovePos_1();\n        if (matchFinder._pos == DICTIONARY_SIZE_THRESHOLD) {\n            subValue = matchFinder._pos - matchFinder._cyclicBufferSize;\n            this.#NormalizeLinks(matchFinder._cyclicBufferSize * 2, subValue);\n            this.#NormalizeLinks(matchFinder._hashSizeSum, subValue);\n            this.#lzInWindow.reduceOffsets(subValue);\n        }\n    }\n    /**\n     * This is only called after reading one whole gigabyte.\n     */\n    #NormalizeLinks(numItems, subValue) {\n        const items = this.#compressor.chunker.encoder._matchFinder._son;\n        for (let i = 0, value; i < numItems; ++i) {\n            value = items[i] || 0;\n            if (value <= subValue) {\n                value = 0;\n            }\n            else {\n                value -= subValue;\n            }\n            items[i] = value;\n        }\n    }\n    #SetType(binTree, numHashBytes) {\n        binTree.HASH_ARRAY = numHashBytes > 2;\n        if (binTree.HASH_ARRAY) {\n            binTree.kNumHashDirectBytes = 0;\n            binTree.kMinMatchCheck = 4;\n            binTree.kFixHashSize = 66560;\n        }\n        else {\n            binTree.kNumHashDirectBytes = 2;\n            binTree.kMinMatchCheck = 3;\n            binTree.kFixHashSize = 0;\n        }\n    }\n    #Skip(num) {\n        const matchFinder = this.#compressor.chunker.encoder._matchFinder;\n        let count, cur, curMatch, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, pby1, ptr0, ptr1, temp;\n        do {\n            if (matchFinder._pos + matchFinder._matchMaxLen <= matchFinder._streamPos) {\n                lenLimit = matchFinder._matchMaxLen;\n            }\n            else {\n                lenLimit = matchFinder._streamPos - matchFinder._pos;\n                if (lenLimit < matchFinder.kMinMatchCheck) {\n                    this.#MovePos_0();\n                    continue;\n                }\n            }\n            matchMinPos = matchFinder._pos > matchFinder._cyclicBufferSize\n                ? matchFinder._pos - matchFinder._cyclicBufferSize\n                : 0;\n            cur = matchFinder._bufferOffset + matchFinder._pos;\n            if (matchFinder.HASH_ARRAY) {\n                temp = CRC32_TABLE[matchFinder._bufferBase[cur] & 0xFF] ^ (matchFinder._bufferBase[cur + 1] & 0xFF);\n                hash2Value = temp & 0x3FF;\n                matchFinder._hash[hash2Value] = matchFinder._pos;\n                temp ^= (matchFinder._bufferBase[cur + 2] & 0xFF) << 0x08;\n                hash3Value = temp & 0xFFFF;\n                matchFinder._hash[0x400 + hash3Value] = matchFinder._pos;\n                hashValue = (temp ^ (CRC32_TABLE[matchFinder._bufferBase[cur + 3] & 0xFF] << 5)) & matchFinder._hashMask;\n            }\n            else {\n                hashValue = (matchFinder._bufferBase[cur] & 0xFF) ^ ((matchFinder._bufferBase[cur + 1] & 0xFF) << 0x08);\n            }\n            curMatch = matchFinder._hash[matchFinder.kFixHashSize + hashValue];\n            matchFinder._hash[matchFinder.kFixHashSize + hashValue] = matchFinder._pos;\n            ptr0 = (matchFinder._cyclicBufferPos << 1) + 1;\n            ptr1 = matchFinder._cyclicBufferPos << 1;\n            len0 = len1 = matchFinder.kNumHashDirectBytes;\n            count = matchFinder._cutValue;\n            while (1) {\n                if (curMatch <= matchMinPos || count == 0) {\n                    count -= 1;\n                    matchFinder._son[ptr0] = matchFinder._son[ptr1] = 0;\n                    break;\n                }\n                delta = matchFinder._pos - curMatch;\n                cyclicPos = (delta <= matchFinder._cyclicBufferPos\n                    ? matchFinder._cyclicBufferPos - delta\n                    : matchFinder._cyclicBufferPos - delta + matchFinder._cyclicBufferSize) << 1;\n                pby1 = matchFinder._bufferOffset + curMatch;\n                len = len0 < len1 ? len0 : len1;\n                if (matchFinder._bufferBase[pby1 + len] == matchFinder._bufferBase[cur + len]) {\n                    while ((len += 1) != lenLimit) {\n                        if (matchFinder._bufferBase[pby1 + len] != matchFinder._bufferBase[cur + len]) {\n                            break;\n                        }\n                    }\n                    if (len == lenLimit) {\n                        matchFinder._son[ptr1] = matchFinder._son[cyclicPos];\n                        matchFinder._son[ptr0] = matchFinder._son[cyclicPos + 1];\n                        break;\n                    }\n                }\n                if ((matchFinder._bufferBase[pby1 + len] & 0xFF) < (matchFinder._bufferBase[cur + len] & 0xFF)) {\n                    matchFinder._son[ptr1] = curMatch;\n                    ptr1 = cyclicPos + 1;\n                    curMatch = matchFinder._son[ptr1];\n                    len1 = len;\n                }\n                else {\n                    matchFinder._son[ptr0] = curMatch;\n                    ptr0 = cyclicPos;\n                    curMatch = matchFinder._son[ptr0];\n                    len0 = len;\n                }\n            }\n            this.#MovePos_0();\n        } while ((num -= 1) != 0);\n    }\n    #CodeInChunks(inStream, outSize) {\n        this.#decoder.rangeDecoder.stream = inStream;\n        this.#decoder.flush();\n        this.#decoder.outWindow.stream = null;\n        this.#decoder.outWindow.stream = this.#decompressor.output;\n        this.#Init_1();\n        this.#decoder.state = 0;\n        this.#decoder.rep0 = 0;\n        this.#decoder.rep1 = 0;\n        this.#decoder.rep2 = 0;\n        this.#decoder.rep3 = 0;\n        this.#decoder.outSize = outSize;\n        this.#decoder.nowPos64 = P0_LONG_LIT;\n        this.#decoder.prevByte = 0;\n        // Create and return decoder chunker\n        const decoderChunker = new DecoderChunker(this.#decoder);\n        decoderChunker.alive = 1;\n        return decoderChunker;\n    }\n    #Init_1() {\n        this.#decoder.init();\n    }\n    #Backward(cur) {\n        const encoder = this.#compressor.chunker.encoder;\n        let backCur, backMem, posMem, posPrev;\n        encoder._optimumEndIndex = cur;\n        posMem = encoder._optimum[cur].posPrev;\n        backMem = encoder._optimum[cur].backPrev;\n        do {\n            if (encoder._optimum[cur].prev1IsChar) {\n                this.#MakeAsChar(encoder._optimum[posMem]);\n                encoder._optimum[posMem].posPrev = posMem - 1;\n                if (encoder._optimum[cur].prev2) {\n                    encoder._optimum[posMem - 1].prev1IsChar = 0;\n                    encoder._optimum[posMem - 1].posPrev = encoder._optimum[cur].posPrev2;\n                    encoder._optimum[posMem - 1].backPrev = encoder._optimum[cur].backPrev2;\n                }\n            }\n            posPrev = posMem;\n            backCur = backMem;\n            backMem = encoder._optimum[posPrev].backPrev;\n            posMem = encoder._optimum[posPrev].posPrev;\n            encoder._optimum[posPrev].backPrev = backCur;\n            encoder._optimum[posPrev].posPrev = cur;\n            cur = posPrev;\n        } while (cur > 0);\n        encoder.backRes = encoder._optimum[0].backPrev;\n        encoder._optimumCurrentIndex = encoder._optimum[0].posPrev;\n        return encoder._optimumCurrentIndex;\n    }\n    #CodeOneBlock() {\n        let baseVal, complexState, curByte, distance, footerBits, len, lenToPosState, matchByte, pos, posReduced, posSlot, posState, progressPosValuePrev, subCoder;\n        this.#compressor.chunker.encoder.processedInSize[0] = P0_LONG_LIT;\n        this.#compressor.chunker.encoder.processedOutSize[0] = P0_LONG_LIT;\n        this.#compressor.chunker.encoder.finished[0] = 1;\n        progressPosValuePrev = this.#compressor.chunker.encoder.nowPos64;\n        if (this.#compressor.chunker.encoder._inStream) {\n            this.#compressor.chunker.encoder._matchFinder._stream = this.#compressor.chunker.encoder._inStream;\n            this.#Init_5();\n            this.#compressor.chunker.encoder._needReleaseMFStream = 1;\n            this.#compressor.chunker.encoder._inStream = null;\n        }\n        if (this.#compressor.chunker.encoder._finished) {\n            return;\n        }\n        this.#compressor.chunker.encoder._finished = 1;\n        if (compare64(this.#compressor.chunker.encoder.nowPos64, P0_LONG_LIT) === 0) {\n            if (!this.#lzInWindow.getNumAvailableBytes()) {\n                this.#Flush(lowBits64(this.#compressor.chunker.encoder.nowPos64));\n                return;\n            }\n            this.#ReadMatchDistances();\n            posState = lowBits64(this.#compressor.chunker.encoder.nowPos64) & this.#compressor.chunker.encoder._posStateMask;\n            this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isMatch, (this.#compressor.chunker.encoder._state << 4) + posState, 0);\n            this.#compressor.chunker.encoder._state = stateUpdateChar(this.#compressor.chunker.encoder._state);\n            curByte = this.#lzInWindow.getIndexByte(-this.#compressor.chunker.encoder._additionalOffset);\n            this.#compressor.chunker.encoder.encodeLiteral(this.#LZMA_Encoder_GetSubCoder(lowBits64(this.#compressor.chunker.encoder.nowPos64), this.#compressor.chunker.encoder._previousByte), curByte);\n            this.#compressor.chunker.encoder._previousByte = curByte;\n            this.#compressor.chunker.encoder._additionalOffset -= 1;\n            this.#compressor.chunker.encoder.nowPos64 = add64(this.#compressor.chunker.encoder.nowPos64, P1_LONG_LIT);\n        }\n        if (!this.#lzInWindow.getNumAvailableBytes()) {\n            this.#Flush(lowBits64(this.#compressor.chunker.encoder.nowPos64));\n            return;\n        }\n        while (1) {\n            len = this.#GetOptimum(lowBits64(this.#compressor.chunker.encoder.nowPos64));\n            pos = this.#compressor.chunker.encoder.backRes;\n            posState = lowBits64(this.#compressor.chunker.encoder.nowPos64) & this.#compressor.chunker.encoder._posStateMask;\n            complexState = (this.#compressor.chunker.encoder._state << 4) + posState;\n            if (len == 1 && pos == -1) {\n                this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isMatch, complexState, 0);\n                curByte = this.#lzInWindow.getIndexByte(-this.#compressor.chunker.encoder._additionalOffset);\n                subCoder = this.#LZMA_Encoder_GetSubCoder(lowBits64(this.#compressor.chunker.encoder.nowPos64), this.#compressor.chunker.encoder._previousByte);\n                if (this.#compressor.chunker.encoder._state < 7) {\n                    this.#compressor.chunker.encoder.encodeLiteral(subCoder, curByte);\n                }\n                else {\n                    matchByte = this.#lzInWindow.getIndexByte(-this.#compressor.chunker.encoder._repDistances[0]\n                        - 1\n                        - this.#compressor.chunker.encoder._additionalOffset);\n                    this.#compressor.chunker.encoder.encodeMatched(subCoder, matchByte, curByte);\n                }\n                this.#compressor.chunker.encoder._previousByte = curByte;\n                this.#compressor.chunker.encoder._state = stateUpdateChar(this.#compressor.chunker.encoder._state);\n            }\n            else {\n                this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isMatch, complexState, 1);\n                if (pos < 4) {\n                    this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRep, this.#compressor.chunker.encoder._state, 1);\n                    if (!pos) {\n                        this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRepG0, this.#compressor.chunker.encoder._state, 0);\n                        if (len == 1) {\n                            this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRep0Long, complexState, 0);\n                        }\n                        else {\n                            this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRep0Long, complexState, 1);\n                        }\n                    }\n                    else {\n                        this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRepG0, this.#compressor.chunker.encoder._state, 1);\n                        if (pos == 1) {\n                            this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRepG1, this.#compressor.chunker.encoder._state, 0);\n                        }\n                        else {\n                            this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRepG1, this.#compressor.chunker.encoder._state, 1);\n                            this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRepG2, this.#compressor.chunker.encoder._state, pos - 2);\n                        }\n                    }\n                    if (len == 1) {\n                        this.#compressor.chunker.encoder._state = this.#compressor.chunker.encoder._state < 7 ? 9 : 11;\n                    }\n                    else {\n                        this.#compressor.chunker.encoder.encodeLength(this.#compressor.chunker.encoder._repMatchLenEncoder, len - 2, posState);\n                        this.#compressor.chunker.encoder._state = this.#compressor.chunker.encoder._state < 7\n                            ? 0x08\n                            : 11;\n                    }\n                    distance = this.#compressor.chunker.encoder._repDistances[pos];\n                    if (pos != 0) {\n                        const encoder = this.#compressor.chunker.encoder;\n                        for (let i = pos; i >= 1; --i) {\n                            encoder._repDistances[i] = encoder._repDistances[i - 1];\n                        }\n                        encoder._repDistances[0] = distance;\n                    }\n                }\n                else {\n                    this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._isRep, this.#compressor.chunker.encoder._state, 0);\n                    this.#compressor.chunker.encoder._state = this.#compressor.chunker.encoder._state < 7 ? 7 : 10;\n                    this.#compressor.chunker.encoder.encodeLength(this.#compressor.chunker.encoder._lenEncoder, len - 0x02, posState);\n                    pos -= 0x04;\n                    posSlot = this.#compressor.chunker.encoder.getPosSlot(pos);\n                    lenToPosState = getLenToPosState(len);\n                    this.#compressor.chunker.encoder.encodeBitTree(this.#compressor.chunker.encoder._posSlotEncoder[lenToPosState], posSlot);\n                    if (posSlot >= 0x04) {\n                        footerBits = (posSlot >> 0x01) - 0x01;\n                        baseVal = (0x02 | (posSlot & 0x01)) << footerBits;\n                        posReduced = pos - baseVal;\n                        if (posSlot < 0x0E) {\n                            this.#compressor.chunker.encoder.reverseEncodeRange(baseVal - posSlot - 0x01, footerBits, posReduced);\n                        }\n                        else {\n                            this.#compressor.chunker.encoder.encodeDirectBits(posReduced >> 0x04, footerBits - 4);\n                            this.#compressor.chunker.encoder.reverseEncode(posReduced & 0x0F);\n                            this.#compressor.chunker.encoder._alignPriceCount += 1;\n                        }\n                    }\n                    distance = pos;\n                    const encoder2 = this.#compressor.chunker.encoder;\n                    for (let i = 3; i >= 1; --i) {\n                        encoder2._repDistances[i] = encoder2._repDistances[i - 1];\n                    }\n                    encoder2._repDistances[0] = distance;\n                    encoder2._matchPriceCount += 0x01;\n                }\n                this.#compressor.chunker.encoder._previousByte = this.#lzInWindow.getIndexByte(len - 1 - this.#compressor.chunker.encoder._additionalOffset);\n            }\n            this.#compressor.chunker.encoder._additionalOffset -= len;\n            this.#compressor.chunker.encoder.nowPos64 = add64(this.#compressor.chunker.encoder.nowPos64, fromInt64(len));\n            if (!this.#compressor.chunker.encoder._additionalOffset) {\n                if (this.#compressor.chunker.encoder._matchPriceCount >= 0x80) {\n                    this.#compressor.chunker.encoder.fillDistancesPrices();\n                }\n                if (this.#compressor.chunker.encoder._alignPriceCount >= 0x10) {\n                    this.#FillAlignPrices(this.#compressor.chunker.encoder);\n                }\n                this.#compressor.chunker.encoder.processedInSize[0] = this.#compressor.chunker.encoder.nowPos64;\n                this.#compressor.chunker.encoder.processedOutSize[0] = this.#GetProcessedSizeAdd();\n                if (!this.#lzInWindow.getNumAvailableBytes()) {\n                    this.#Flush(lowBits64(this.#compressor.chunker.encoder.nowPos64));\n                    return;\n                }\n                if (compare64(sub64(this.#compressor.chunker.encoder.nowPos64, progressPosValuePrev), [0x1000, 0]) >= 0) {\n                    this.#compressor.chunker.encoder._finished = 0;\n                    this.#compressor.chunker.encoder.finished[0] = 0;\n                    return;\n                }\n            }\n        }\n    }\n    #Create_2() {\n        let binTree, numHashBytes;\n        if (!this.#encoder._matchFinder) {\n            binTree = {};\n            numHashBytes = 4;\n            if (!this.#encoder._matchFinderType) {\n                numHashBytes = 2;\n            }\n            this.#SetType(binTree, numHashBytes);\n            this.#encoder._matchFinder = binTree;\n            this.#lzInWindow = new LzInWindow(binTree);\n        }\n        this.#encoder.createLiteralEncoder();\n        if (this.#encoder._dictionarySize == this.#encoder._dictionarySizePrev\n            && this.#encoder._numFastBytesPrev == this.#encoder._numFastBytes) {\n            return;\n        }\n        this.#Create_3(0x1000, 0x0112);\n        this.#encoder._dictionarySizePrev = this.#encoder._dictionarySize;\n        this.#encoder._numFastBytesPrev = this.#encoder._numFastBytes;\n    }\n    #Encoder() {\n        for (let i = 0; i < 0x1000; ++i) {\n            this.#encoder._optimum[i] = {};\n        }\n        for (let i = 0; i < 4; ++i) {\n            this.#encoder._posSlotEncoder[i] = createBitTree(6);\n        }\n    }\n    #FillAlignPrices(encoder) {\n        for (let i = 0; i < 16; ++i) {\n            encoder._alignPrices[i] = this.#ReverseGetPrice(encoder._posAlignEncoder, i);\n        }\n        encoder._alignPriceCount = 0;\n    }\n    #Flush(nowPos) {\n        this.#ReleaseMFStream();\n        this.#compressor.chunker.encoder.writeEndMarker(nowPos & this.#compressor.chunker.encoder._posStateMask);\n        for (let i = 0; i < 5; ++i) {\n            this.#compressor.chunker.encoder.shiftLow();\n        }\n    }\n    #GetOptimum(position) {\n        let cur, curAnd1Price, curAndLenCharPrice, curAndLenPrice, curBack, curPrice, currentByte, distance, len, lenEnd, lenMain, lenTest, lenTest2, lenTestTemp, matchByte, matchPrice, newLen, nextIsChar, nextMatchPrice, nextOptimum, nextRepMatchPrice, normalMatchPrice, numAvailableBytes, numAvailableBytesFull, numDistancePairs, offs, offset, opt, optimum, pos, posPrev, posState, posStateNext, price_4, repIndex, repLen, repMatchPrice, repMaxIndex, shortRepPrice, startLen, state, state2, t, price, price_0, price_1, price_2, price_3, lenRes;\n        const encoder = this.#compressor.chunker.encoder;\n        if (encoder._optimumEndIndex != encoder._optimumCurrentIndex) {\n            lenRes = encoder._optimum[encoder._optimumCurrentIndex].posPrev - encoder._optimumCurrentIndex;\n            encoder.backRes = encoder._optimum[encoder._optimumCurrentIndex].backPrev;\n            encoder._optimumCurrentIndex = encoder._optimum[encoder._optimumCurrentIndex].posPrev;\n            return lenRes;\n        }\n        encoder._optimumCurrentIndex = encoder._optimumEndIndex = 0;\n        if (encoder._longestMatchWasFound) {\n            lenMain = encoder._longestMatchLength;\n            encoder._longestMatchWasFound = 0;\n        }\n        else {\n            lenMain = this.#ReadMatchDistances();\n        }\n        numDistancePairs = encoder._numDistancePairs;\n        numAvailableBytes = this.#lzInWindow.getNumAvailableBytes() + 1;\n        if (numAvailableBytes < 2) {\n            encoder.backRes = -1;\n            return 1;\n        }\n        if (numAvailableBytes > 0x0111) {\n            numAvailableBytes = 0x0111;\n        }\n        repMaxIndex = 0;\n        for (let i = 0; i < 4; ++i) {\n            encoder.reps[i] = encoder._repDistances[i];\n            encoder.repLens[i] = this.#lzInWindow.getMatchLen(-1, encoder.reps[i], 0x0111);\n            if (encoder.repLens[i] > encoder.repLens[repMaxIndex]) {\n                repMaxIndex = i;\n            }\n        }\n        if (encoder.repLens[repMaxIndex] >= encoder._numFastBytes) {\n            encoder.backRes = repMaxIndex;\n            lenRes = encoder.repLens[repMaxIndex];\n            this.#MovePos(lenRes - 1);\n            return lenRes;\n        }\n        if (lenMain >= encoder._numFastBytes) {\n            encoder.backRes = this.#compressor.chunker.encoder._matchDistances[numDistancePairs - 1] + 4;\n            this.#MovePos(lenMain - 1);\n            return lenMain;\n        }\n        currentByte = this.#lzInWindow.getIndexByte(-1);\n        matchByte = this.#lzInWindow.getIndexByte(-encoder._repDistances[0] - 1 - 1);\n        if (lenMain < 2 && currentByte != matchByte && encoder.repLens[repMaxIndex] < 2) {\n            encoder.backRes = -1;\n            return 1;\n        }\n        encoder._optimum[0].state = encoder._state;\n        posState = position & encoder._posStateMask;\n        encoder._optimum[1].price = PROB_PRICES[(encoder._isMatch[(encoder._state << 4) + posState]) >>> 2] + this.#RangeCoder_Encoder_GetPrice_0(this.#LZMA_Encoder_GetSubCoder(position, encoder._previousByte), encoder._state >= 7, matchByte, currentByte);\n        this.#MakeAsChar(encoder._optimum[1]);\n        matchPrice = PROB_PRICES[(2048 - encoder._isMatch[(encoder._state << 4) + posState])\n            >>> 2];\n        repMatchPrice = matchPrice + PROB_PRICES[(2048 - encoder._isRep[encoder._state]) >>> 2];\n        if (matchByte == currentByte) {\n            shortRepPrice = repMatchPrice + this.#GetRepLen1Price(posState);\n            if (shortRepPrice < encoder._optimum[1].price) {\n                encoder._optimum[1].price = shortRepPrice;\n                this.#MakeAsShortRep(encoder._optimum[1]);\n            }\n        }\n        lenEnd = lenMain >= encoder.repLens[repMaxIndex]\n            ? lenMain\n            : encoder.repLens[repMaxIndex];\n        if (lenEnd < 2) {\n            encoder.backRes = encoder._optimum[1].backPrev;\n            return 1;\n        }\n        encoder._optimum[1].posPrev = 0;\n        encoder._optimum[0].backs0 = encoder.reps[0];\n        encoder._optimum[0].backs1 = encoder.reps[1];\n        encoder._optimum[0].backs2 = encoder.reps[2];\n        encoder._optimum[0].backs3 = encoder.reps[3];\n        len = lenEnd;\n        do {\n            encoder._optimum[len].price = INFINITY_PRICE;\n            len -= 1;\n        } while (len >= 2);\n        for (let i = 0; i < 4; ++i) {\n            repLen = encoder.repLens[i];\n            if (repLen < 2) {\n                continue;\n            }\n            price_4 = repMatchPrice + this.#GetPureRepPrice(i, encoder._state, posState);\n            do {\n                curAndLenPrice = price_4 + encoder._repMatchLenEncoder.getPrice(repLen - 2, posState);\n                optimum = encoder._optimum[repLen];\n                if (curAndLenPrice < optimum.price) {\n                    optimum.price = curAndLenPrice;\n                    optimum.posPrev = 0;\n                    optimum.backPrev = i;\n                    optimum.prev1IsChar = 0;\n                }\n            } while ((repLen -= 1) >= 2);\n        }\n        normalMatchPrice = matchPrice\n            + PROB_PRICES[(encoder._isRep[encoder._state]) >>> 2];\n        len = encoder.repLens[0] >= 2 ? encoder.repLens[0] + 1 : 2;\n        if (len <= lenMain) {\n            offs = 0;\n            while (len > encoder._matchDistances[offs]) {\n                offs += 2;\n            }\n            for (;; len += 1) {\n                distance = encoder._matchDistances[offs + 1];\n                curAndLenPrice = normalMatchPrice + this.#LZMA_Encoder_GetPosLenPrice(distance, len, posState);\n                optimum = encoder._optimum[len];\n                if (curAndLenPrice < optimum.price) {\n                    optimum.price = curAndLenPrice;\n                    optimum.posPrev = 0;\n                    optimum.backPrev = distance + 4;\n                    optimum.prev1IsChar = 0;\n                }\n                if (len == encoder._matchDistances[offs]) {\n                    offs += 2;\n                    if (offs == numDistancePairs) {\n                        break;\n                    }\n                }\n            }\n        }\n        cur = 0;\n        while (1) {\n            ++cur;\n            if (cur == lenEnd) {\n                return this.#Backward(cur);\n            }\n            newLen = this.#ReadMatchDistances();\n            numDistancePairs = encoder._numDistancePairs;\n            if (newLen >= encoder._numFastBytes) {\n                encoder._longestMatchLength = newLen;\n                encoder._longestMatchWasFound = 0x01;\n                return this.#Backward(cur);\n            }\n            position += 0x01;\n            posPrev = encoder._optimum[cur].posPrev;\n            if (encoder._optimum[cur].prev1IsChar) {\n                posPrev -= 0x01;\n                if (encoder._optimum[cur].prev2) {\n                    state = encoder._optimum[encoder._optimum[cur].posPrev2].state;\n                    if (encoder._optimum[cur].backPrev2 < 0x04) {\n                        state = (state < 0x07) ? 0x08 : 0x0B;\n                    }\n                    else {\n                        state = (state < 0x07) ? 0x07 : 0x0A;\n                    }\n                }\n                else {\n                    state = encoder._optimum[posPrev].state;\n                }\n                state = stateUpdateChar(state);\n            }\n            else {\n                state = encoder._optimum[posPrev].state;\n            }\n            if (posPrev == cur - 1) {\n                if (!encoder._optimum[cur].backPrev) {\n                    state = state < 7 ? 9 : 11;\n                }\n                else {\n                    state = stateUpdateChar(state);\n                }\n            }\n            else {\n                if (encoder._optimum[cur].prev1IsChar\n                    && encoder._optimum[cur].prev2) {\n                    posPrev = encoder._optimum[cur].posPrev2;\n                    pos = encoder._optimum[cur].backPrev2;\n                    state = state < 0x07 ? 0x08 : 0x0B;\n                }\n                else {\n                    pos = encoder._optimum[cur].backPrev;\n                    if (pos < 4) {\n                        state = state < 0x07 ? 0x08 : 0x0B;\n                    }\n                    else {\n                        state = state < 0x07 ? 0x07 : 0x0A;\n                    }\n                }\n                opt = encoder._optimum[posPrev];\n                if (pos < 4) {\n                    if (!pos) {\n                        encoder.reps[0] = opt.backs0;\n                        encoder.reps[1] = opt.backs1;\n                        encoder.reps[2] = opt.backs2;\n                        encoder.reps[3] = opt.backs3;\n                    }\n                    else if (pos == 1) {\n                        encoder.reps[0] = opt.backs1;\n                        encoder.reps[1] = opt.backs0;\n                        encoder.reps[2] = opt.backs2;\n                        encoder.reps[3] = opt.backs3;\n                    }\n                    else if (pos == 2) {\n                        encoder.reps[0] = opt.backs2;\n                        encoder.reps[1] = opt.backs0;\n                        encoder.reps[2] = opt.backs1;\n                        encoder.reps[3] = opt.backs3;\n                    }\n                    else {\n                        encoder.reps[0] = opt.backs3;\n                        encoder.reps[1] = opt.backs0;\n                        encoder.reps[2] = opt.backs1;\n                        encoder.reps[3] = opt.backs2;\n                    }\n                }\n                else {\n                    encoder.reps[0] = pos - 4;\n                    encoder.reps[1] = opt.backs0;\n                    encoder.reps[2] = opt.backs1;\n                    encoder.reps[3] = opt.backs2;\n                }\n            }\n            encoder._optimum[cur].state = state;\n            encoder._optimum[cur].backs0 = encoder.reps[0];\n            encoder._optimum[cur].backs1 = encoder.reps[1];\n            encoder._optimum[cur].backs2 = encoder.reps[2];\n            encoder._optimum[cur].backs3 = encoder.reps[3];\n            curPrice = encoder._optimum[cur].price;\n            currentByte = this.#lzInWindow.getIndexByte(-0x01);\n            matchByte = this.#lzInWindow.getIndexByte(-encoder.reps[0] - 1 - 1);\n            posState = position & encoder._posStateMask;\n            curAnd1Price = curPrice\n                + PROB_PRICES[(encoder._isMatch[(state << 0x04) + posState]) >>> 2]\n                + this.#RangeCoder_Encoder_GetPrice_0(this.#LZMA_Encoder_GetSubCoder(position, this.#lzInWindow.getIndexByte(-2)), state >= 7, matchByte, currentByte);\n            nextOptimum = encoder._optimum[cur + 1];\n            nextIsChar = 0;\n            if (curAnd1Price < nextOptimum.price) {\n                nextOptimum.price = curAnd1Price;\n                nextOptimum.posPrev = cur;\n                nextOptimum.backPrev = -0x01;\n                nextOptimum.prev1IsChar = 0;\n                nextIsChar = 1;\n            }\n            matchPrice = curPrice + PROB_PRICES[(2048 - encoder._isMatch[(state << 4) + posState]) >>> 2];\n            repMatchPrice = matchPrice + PROB_PRICES[(2048 - encoder._isRep[state]) >>> 2];\n            if (matchByte == currentByte && !(nextOptimum.posPrev < cur && !nextOptimum.backPrev)) {\n                shortRepPrice = repMatchPrice\n                    + (PROB_PRICES[(encoder._isRepG0[state]) >>> 0x02] + PROB_PRICES[(encoder._isRep0Long[(state << 0x04) + posState]) >>> 0x02]);\n                if (shortRepPrice <= nextOptimum.price) {\n                    nextOptimum.price = shortRepPrice;\n                    nextOptimum.posPrev = cur;\n                    nextOptimum.backPrev = 0;\n                    nextOptimum.prev1IsChar = 0;\n                    nextIsChar = 1;\n                }\n            }\n            numAvailableBytesFull = this.#lzInWindow.getNumAvailableBytes() + 1;\n            numAvailableBytesFull = 0xFFF - cur < numAvailableBytesFull\n                ? 0xFFF - cur\n                : numAvailableBytesFull;\n            numAvailableBytes = numAvailableBytesFull;\n            if (numAvailableBytes < 2) {\n                continue;\n            }\n            if (numAvailableBytes > encoder._numFastBytes) {\n                numAvailableBytes = encoder._numFastBytes;\n            }\n            if (!nextIsChar && matchByte != currentByte) {\n                t = Math.min(numAvailableBytesFull - 1, encoder._numFastBytes);\n                lenTest2 = this.#lzInWindow.getMatchLen(0, encoder.reps[0], t);\n                if (lenTest2 >= 2) {\n                    state2 = stateUpdateChar(state);\n                    posStateNext = position + 1 & encoder._posStateMask;\n                    nextRepMatchPrice = curAnd1Price\n                        + PROB_PRICES[(2048 - encoder._isMatch[(state2 << 4) + posStateNext]) >>> 2]\n                        + PROB_PRICES[(2048 - encoder._isRep[state2]) >>> 2];\n                    offset = cur + 1 + lenTest2;\n                    while (lenEnd < offset) {\n                        encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;\n                    }\n                    curAndLenPrice = nextRepMatchPrice + (price = encoder._repMatchLenEncoder.getPrice(lenTest2 - 2, posStateNext),\n                        price + this.#GetPureRepPrice(0, state2, posStateNext));\n                    optimum = encoder._optimum[offset];\n                    if (curAndLenPrice < optimum.price) {\n                        optimum.price = curAndLenPrice;\n                        optimum.posPrev = cur + 1;\n                        optimum.backPrev = 0;\n                        optimum.prev1IsChar = 1;\n                        optimum.prev2 = 0;\n                    }\n                }\n            }\n            startLen = 0x02;\n            for (repIndex = 0; repIndex < 4; ++repIndex) {\n                lenTest = this.#lzInWindow.getMatchLen(-0x01, encoder.reps[repIndex], numAvailableBytes);\n                if (lenTest < 2) {\n                    continue;\n                }\n                lenTestTemp = lenTest;\n                do {\n                    while (lenEnd < cur + lenTest) {\n                        encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;\n                    }\n                    curAndLenPrice = repMatchPrice + (price_0 = encoder._repMatchLenEncoder.getPrice(lenTest - 2, posState),\n                        price_0 + this.#GetPureRepPrice(repIndex, state, posState));\n                    optimum = encoder._optimum[cur + lenTest];\n                    if (curAndLenPrice < optimum.price) {\n                        optimum.price = curAndLenPrice;\n                        optimum.posPrev = cur;\n                        optimum.backPrev = repIndex;\n                        optimum.prev1IsChar = 0;\n                    }\n                } while ((lenTest -= 1) >= 2);\n                lenTest = lenTestTemp;\n                if (!repIndex) {\n                    startLen = lenTest + 1;\n                }\n                if (lenTest < numAvailableBytesFull) {\n                    t = Math.min(numAvailableBytesFull - 1 - lenTest, encoder._numFastBytes);\n                    lenTest2 = this.#lzInWindow.getMatchLen(lenTest, encoder.reps[repIndex], t);\n                    if (lenTest2 >= 2) {\n                        state2 = state < 7 ? 0x08 : 11;\n                        posStateNext = position + lenTest & encoder._posStateMask;\n                        curAndLenCharPrice = repMatchPrice\n                            + (price_1 = encoder._repMatchLenEncoder.getPrice(lenTest - 2, posState), price_1 + this.#GetPureRepPrice(repIndex, state, posState))\n                            + PROB_PRICES[(encoder._isMatch[(state2 << 4) + posStateNext]) >>> 2]\n                            + this.#RangeCoder_Encoder_GetPrice_0(this.#LZMA_Encoder_GetSubCoder(position + lenTest, this.#lzInWindow.getIndexByte(lenTest - 1 - 1)), true, this.#lzInWindow.getIndexByte(lenTest - 1 - (encoder.reps[repIndex] + 1)), this.#lzInWindow.getIndexByte(lenTest - 1));\n                        state2 = stateUpdateChar(state2);\n                        posStateNext = position + lenTest + 1 & encoder._posStateMask;\n                        nextMatchPrice = curAndLenCharPrice + PROB_PRICES[(2048 - encoder._isMatch[(state2 << 4) + posStateNext]) >>> 2];\n                        nextRepMatchPrice = nextMatchPrice + PROB_PRICES[(2048 - encoder._isRep[state2]) >>> 2];\n                        offset = lenTest + 1 + lenTest2;\n                        while (lenEnd < cur + offset) {\n                            encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;\n                        }\n                        curAndLenPrice = nextRepMatchPrice + (price_2 = encoder._repMatchLenEncoder.getPrice(lenTest2 - 2, posStateNext), price_2 + this.#GetPureRepPrice(0, state2, posStateNext));\n                        optimum = encoder._optimum[cur + offset];\n                        if (curAndLenPrice < optimum.price) {\n                            optimum.price = curAndLenPrice;\n                            optimum.posPrev = cur + lenTest + 1;\n                            optimum.backPrev = 0;\n                            optimum.prev1IsChar = 1;\n                            optimum.prev2 = 1;\n                            optimum.posPrev2 = cur;\n                            optimum.backPrev2 = repIndex;\n                        }\n                    }\n                }\n            }\n            if (newLen > numAvailableBytes) {\n                newLen = numAvailableBytes;\n                for (numDistancePairs = 0; newLen > encoder._matchDistances[numDistancePairs]; numDistancePairs += 2) { }\n                encoder._matchDistances[numDistancePairs] = newLen;\n                numDistancePairs += 2;\n            }\n            if (newLen >= startLen) {\n                normalMatchPrice = matchPrice + PROB_PRICES[(encoder._isRep[state]) >>> 2];\n                while (lenEnd < cur + newLen) {\n                    encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;\n                }\n                offs = 0;\n                while (startLen > encoder._matchDistances[offs]) {\n                    offs += 2;\n                }\n                for (lenTest = startLen;; lenTest += 1) {\n                    curBack = encoder._matchDistances[offs + 1];\n                    curAndLenPrice = normalMatchPrice + this.#LZMA_Encoder_GetPosLenPrice(curBack, lenTest, posState);\n                    optimum = encoder._optimum[cur + lenTest];\n                    if (curAndLenPrice < optimum.price) {\n                        optimum.price = curAndLenPrice;\n                        optimum.posPrev = cur;\n                        optimum.backPrev = curBack + 4;\n                        optimum.prev1IsChar = 0;\n                    }\n                    if (lenTest == encoder._matchDistances[offs]) {\n                        if (lenTest < numAvailableBytesFull) {\n                            t = Math.min(numAvailableBytesFull - 1 - lenTest, encoder._numFastBytes);\n                            lenTest2 = this.#lzInWindow.getMatchLen(lenTest, curBack, t);\n                            if (lenTest2 >= 2) {\n                                state2 = state < 7 ? 7 : 10;\n                                posStateNext = position + lenTest & encoder._posStateMask;\n                                curAndLenCharPrice = curAndLenPrice\n                                    + PROB_PRICES[(encoder._isMatch[(state2 << 4) + posStateNext]) >>> 2]\n                                    + this.#RangeCoder_Encoder_GetPrice_0(this.#LZMA_Encoder_GetSubCoder(position + lenTest, this.#lzInWindow.getIndexByte(lenTest - 1 - 1)), true, this.#lzInWindow.getIndexByte(lenTest - (curBack + 1) - 1), this.#lzInWindow.getIndexByte(lenTest - 1));\n                                state2 = stateUpdateChar(state2);\n                                posStateNext = position + lenTest + 1 & encoder._posStateMask;\n                                nextMatchPrice = curAndLenCharPrice + PROB_PRICES[(2048 - encoder._isMatch[(state2 << 4) + posStateNext]) >>> 2];\n                                nextRepMatchPrice = nextMatchPrice + PROB_PRICES[(2048 - encoder._isRep[state2]) >>> 2];\n                                offset = lenTest + 1 + lenTest2;\n                                while (lenEnd < cur + offset) {\n                                    encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;\n                                }\n                                curAndLenPrice = nextRepMatchPrice + (price_3 = encoder._repMatchLenEncoder.getPrice(lenTest2 - 2, posStateNext), price_3 + this.#GetPureRepPrice(0, state2, posStateNext));\n                                optimum = encoder._optimum[cur + offset];\n                                if (curAndLenPrice < optimum.price) {\n                                    optimum.price = curAndLenPrice;\n                                    optimum.posPrev = cur + lenTest + 1;\n                                    optimum.backPrev = 0;\n                                    optimum.prev1IsChar = 1;\n                                    optimum.prev2 = 1;\n                                    optimum.posPrev2 = cur;\n                                    optimum.backPrev2 = curBack + 4;\n                                }\n                            }\n                        }\n                        offs += 2;\n                        if (offs == numDistancePairs) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // Fallback return - should not be reached in normal execution\n        return 1;\n    }\n    #LZMA_Encoder_GetPosLenPrice(pos, len, posState) {\n        const encoder = this.#compressor.chunker.encoder;\n        let price, lenToPosState = getLenToPosState(len);\n        if (pos < 128) {\n            price = encoder._distancesPrices[lenToPosState * 128 + pos];\n        }\n        else {\n            const position = (lenToPosState << 6) + this.GetPosSlot2(pos);\n            price = encoder._posSlotPrices[position] + encoder._alignPrices[pos & 15];\n        }\n        return price + encoder._lenEncoder.getPrice(len - 2, posState);\n    }\n    #GetPureRepPrice(repIndex, state, posState) {\n        const encoder = this.#compressor.chunker.encoder;\n        let price;\n        if (!repIndex) {\n            price = PROB_PRICES[(encoder._isRepG0[state]) >>> 2];\n            price += PROB_PRICES[0x800 - this.#compressor.chunker.encoder._isRep0Long[(state << 4) + posState] >>> 2];\n        }\n        else {\n            price = PROB_PRICES[(0x800 - this.#compressor.chunker.encoder._isRepG0[state]) >>> 2];\n            if (repIndex == 1) {\n                price += PROB_PRICES[(this.#compressor.chunker.encoder._isRepG1[state]) >>> 2];\n            }\n            else {\n                price += PROB_PRICES[(0x800 - this.#compressor.chunker.encoder._isRepG1[state]) >>> 2];\n                price += getBitPrice(this.#compressor.chunker.encoder._isRepG2[state], repIndex - 2);\n            }\n        }\n        return price;\n    }\n    #GetRepLen1Price(posState) {\n        const encoder = this.#compressor.chunker.encoder;\n        const repG0Price = PROB_PRICES[(encoder._isRepG0[encoder._state]) >>> 2];\n        const rep0LongPrice = PROB_PRICES[encoder._isRep0Long[(encoder._state << 4) + posState] >>> 2];\n        return repG0Price + rep0LongPrice;\n    }\n    #MovePos(num) {\n        if (num > 0) {\n            this.#Skip(num);\n            this.#compressor.chunker.encoder._additionalOffset += num;\n        }\n    }\n    #ReadMatchDistances() {\n        let lenRes = 0;\n        const encoder = this.#compressor.chunker.encoder;\n        encoder._numDistancePairs = this.#GetMatches();\n        if (encoder._numDistancePairs > 0) {\n            lenRes = encoder._matchDistances[encoder._numDistancePairs - 2];\n            if (lenRes == encoder._numFastBytes) {\n                lenRes += this.#lzInWindow.getMatchLen(lenRes - 1, encoder._matchDistances[encoder._numDistancePairs - 1], 0x0111 - lenRes);\n            }\n        }\n        encoder._additionalOffset += 1;\n        return lenRes;\n    }\n    #ReleaseMFStream() {\n        const encoder = this.#compressor.chunker.encoder;\n        if (encoder._matchFinder && encoder._needReleaseMFStream) {\n            encoder._matchFinder._stream = null;\n            encoder._needReleaseMFStream = 0;\n        }\n    }\n    #ReleaseStreams() {\n        this.#ReleaseMFStream();\n        this.#compressor.chunker.encoder._rangeEncoder.stream = null;\n    }\n    writeHeaderProperties() {\n        const HEADER_SIZE = 0x5; // Total header size in bytes\n        // First byte combines posStateBits, literalPosStateBits and literalContextBits\n        // Format: (posStateBits * 5 + literalPosStateBits) * 9 + literalContextBits\n        this.#encoder.properties[0] = ((this.#encoder._posStateBits * 5 + this.#encoder._numLiteralPosStateBits) * 9 + this.#encoder._numLiteralContextBits) & 0xFF; // Ensure byte-sized value\n        // Next 4 bytes store dictionary size in little-endian format\n        for (let byteIndex = 0; byteIndex < 4; byteIndex++) {\n            // Shift dictionary size right by appropriate number of bits and mask to byte\n            this.#encoder.properties[1 + byteIndex] = (this.#encoder._dictionarySize >> (0x08 * byteIndex)) & 0xFF;\n        }\n        this.#write_0(this.#compressor.output, this.#encoder.properties, 0, HEADER_SIZE);\n    }\n    GetPosSlot2(pos) {\n        if (pos < 0x20000) {\n            return G_FAST_POS[pos >> 6] + 12;\n        }\n        if (pos < 0x8000000) {\n            return G_FAST_POS[pos >> 16] + 32;\n        }\n        return G_FAST_POS[pos >> 26] + 52;\n    }\n    #LZMA_Encoder_GetSubCoder(pos, prevByte) {\n        const subCoder = this.#compressor.chunker.encoder._literalEncoder.getSubCoder(pos, prevByte);\n        return { decoders: subCoder.decoders };\n    }\n    #RangeCoder_Encoder_GetPrice_0(encoder, matchMode, matchByte, symbol) {\n        let bit, context = 1, i = 7, matchBit, price = 0;\n        if (matchMode) {\n            for (; i >= 0; --i) {\n                matchBit = (matchByte >> i) & 1;\n                bit = (symbol >> i) & 1;\n                price += getBitPrice(encoder.decoders[((1 + matchBit) << 8) + context], bit);\n                context = context << 1 | bit;\n                if (matchBit != bit) {\n                    --i;\n                    break;\n                }\n            }\n        }\n        for (; i >= 0; --i) {\n            bit = symbol >> i & 1;\n            price += getBitPrice(encoder.decoders[context], bit);\n            context = context << 1 | bit;\n        }\n        return price;\n    }\n    #MakeAsChar(optimum) {\n        optimum.backPrev = -1;\n        optimum.prev1IsChar = 0;\n    }\n    #MakeAsShortRep(optimum) {\n        optimum.backPrev = 0;\n        optimum.prev1IsChar = 0;\n    }\n    ReverseEncode(startIndex, NumBitLevels, symbol) {\n        let bit, m = 1;\n        for (let i = 0; i < NumBitLevels; ++i) {\n            bit = symbol & 1;\n            this.#compressor.chunker.encoder.encodeBit(this.#compressor.chunker.encoder._posEncoders, startIndex + m, bit);\n            m = m << 1 | bit;\n            symbol >>= 1;\n        }\n    }\n    #ReverseGetPrice(encoder, symbol) {\n        let bit, m = 1, price = 0;\n        for (let i = encoder.numBitLevels; i != 0; i -= 1) {\n            bit = symbol & 1;\n            symbol >>>= 1;\n            price += getBitPrice(encoder.models[m], bit);\n            m = m << 1 | bit;\n        }\n        return price;\n    }\n    #GetProcessedSizeAdd() {\n        const processedCacheSize = add64(fromInt64(this.#compressor.chunker.encoder._rangeEncoder.cacheSize), this.#compressor.chunker.encoder._rangeEncoder.position);\n        return add64(processedCacheSize, [4, 0]);\n    }\n    #decodeString(utf) {\n        let j = 0, x, y, z, l = utf.length, buf = [], charCodes = [];\n        for (let i = 0; i < l; ++i, ++j) {\n            x = utf[i] & 0xFF;\n            if (!(x & 0x80)) {\n                if (!x) {\n                    // It appears that this is binary data, so it cannot be\n                    // converted to a string, so just send it back.\n                    return utf;\n                }\n                charCodes[j] = x;\n            }\n            else if ((x & 0xE0) == 0xC0) {\n                if (i + 1 >= l) {\n                    // It appears that this is binary data, so it cannot be\n                    // converted to a string, so just send it back.\n                    return String.fromCharCode(...utf);\n                }\n                y = utf[++i] & 0xFF;\n                if ((y & 0xC0) != 0x80) {\n                    // It appears that this is binary data, so it cannot be\n                    // converted to a string, so just send it back.\n                    return String.fromCharCode(...utf);\n                }\n                charCodes[j] = ((x & 0x1F) << 6) | (y & 0x3F);\n            }\n            else if ((x & 0xF0) == 0xE0) {\n                if (i + 2 >= l) {\n                    // It appears that this is binary data, so it cannot be\n                    // converted to a string, so just send it back.\n                    return utf;\n                }\n                y = utf[++i] & 0xFF;\n                if ((y & 0xC0) != 0x80) {\n                    // It appears that this is binary data, so it cannot be converted to\n                    // a string, so just send it back.\n                    return utf;\n                }\n                z = utf[++i] & 0xFF;\n                if ((z & 0xC0) != 0x80) {\n                    // It appears that this is binary data, so it cannot be converted to\n                    // a string, so just send it back.\n                    return utf;\n                }\n                charCodes[j] = ((x & 0x0F) << 0x0C) | ((y & 0x3F) << 6) | (z & 0x3F);\n            }\n            else {\n                // It appears that this is binary data, so it cannot be converted to\n                // a string, so just send it back.\n                return utf;\n            }\n            if (j == 0x3FFF) {\n                buf.push(String.fromCharCode.apply(String, charCodes));\n                j = -1;\n            }\n        }\n        if (j > 0) {\n            charCodes.length = j;\n            buf.push(String.fromCharCode.apply(String, charCodes));\n        }\n        return buf.join(\"\");\n    }\n    encodeString(inputString) {\n        let ch, chars = [], elen = 0, l = inputString.length;\n        this.#getChars(inputString, 0, l, chars, 0);\n        // Add extra spaces in the array to break up the unicode symbols.\n        for (let i = 0; i < l; ++i) {\n            ch = chars[i];\n            if (ch >= 1 && ch <= 127) {\n                ++elen;\n            }\n            else if (!ch || ch >= 128 && ch <= 2047) {\n                elen += 2;\n            }\n            else {\n                elen += 3;\n            }\n        }\n        const data = [];\n        elen = 0;\n        for (let i = 0; i < l; ++i) {\n            ch = chars[i];\n            if (ch >= 1 && ch <= 0x7F) { // 127\n                data[elen++] = ch << 24 >> 24;\n            }\n            else if (!ch || ch >= 0x80 && ch <= 0x7FF) {\n                data[elen++] = (0xC0 | ch >> 6 & 0x1F) << 24 >> 24;\n                data[elen++] = (0x80 | ch & 0x3F) << 24 >> 24;\n            }\n            else {\n                data[elen++] = (0xE0 | ch >> 12 & 0x0F) << 24 >> 24;\n                data[elen++] = (0x80 | ch >> 6 & 0x3F) << 24 >> 24;\n                data[elen++] = (0x80 | ch & 0x3F) << 24 >> 24;\n            }\n        }\n        return data;\n    }\n    compress(data, mode = 5) {\n        const compressionMode = MODES[mode];\n        this.#byteArrayCompressor(data, compressionMode);\n        while (this.#compressor.chunker.processChunk())\n            ;\n        const result = this.#toByteArray(this.#compressor.output);\n        return new Int8Array(result);\n    }\n    compressString(data, mode = 5) {\n        const encodedData = this.encodeString(data);\n        return this.compress(new Uint8Array(encodedData), mode);\n    }\n    decompress(bytearray) {\n        this.#byteArrayDecompressor(bytearray);\n        while (this.#decompressor.chunker.processChunk())\n            ;\n        return this.#toByteArray(this.#decompressor.output);\n    }\n    decompressString(bytearray) {\n        this.#byteArrayDecompressor(bytearray);\n        while (this.#decompressor.chunker.processChunk())\n            ;\n        const decodedByteArray = this.#toByteArray(this.#decompressor.output);\n        const result = this.#decodeString(decodedByteArray);\n        if (typeof result === \"string\") {\n            return result;\n        }\n        else {\n            // If decoding failed and returned binary data, convert to string anyway\n            return String.fromCharCode(...result);\n        }\n    }\n    // Public methods for chunker access\n    codeOneBlock() {\n        this.#CodeOneBlock();\n    }\n    releaseStreams() {\n        this.#ReleaseStreams();\n    }\n}\n", "/**\n * @license\n * Copyright Filip Seman\n * SPDX-License-Identifier: MIT\n */\nimport { LZMA, } from \"./lzma.js\";\nexport { LZMA } from \"./lzma.js\";\nexport { CRC32_TABLE } from \"./utils.js\";\n/**\n * Compresses data using LZMA algorithm\n *\n * @param data Data to compress - can be Uint8Array or ArrayBuffer\n * @param mode Compression mode (1-9), defaults to 5\n * @returns Compressed data as a byte array\n */\nexport function compress(data, mode = 5) {\n    // Convert ArrayBuffer to Uint8Array if needed\n    const input = data instanceof ArrayBuffer\n        ? new Uint8Array(data)\n        : data;\n    const result = new LZMA().compress(input, mode);\n    return new Uint8Array(result);\n}\n/**\n * Compresses data using LZMA algorithm\n *\n * @param data String to compress\n * @param mode Compression mode (1-9), defaults to 5\n * @returns Compressed data as byte array\n */\nexport function compressString(data, mode = 5) {\n    const compressedData = new LZMA().compressString(data, mode);\n    return new Uint8Array(compressedData);\n}\n/**\n * Decompresses LZMA compressed data\n *\n * @param data Compressed data as Uint8Array or ArrayBuffer\n * @returns Decompressed data\n */\nexport function decompress(data) {\n    const input = data instanceof ArrayBuffer\n        ? new Uint8Array(data)\n        : data;\n    const decompressedData = new LZMA().decompress(input);\n    return new Uint8Array(decompressedData);\n}\n/**\n * Decompresses LZMA compressed data\n *\n * @param data Compressed data as Uint8Array or ArrayBuffer\n * @returns Decompressed data as string\n */\nexport function decompressString(data) {\n    return new LZMA().decompressString(data);\n}\n"],
  "mappings": ";;;;;;;;;AACA,IAAM,aAAa;AACnB,IAAM,YAAY;AAClB,IAAM,YAAY;AAEX,IAAM,iBAAiB;AACvB,IAAM,cAAc;AACpB,IAAM,4BAA4B;AAElC,IAAM,YAAY,KAAK;AACvB,IAAM,wBAAwB;AAC9B,IAAM,iBAAiB,KAAK;AAK5B,IAAM,sBAAsB;AAC5B,IAAM,oBAAoB;AAC1B,IAAM,oBAAoB;AAC1B,IAAM,uBAAuB;AAC7B,IAAM,sBAAsB;AAC5B,IAAM,oBAAoB;AAE1B,IAAM,cAAc,CAAC,YAAY,CAAC,UAAU;AAE5C,IAAM,cAAc,CAAC,GAAG,CAAC;AACzB,IAAM,cAAc,CAAC,GAAG,CAAC;AAMzB,IAAM,cAAc;AAAA,EACvB;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAC5D;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,E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",
  "names": ["shiftFact"]
}
