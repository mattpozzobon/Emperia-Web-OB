import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/lzma1/lib/utils.js
var MAX_UINT32 = 4294967296;
var MAX_INT32 = 2147483647;
var MIN_INT32 = -2147483648;
var INFINITY_PRICE = 268435455;
var _MAX_UINT32 = 4294967295;
var DICTIONARY_SIZE_THRESHOLD = 1073741823;
var kTopValue = 1 << 24;
var kNumBitModelTotalBits = 11;
var kBitModelTotal = 1 << kNumBitModelTotalBits;
var MATCH_DECODERS_SIZE = 192;
var REP_DECODERS_SIZE = 12;
var POS_DECODERS_SIZE = 114;
var LITERAL_DECODER_SIZE = 768;
var DEFAULT_WINDOW_SIZE = 4096;
var CHOICE_ARRAY_SIZE = 2;
var N1_LONG_LIT = [4294967295, -MAX_UINT32];
var P0_LONG_LIT = [0, 0];
var P1_LONG_LIT = [1, 0];
var CRC32_TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
var PROB_PRICES = createProbPrices();
var G_FAST_POS = createFastPos();
function initArray(len, value = 0) {
  const array = [];
  array[len - 1] = void 0;
  if (value !== 0) {
    for (let i = 0; i < len; i++) {
      array[i] = value;
    }
  }
  return array;
}
function arraycopy(src, srcOfs, dest, destOfs, len) {
  if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > src.length || destOfs + len > dest.length) {
    return;
  }
  if (src === dest && srcOfs < destOfs && destOfs < srcOfs + len) {
    for (let i = len - 1; i >= 0; i--) {
      dest[destOfs + i] = src[srcOfs + i];
    }
  } else {
    for (let i = 0; i < len; i++) {
      dest[destOfs + i] = src[srcOfs + i];
    }
  }
}
function getBitPrice(probability, bit) {
  return PROB_PRICES[((probability - bit ^ -bit) & 2047) >>> 2];
}
function create64(valueLow, valueHigh) {
  let diffHigh, diffLow;
  valueHigh %= 18446744073709552e3;
  valueLow %= 18446744073709552e3;
  diffHigh = valueHigh % MAX_UINT32;
  diffLow = Math.floor(valueLow / MAX_UINT32) * MAX_UINT32;
  valueHigh = valueHigh - diffHigh + diffLow;
  valueLow = valueLow - diffLow + diffHigh;
  while (valueLow < 0) {
    valueLow += MAX_UINT32;
    valueHigh -= MAX_UINT32;
  }
  while (valueLow > 4294967295) {
    valueLow -= MAX_UINT32;
    valueHigh += MAX_UINT32;
  }
  valueHigh = valueHigh % 18446744073709552e3;
  while (valueHigh > 9223372032559809e3) {
    valueHigh -= 18446744073709552e3;
  }
  while (valueHigh < -9223372036854776e3) {
    valueHigh += 18446744073709552e3;
  }
  return [valueLow, valueHigh];
}
function add64(a, b) {
  return create64(a[0] + b[0], a[1] + b[1]);
}
function sub64(a, b) {
  return create64(a[0] - b[0], a[1] - b[1]);
}
function compare64(a, b) {
  if (a[0] == b[0] && a[1] == b[1]) {
    return 0;
  }
  const nega = a[1] < 0;
  const negb = b[1] < 0;
  if (nega && !negb) {
    return -1;
  }
  if (!nega && negb) {
    return 1;
  }
  if (sub64(a, b)[1] < 0) {
    return -1;
  }
  return 1;
}
function lowBits64(a) {
  if (a[0] >= 2147483648) {
    return ~~Math.max(Math.min(a[0] - MAX_UINT32, MAX_INT32), MIN_INT32);
  }
  return ~~Math.max(Math.min(a[0], MAX_INT32), MIN_INT32);
}
function fromInt64(value) {
  if (value >= 0) {
    return [value, 0];
  } else {
    return [value + MAX_UINT32, -MAX_UINT32];
  }
}
function shr64(a, n) {
  n &= 63;
  if (n <= 30) {
    const shiftFact2 = 1 << n;
    return create64(Math.floor(a[0] / shiftFact2), a[1] / shiftFact2);
  }
  const shiftFact = (1 << 30) * (1 << n - 30);
  return create64(Math.floor(a[0] / shiftFact), a[1] / shiftFact);
}
function initBitModels(probs) {
  for (let i = probs.length - 1; i >= 0; --i) {
    probs[i] = 1024;
  }
}
function getLenToPosState(len) {
  len -= 2;
  if (len < 4) {
    return len;
  }
  return 3;
}
function stateUpdateChar(index) {
  if (index < 4) {
    return 0;
  }
  if (index < 10) {
    return index - 3;
  }
  return index - 6;
}
function createBitTree(numBitLevels) {
  return {
    numBitLevels,
    models: initArray(1 << numBitLevels)
  };
}
function createProbPrices() {
  const probPrices = [];
  for (let i = 8; i >= 0; --i) {
    let start = 1 << 9 - i - 1;
    let end = 1 << 9 - i;
    for (let j = start; j < end; ++j) {
      probPrices[j] = (i << 6) + (end - j << 6 >>> 9 - i - 1);
    }
  }
  return probPrices;
}
function createFastPos() {
  const gFastPos = [0, 1];
  let c = 2;
  for (let slotFast = 2; slotFast < 22; ++slotFast) {
    let k = 1 << (slotFast >> 1) - 1;
    for (let j = 0; j < k; ++j, ++c) {
      gFastPos[c] = slotFast;
    }
  }
  return gFastPos;
}

// node_modules/lzma1/lib/chunker.js
var EncoderChunker = class {
  constructor(lzma) {
    __publicField(this, "encoder", null);
    __publicField(this, "decoder", null);
    __publicField(this, "alive", 0);
    __publicField(this, "inBytesProcessed", [0, 0]);
    __publicField(this, "lzma");
    this.lzma = lzma;
  }
  /**
   * Process one chunk of encoding
   */
  processChunk() {
    if (!this.alive) {
      throw new Error("bad state");
    }
    if (!this.encoder) {
      throw new Error("No decoding");
    }
    this.lzma.codeOneBlock();
    this.inBytesProcessed = this.encoder.processedInSize[0];
    if (this.encoder.finished[0]) {
      this.lzma.releaseStreams();
      this.alive = 0;
    }
    return this.alive;
  }
};
var DecoderChunker = class {
  constructor(decoder) {
    __publicField(this, "encoder", null);
    __publicField(this, "decoder");
    __publicField(this, "alive", 0);
    __publicField(this, "inBytesProcessed", [0, 0]);
    this.decoder = decoder;
  }
  /**
   * Process one chunk of decoding
   */
  processChunk() {
    if (!this.alive) {
      throw new Error("Bad state");
    }
    if (this.encoder) {
      throw new Error("No encoding");
    }
    const result = this.decoder.codeOneChunk();
    if (result === -1) {
      throw new Error("Corrupted input");
    }
    this.inBytesProcessed = this.decoder.nowPos64;
    const isOutputComplete = compare64(this.decoder.outSize, P0_LONG_LIT) >= 0 && compare64(this.decoder.nowPos64, this.decoder.outSize) >= 0;
    if (result || isOutputComplete) {
      this.decoder.flush();
      this.decoder.cleanup();
      this.alive = 0;
    }
    return this.alive;
  }
};

// node_modules/lzma1/lib/lz-window.js
var LzOutWindow = class {
  constructor(writer = null, windowSize = 4096) {
    __publicField(this, "buffer", null);
    __publicField(this, "pos", 0);
    __publicField(this, "streamPos", 0);
    __publicField(this, "stream", null);
    __publicField(this, "windowSize", 0);
    // Private Go-style properties
    __publicField(this, "w", null);
    __publicField(this, "buf", []);
    this.w = writer;
    this.stream = writer;
    this.windowSize = windowSize;
    this.buf = new Array(windowSize);
    this.buffer = this.buf;
    this.pos = 0;
    this.streamPos = 0;
  }
  /**
   * Copy a block of data from a previous position (LZ77-style)
   */
  copyBlock(distance, length) {
    if (!this.buffer)
      return;
    for (let i = 0; i < length; i++) {
      let sourcePos = this.pos - distance - 1;
      if (sourcePos < 0) {
        sourcePos += this.windowSize;
      }
      const byte = this.buffer[sourcePos];
      this.putByte(byte);
    }
  }
  /**
   * Put a single byte into the window
   */
  putByte(byte) {
    if (!this.buffer)
      return;
    this.buffer[this.pos] = byte;
    this.pos++;
    this.streamPos++;
    if (this.pos >= this.windowSize) {
      this.flush();
    }
  }
  /**
   * Get a byte from a relative position
   */
  getByte(relativePos) {
    if (!this.buffer)
      return 0;
    let pos = this.pos + relativePos;
    if (pos < 0) {
      pos += this.windowSize;
    } else if (pos >= this.windowSize) {
      pos -= this.windowSize;
    }
    return this.buffer[pos];
  }
  /**
   * Flush buffered data to output writer
   */
  flush() {
    if (this.w && this.buffer && this.pos > 0) {
      const dataToWrite = this.buffer.slice(0, this.pos);
      this.w.write(dataToWrite);
      this.pos = 0;
    }
  }
  /**
   * Check if the window is empty
   */
  isEmpty() {
    return this.streamPos === 0;
  }
  /**
   * Reset the window
   */
  reset() {
    this.pos = 0;
    this.streamPos = 0;
    if (this.buffer) {
      this.buffer.fill(0);
    }
  }
};

// node_modules/lzma1/lib/range-decoder.js
var RangeDecoder = class {
  constructor() {
    __publicField(this, "stream", null);
    __publicField(this, "code", 0);
    __publicField(this, "rrange", 0);
  }
  /**
   * Set input stream for decoding
   */
  setStream(stream) {
    this.stream = stream;
  }
  /**
   * Initialize range decoder
   */
  init() {
    this.code = 0;
    this.rrange = -1;
    for (let i = 0; i < 5; ++i) {
      this.code = this.code << 8 | this.readFromStream();
    }
  }
  /**
   * Decode a single bit using probability model
   */
  decodeBit(probs, index) {
    let newBound, prob = probs[index];
    newBound = (this.rrange >>> 11) * prob;
    if ((this.code ^ -2147483648) < (newBound ^ -2147483648)) {
      this.rrange = newBound;
      probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;
      if (!(this.rrange & -16777216)) {
        this.code = this.code << 8 | this.readFromStream();
        this.rrange <<= 8;
      }
      return 0;
    } else {
      this.rrange -= newBound;
      this.code -= newBound;
      probs[index] = prob - (prob >>> 5) << 16 >> 16;
      if (!(this.rrange & -16777216)) {
        this.code = this.code << 8 | this.readFromStream();
        this.rrange <<= 8;
      }
      return 1;
    }
  }
  /**
   * Decode direct bits (without probability model)
   */
  decodeDirectBits(numTotalBits) {
    let result = 0;
    for (let i = numTotalBits; i != 0; i -= 1) {
      this.rrange >>>= 1;
      let t = this.code - this.rrange >>> 31;
      this.code -= this.rrange & t - 1;
      result = result << 1 | 1 - t;
      if (!(this.rrange & -16777216)) {
        this.code = this.code << 8 | this.readFromStream();
        this.rrange <<= 8;
      }
    }
    return result;
  }
  /**
   * Get current code value (for compatibility)
   */
  get currentCode() {
    return this.code;
  }
  /**
   * Get current range value (for compatibility)
   */
  get currentRange() {
    return this.rrange;
  }
  /**
   * Read a single byte from the input stream
   */
  readFromStream() {
    if (!this.stream) {
      return 0;
    }
    if (this.stream.pos >= this.stream.count) {
      return -1;
    }
    let value;
    if (this.stream.buf instanceof ArrayBuffer) {
      value = new Uint8Array(this.stream.buf)[this.stream.pos++];
    } else if (this.stream.buf instanceof Uint8Array) {
      value = this.stream.buf[this.stream.pos++];
    } else {
      value = this.stream.buf[this.stream.pos++];
    }
    return value & 255;
  }
};

// node_modules/lzma1/lib/decoder.js
var Decoder = class {
  constructor() {
    __publicField(this, "rangeDecoder");
    __publicField(this, "outWindow");
    // Decoder state
    __publicField(this, "state", 0);
    __publicField(this, "rep0", 0);
    __publicField(this, "rep1", 0);
    __publicField(this, "rep2", 0);
    __publicField(this, "rep3", 0);
    __publicField(this, "prevByte", 0);
    __publicField(this, "nowPos64", [0, 0]);
    __publicField(this, "outSize", [0, 0]);
    // Decoder configuration
    __publicField(this, "posStateMask", 0);
    __publicField(this, "dictSizeCheck", 0);
    // Probability models for different symbols
    __publicField(this, "matchDecoders", []);
    __publicField(this, "rep0LongDecoders", []);
    __publicField(this, "repDecoders", []);
    __publicField(this, "repG0Decoders", []);
    __publicField(this, "repG1Decoders", []);
    __publicField(this, "repG2Decoders", []);
    __publicField(this, "posDecoders", []);
    // Complex decoders
    __publicField(this, "literalDecoder");
    __publicField(this, "posSlotDecoders", []);
    __publicField(this, "lenDecoder");
    __publicField(this, "repLenDecoder");
    __publicField(this, "posAlignDecoder");
    // Chunker properties for compatibility
    __publicField(this, "decoder");
    __publicField(this, "encoder", null);
    __publicField(this, "alive", 0);
    __publicField(this, "inBytesProcessed", [0, 0]);
    this.rangeDecoder = new RangeDecoder();
    this.outWindow = new LzOutWindow(null, DEFAULT_WINDOW_SIZE);
    this.matchDecoders = initArray(MATCH_DECODERS_SIZE);
    this.rep0LongDecoders = initArray(MATCH_DECODERS_SIZE);
    this.repDecoders = initArray(REP_DECODERS_SIZE);
    this.repG0Decoders = initArray(REP_DECODERS_SIZE);
    this.repG1Decoders = initArray(REP_DECODERS_SIZE);
    this.repG2Decoders = initArray(REP_DECODERS_SIZE);
    this.posDecoders = initArray(POS_DECODERS_SIZE);
    this.literalDecoder = {
      coders: [],
      numPrevBits: 0,
      numPosBits: 0,
      posMask: 0,
      init: () => this.initLiteralDecoder()
    };
    for (let i = 0; i < 4; i++) {
      this.posSlotDecoders[i] = createBitTree(6);
    }
    this.lenDecoder = this.createLenDecoder();
    this.repLenDecoder = this.createLenDecoder();
    this.posAlignDecoder = createBitTree(4);
    this.decoder = this;
  }
  // Alias for compatibility with LZMA class
  get literalCoder() {
    return this.literalDecoder;
  }
  createLenDecoder() {
    const decoder = {
      choice: initArray(CHOICE_ARRAY_SIZE),
      lowCoder: [],
      midCoder: [],
      highCoder: createBitTree(8),
      numPosStates: 0
    };
    return decoder;
  }
  setDecoderProperties(properties) {
    if (properties.length < 5) {
      return false;
    }
    const lc = properties[0] % 9;
    const remainder = Math.floor(properties[0] / 9);
    const lp = remainder % 5;
    const pb = Math.floor(remainder / 5);
    if (pb > 4) {
      return false;
    }
    this.literalDecoder.numPrevBits = lc;
    this.literalDecoder.numPosBits = lp;
    this.literalDecoder.posMask = (1 << lp) - 1;
    this.posStateMask = (1 << pb) - 1;
    let dictSize = 0;
    for (let i = 0; i < 4; i++) {
      const unsignedByte = properties[1 + i] & 255;
      dictSize += unsignedByte << i * 8;
    }
    this.dictSizeCheck = Math.max(dictSize, 1);
    if (dictSize > 0) {
      this.outWindow.windowSize = Math.max(dictSize, 4096);
      this.outWindow.buffer = initArray(this.outWindow.windowSize);
    }
    const numStates = 1 << this.literalDecoder.numPrevBits + this.literalDecoder.numPosBits;
    this.literalDecoder.coders = [];
    for (let i = 0; i < numStates; i++) {
      this.literalDecoder.coders[i] = {
        decoders: initArray(LITERAL_DECODER_SIZE)
        // 0x300
      };
    }
    this.lenDecoder.numPosStates = 1 << pb;
    this.repLenDecoder.numPosStates = 1 << pb;
    this.lenDecoder.lowCoder = [];
    this.lenDecoder.midCoder = [];
    this.repLenDecoder.lowCoder = [];
    this.repLenDecoder.midCoder = [];
    for (let posState = 0; posState < 1 << pb; posState++) {
      this.lenDecoder.lowCoder[posState] = createBitTree(3);
      this.lenDecoder.midCoder[posState] = createBitTree(3);
      this.repLenDecoder.lowCoder[posState] = createBitTree(3);
      this.repLenDecoder.midCoder[posState] = createBitTree(3);
    }
    return true;
  }
  // Methods that modify decoder state
  copyBlock(len) {
    const outputWindow = this.outWindow;
    const distance = this.rep0;
    let pos = outputWindow.pos - distance - 1;
    if (pos < 0) {
      pos += outputWindow.windowSize;
    }
    for (; len != 0; len -= 1) {
      if (pos >= outputWindow.windowSize) {
        pos = 0;
      }
      outputWindow.buffer[outputWindow.pos] = outputWindow.buffer[pos];
      outputWindow.pos += 1;
      pos += 1;
      if (outputWindow.pos >= outputWindow.windowSize) {
        this.flush();
      }
    }
  }
  putByte(b) {
    this.outWindow.buffer[this.outWindow.pos] = b;
    this.outWindow.pos += 1;
    if (this.outWindow.pos >= this.outWindow.windowSize) {
      this.flush();
    }
  }
  getByte(distance) {
    const outputWindow = this.outWindow;
    let pos = outputWindow.pos - distance - 1;
    if (pos < 0) {
      pos += outputWindow.windowSize;
    }
    return outputWindow.buffer[pos];
  }
  getDecoder(pos, prevByte) {
    const positionMask = pos & this.literalDecoder.posMask;
    const prevBitsMask = (prevByte & 255) >>> 8 - this.literalDecoder.numPrevBits;
    const index = (positionMask << this.literalDecoder.numPrevBits) + prevBitsMask;
    return this.literalDecoder.coders[index];
  }
  initLiteralDecoder() {
    let numStates = 1 << this.literalDecoder.numPrevBits + this.literalDecoder.numPosBits;
    for (let i = 0; i < numStates; ++i) {
      for (let j = 0; j < this.literalDecoder.coders[i].decoders.length; j++) {
        this.literalDecoder.coders[i].decoders[j] = 1024;
      }
    }
  }
  init() {
    this.outWindow.streamPos = 0;
    this.outWindow.pos = 0;
    initBitModels(this.matchDecoders);
    initBitModels(this.rep0LongDecoders);
    initBitModels(this.repDecoders);
    initBitModels(this.repG0Decoders);
    initBitModels(this.repG1Decoders);
    initBitModels(this.repG2Decoders);
    initBitModels(this.posDecoders);
    this.initLiteralDecoder();
    for (let i = 0; i < 4; ++i) {
      initBitModels(this.posSlotDecoders[i].models);
    }
    this.initLenDecoder(this.lenDecoder);
    this.initLenDecoder(this.repLenDecoder);
    initBitModels(this.posAlignDecoder.models);
    this.initRangeDecoder();
  }
  initLenDecoder(decoder) {
    initBitModels(decoder.choice);
    for (let posState = 0; posState < decoder.numPosStates; ++posState) {
      initBitModels(decoder.lowCoder[posState].models);
      initBitModels(decoder.midCoder[posState].models);
    }
    initBitModels(decoder.highCoder.models);
  }
  outWindowReleaseStream() {
    this.flush();
    this.outWindow.stream = null;
  }
  decodeBit(probs, index) {
    return this.rangeDecoder.decodeBit(probs, index);
  }
  decodeDirectBits(numTotalBits) {
    return this.rangeDecoder.decodeDirectBits(numTotalBits);
  }
  initRangeDecoder() {
    this.rangeDecoder.init();
  }
  rangeBitTreeDecoder(bitTree) {
    let bitIndex, m = 1;
    for (bitIndex = bitTree.numBitLevels; bitIndex != 0; bitIndex -= 1) {
      m = (m << 1) + this.decodeBit(bitTree.models, m);
    }
    return m - (1 << bitTree.numBitLevels);
  }
  reverseDecode(models, startIndex, numBitLevels) {
    let symbol = 0;
    for (let bitIndex = 0, m = 1, bit; bitIndex < numBitLevels; ++bitIndex) {
      bit = this.decodeBit(models, startIndex + m);
      m <<= 1;
      m += bit;
      symbol |= bit << bitIndex;
    }
    return symbol;
  }
  reverseDecodeAlignDecoder() {
    let symbol = 0;
    for (let m = 1, bitIndex = 0, bit; bitIndex < this.posAlignDecoder.numBitLevels; ++bitIndex) {
      bit = this.decodeBit(this.posAlignDecoder.models, m);
      m <<= 1;
      m += bit;
      symbol |= bit << bitIndex;
    }
    return symbol;
  }
  // Update the placeholder implementations with actual logic
  decodeNormalWithRangeDecoder(decoder) {
    let symbol = 1;
    do {
      symbol = symbol << 1 | this.decodeBit(decoder.decoders, symbol);
    } while (symbol < 256);
    return symbol << 24 >> 24;
  }
  decodeWithMatchByteWithRangeDecoder(encoder, matchByte) {
    let bit, matchBit, symbol = 1;
    do {
      matchBit = matchByte >> 7 & 1;
      matchByte <<= 1;
      bit = this.decodeBit(encoder.decoders, (1 + matchBit << 8) + symbol);
      symbol = symbol << 1 | bit;
      if (matchBit != bit) {
        while (symbol < 256) {
          symbol = symbol << 1 | this.decodeBit(encoder.decoders, symbol);
        }
        break;
      }
    } while (symbol < 256);
    return symbol << 24 >> 24;
  }
  decodeLenWithRangeDecoder(decoder, posState) {
    if (!this.decodeBit(decoder.choice, 0)) {
      return this.rangeBitTreeDecoder(decoder.lowCoder[posState]);
    }
    let symbol = 8;
    if (!this.decodeBit(decoder.choice, 1)) {
      symbol += this.rangeBitTreeDecoder(decoder.midCoder[posState]);
    } else {
      symbol += 8 + this.rangeBitTreeDecoder(decoder.highCoder);
    }
    return symbol;
  }
  codeOneChunk() {
    let decoder2, distance, len, numDirectBits, positionSlot;
    let posState = lowBits64(this.nowPos64) & this.posStateMask;
    if (!this.decodeBit(this.matchDecoders, (this.state << 4) + posState)) {
      decoder2 = this.getDecoder(lowBits64(this.nowPos64), this.prevByte);
      if (this.state < 7) {
        this.prevByte = this.decodeNormalWithRangeDecoder(decoder2);
      } else {
        this.prevByte = this.decodeWithMatchByteWithRangeDecoder(decoder2, this.getByte(this.rep0));
      }
      this.putByte(this.prevByte);
      this.state = stateUpdateChar(this.state);
      this.nowPos64 = add64(this.nowPos64, [1, 0]);
    } else {
      if (this.decodeBit(this.repDecoders, this.state)) {
        len = 0;
        if (!this.decodeBit(this.repG0Decoders, this.state)) {
          if (!this.decodeBit(this.rep0LongDecoders, (this.state << 4) + posState)) {
            this.state = this.state < 7 ? 9 : 11;
            len = 1;
          }
        } else {
          if (!this.decodeBit(this.repG1Decoders, this.state)) {
            distance = this.rep1;
          } else {
            if (!this.decodeBit(this.repG2Decoders, this.state)) {
              distance = this.rep2;
            } else {
              distance = this.rep3;
              this.rep3 = this.rep2;
            }
            this.rep2 = this.rep1;
          }
          this.rep1 = this.rep0;
          this.rep0 = distance;
        }
        if (!len) {
          len = this.decodeLenWithRangeDecoder(this.repLenDecoder, posState) + 2;
          this.state = this.state < 7 ? 8 : 11;
        }
      } else {
        this.rep3 = this.rep2;
        this.rep2 = this.rep1;
        this.rep1 = this.rep0;
        len = 2 + this.decodeLenWithRangeDecoder(this.lenDecoder, posState);
        this.state = this.state < 7 ? 7 : 10;
        positionSlot = this.rangeBitTreeDecoder(this.posSlotDecoders[getLenToPosState(len)]);
        if (positionSlot >= 4) {
          numDirectBits = (positionSlot >> 1) - 1;
          this.rep0 = (2 | positionSlot & 1) << numDirectBits;
          if (positionSlot < 14) {
            this.rep0 += this.reverseDecode(this.posDecoders, this.rep0 - positionSlot - 1, numDirectBits);
          } else {
            this.rep0 += this.decodeDirectBits(numDirectBits - 4) << 4;
            this.rep0 += this.reverseDecodeAlignDecoder();
            if (this.rep0 < 0) {
              if (this.rep0 == -1) {
                return 1;
              }
              return -1;
            }
          }
        } else {
          this.rep0 = positionSlot;
        }
      }
      if (compare64([this.rep0, 0], this.nowPos64) >= 0 || this.rep0 >= this.dictSizeCheck) {
        return -1;
      }
      this.copyBlock(len);
      this.nowPos64 = add64(this.nowPos64, [len, 0]);
      this.prevByte = this.getByte(0);
    }
    return 0;
  }
  // Setup decoder for chunk processing
  setupForDecoding(inStream, outSize, outputBuffer) {
    this.rangeDecoder.setStream(inStream);
    this.outSize = outSize;
    this.outWindowReleaseStream();
    this.outWindow.stream = outputBuffer;
    this.init();
    this.state = 0;
    this.rep0 = 0;
    this.rep1 = 0;
    this.rep2 = 0;
    this.rep3 = 0;
    this.outSize = outSize;
    this.nowPos64 = [0, 0];
    this.prevByte = 0;
    this.decoder = this;
    this.encoder = null;
    this.alive = 1;
  }
  // Process chunk and return alive status
  processChunk() {
    if (!this.alive) {
      throw new Error("Bad state");
    }
    if (this.encoder) {
      throw new Error("No encoding");
    }
    const result = this.codeOneChunk();
    if (result === -1) {
      throw new Error("Corrupted input");
    }
    const isOutputComplete = compare64(this.outSize, [0, 0]) >= 0 && compare64(this.nowPos64, this.outSize) >= 0;
    if (result || isOutputComplete) {
      this.flush();
      this.outWindowReleaseStream();
      this.rangeDecoder.setStream(null);
      this.alive = 0;
    }
    return this.alive;
  }
  writeToOutput(buffer, data, offset, length) {
    const requiredSize = buffer.count + length;
    if (requiredSize > buffer.buf.length) {
      const newSize = Math.max(buffer.buf.length * 2, requiredSize);
      const newBuf = new Array(newSize);
      for (let i = 0; i < buffer.count; i++) {
        newBuf[i] = buffer.buf[i];
      }
      buffer.buf = newBuf;
    }
    for (let i = 0; i < length; i++) {
      buffer.buf[buffer.count + i] = data[offset + i];
    }
    buffer.count += length;
  }
  isBufferWithCount(x) {
    const s = x;
    return !!s && Array.isArray(s.buf) && typeof s.count === "number" && typeof s.write === "function";
  }
  flush() {
    const size = this.outWindow.pos - this.outWindow.streamPos;
    if (!size) {
      return;
    }
    if (this.outWindow.stream && this.outWindow.buffer) {
      const outputBuffer = this.outWindow.stream;
      if (this.isBufferWithCount(outputBuffer)) {
        this.writeToOutput(outputBuffer, this.outWindow.buffer, this.outWindow.streamPos, size);
      } else if (typeof outputBuffer.write === "function") {
        const slice = this.outWindow.buffer.slice(this.outWindow.streamPos, this.outWindow.streamPos + size);
        outputBuffer.write(slice);
      }
    }
    if (this.outWindow.pos >= this.outWindow.windowSize) {
      this.outWindow.pos = 0;
    }
    this.outWindow.streamPos = this.outWindow.pos;
  }
  /**
   * Cleanup decoder resources
   */
  cleanup() {
    this.outWindow.stream = null;
    this.rangeDecoder.stream = null;
  }
};

// node_modules/lzma1/lib/len-coder.js
var LenEncoder = class {
  constructor() {
    // Choice probability arrays for length range selection
    __publicField(this, "choice", initArray(2));
    // Low range coders (for lengths 2-9)
    __publicField(this, "lowCoder", []);
    // Mid range coders (for lengths 10-17)
    __publicField(this, "midCoder", []);
    // High range coder (for lengths 18+)
    __publicField(this, "highCoder", createBitTree(8));
    // Price optimization properties
    __publicField(this, "tableSize", 0);
    __publicField(this, "prices", []);
    __publicField(this, "counters", []);
    for (let posState = 0; posState < 16; ++posState) {
      this.lowCoder[posState] = createBitTree(3);
      this.midCoder[posState] = createBitTree(3);
    }
  }
  /**
   * Initialize the encoder with specified number of position states
   */
  init(numPosStates) {
    initBitModels(this.choice);
    for (let posState = 0; posState < numPosStates; ++posState) {
      initBitModels(this.lowCoder[posState].models);
      initBitModels(this.midCoder[posState].models);
    }
    initBitModels(this.highCoder.models);
  }
  /**
   * Encode a length value using the provided range encoder
   */
  encode(symbol, posState, rangeEncoder) {
    if (symbol < 8) {
      rangeEncoder.encodeBit(this.choice, 0, 0);
      rangeEncoder.encodeBitTree(this.lowCoder[posState], symbol);
    } else {
      symbol -= 8;
      rangeEncoder.encodeBit(this.choice, 0, 1);
      if (symbol < 8) {
        rangeEncoder.encodeBit(this.choice, 1, 0);
        rangeEncoder.encodeBitTree(this.midCoder[posState], symbol);
      } else {
        rangeEncoder.encodeBit(this.choice, 1, 1);
        rangeEncoder.encodeBitTree(this.highCoder, symbol - 8);
      }
    }
  }
  /**
   * Encode with price table update
   */
  encodeWithUpdate(symbol, posState, rangeEncoder) {
    this.encode(symbol, posState, rangeEncoder);
    if (this.counters && (this.counters[posState] -= 1) == 0) {
      this.counters[posState] = this.tableSize;
    }
  }
  /**
   * Get price for encoding a symbol at the given position state
   */
  getPrice(symbol, posState) {
    return this.prices[posState * 272 + symbol];
  }
  /**
   * Initialize as a price table encoder
   */
  initPriceTable() {
    this.prices = [];
    this.counters = [];
  }
  /**
   * Set table size for price optimization
   */
  setTableSize(size) {
    this.tableSize = size;
  }
  /**
   * Set table size and update internal counters
   */
  setTableSizeAndInitCounters(size, numPosStates) {
    this.tableSize = size;
    if (this.counters) {
      for (let posState = 0; posState < numPosStates; ++posState) {
        this.counters[posState] = size;
      }
    }
  }
  /**
   * Get table size
   */
  getTableSize() {
    return this.tableSize;
  }
  /**
   * Update price tables for all position states
   */
  updateTables(numPosStates) {
    if (!this.prices || !this.counters) {
      this.initPriceTable();
    }
    for (let posState = 0; posState < numPosStates; ++posState) {
      this.setPrices(posState, this.tableSize, this.prices, 0);
      if (this.counters) {
        this.counters[posState] = this.tableSize;
      }
    }
  }
  // Private methods for internal state management
  /**
   * Calculate price for bit tree encoder
   */
  getBitTreePrice(encoder, symbol) {
    let bit, bitIndex, m = 1, price = 0;
    for (bitIndex = encoder.numBitLevels; bitIndex != 0; ) {
      bitIndex -= 1;
      bit = symbol >>> bitIndex & 1;
      price += this.getBitPrice(encoder.models[m], bit);
      m = (m << 1) + bit;
    }
    return price;
  }
  /**
   * Get price for a single bit
   */
  getBitPrice(prob, symbol) {
    return getBitPrice(prob, symbol);
  }
  /**
   * Set prices for all symbols in a position state range
   */
  setPrices(posState, numSymbols, prices, priceIndex) {
    const a0 = this.getBitPrice(this.choice[0], 0);
    const a1 = this.getBitPrice(this.choice[0], 1);
    const b0 = a1 + this.getBitPrice(this.choice[1], 0);
    const b1 = a1 + this.getBitPrice(this.choice[1], 1);
    let i = 0;
    const st = priceIndex + posState * 272;
    for (i = 0; i < 8; ++i) {
      if (i >= numSymbols)
        return;
      prices[st + i] = a0 + this.getBitTreePrice(this.lowCoder[posState], i);
    }
    for (; i < 16; ++i) {
      if (i >= numSymbols)
        return;
      prices[st + i] = b0 + this.getBitTreePrice(this.midCoder[posState], i - 8);
    }
    for (; i < numSymbols; ++i) {
      prices[st + i] = b1 + this.getBitTreePrice(this.highCoder, i - 8 - 8);
    }
  }
};

// node_modules/lzma1/lib/lit-coder.js
var LitSubCoder = class {
  constructor() {
    __publicField(this, "coders");
    this.coders = initArray(768, 1024);
  }
  /**
   * Decode normal literal symbol
   */
  decodeNormal(rd) {
    let symbol = 1;
    while (symbol < 256) {
      const i = rd.decodeBit(this.coders, symbol);
      symbol = symbol << 1 | i;
    }
    return symbol & 255;
  }
  /**
   * Decode literal symbol with match byte context
   */
  decodeWithMatchByte(rd, matchByte) {
    let uMatchByte = matchByte;
    let symbol = 1;
    while (symbol < 256) {
      const matchBit = uMatchByte >> 7 & 1;
      uMatchByte <<= 1;
      const bit = rd.decodeBit(this.coders, (1 + matchBit << 8) + symbol);
      symbol = symbol << 1 | bit;
      if (matchBit !== bit) {
        while (symbol < 256) {
          const i = rd.decodeBit(this.coders, symbol);
          symbol = symbol << 1 | i;
        }
        break;
      }
    }
    return symbol & 255;
  }
  /**
   * Encode literal symbol
   */
  encode(re, symbol) {
    let context = 1;
    for (let i = 7; i >= 0; i--) {
      const bit = symbol >> i & 1;
      re.encodeBit(this.coders, context, bit);
      context = context << 1 | bit;
    }
  }
  /**
   * Encode literal symbol with match byte context
   */
  encodeMatched(re, matchByte, symbol) {
    let uMatchByte = matchByte;
    let context = 1;
    let same = true;
    for (let i = 7; i >= 0; i--) {
      const bit = symbol >> i & 1;
      let state = context;
      if (same) {
        const matchBit = uMatchByte >> i & 1;
        state += 1 + matchBit << 8;
        same = matchBit === bit;
      }
      re.encodeBit(this.coders, state, bit);
      context = context << 1 | bit;
    }
  }
  /**
   * Get price for encoding literal symbol
   */
  getPrice(matchMode, matchByte, symbol) {
    let uMatchByte = matchByte;
    let price = 0;
    let context = 1;
    let i = 7;
    if (matchMode) {
      while (i >= 0) {
        const matchBit = uMatchByte >> i & 1;
        const bit = symbol >> i & 1;
        price += getBitPrice(this.coders[1 + matchBit << 8 + context], bit);
        context = context << 1 | bit;
        if (matchBit !== bit) {
          i--;
          break;
        }
        i--;
      }
    }
    while (i >= 0) {
      const bit = symbol >> i & 1;
      price += getBitPrice(this.coders[context], bit);
      context = context << 1 | bit;
      i--;
    }
    return price;
  }
  /**
   * Reset coder to initial state
   */
  reset() {
    this.coders.fill(1024);
  }
  /**
   * Get decoders array (for compatibility with LiteralDecoderEncoder2)
   */
  get decoders() {
    return this.coders;
  }
};
var LitCoder = class {
  constructor(numPosBits, numPrevBits) {
    __publicField(this, "_coders");
    __publicField(this, "_numPrevBits");
    __publicField(this, "_posMask");
    const numStates = 1 << numPrevBits + numPosBits;
    this._coders = [];
    this._numPrevBits = numPrevBits;
    this._posMask = (1 << numPosBits) - 1;
    for (let i = 0; i < numStates; i++) {
      this._coders[i] = new LitSubCoder();
    }
  }
  /**
   * Get sub-coder for position and previous byte
   */
  getSubCoder(pos, prevByte) {
    return this._coders[((pos & this._posMask) << this._numPrevBits) + (prevByte >> 8 - this._numPrevBits)];
  }
  /**
   * Reset all sub-coders
   */
  reset() {
    this._coders.forEach((coder) => coder.reset());
  }
  /**
   * Get number of previous bits (for compatibility)
   */
  get numPrevBits() {
    return this._numPrevBits;
  }
  /**
   * Get number of position bits (for compatibility)
   */
  get numPosBits() {
    return Math.log2(this._posMask + 1);
  }
  /**
   * Get position mask (for compatibility)
   */
  get posMask() {
    return this._posMask;
  }
  /**
   * Get coders array (for compatibility)
   */
  get coders() {
    return this._coders;
  }
};

// node_modules/lzma1/lib/encoder.js
var bitTreePriceCache = /* @__PURE__ */ new Map();
function getDirectBitsPrice(numBits) {
  return numBits << 6;
}
function getBitTreePrice(bitTree, symbol) {
  const cacheKey = `${bitTree.numBitLevels}-${symbol}`;
  if (bitTreePriceCache.has(cacheKey)) {
    return bitTreePriceCache.get(cacheKey);
  }
  let price = 0;
  let modelIndex = 1;
  for (let bitIndex = bitTree.numBitLevels; bitIndex > 0; bitIndex--) {
    const bit = symbol >>> bitIndex - 1 & 1;
    price += getBitPrice(bitTree.models[modelIndex], bit);
    modelIndex = (modelIndex << 1) + bit;
  }
  if (bitTreePriceCache.size < 1e4) {
    bitTreePriceCache.set(cacheKey, price);
  }
  return price;
}
var EncoderState = class {
  constructor() {
    // Core state
    __publicField(this, "state", 0);
    __publicField(this, "previousByte", 0);
    __publicField(this, "position", [0, 0]);
    // Repetition distances (LZ77 back-references)
    __publicField(this, "repDistances", [0, 0, 0, 0]);
    // Match finding state
    __publicField(this, "longestMatchLength", 0);
    __publicField(this, "longestMatchWasFound", false);
    __publicField(this, "additionalOffset", 0);
    // Probability models for different encoding decisions
    __publicField(this, "isMatch", initArray(192));
    __publicField(this, "isRep", initArray(12));
    __publicField(this, "isRepG0", initArray(12));
    __publicField(this, "isRepG1", initArray(12));
    __publicField(this, "isRepG2", initArray(12));
    __publicField(this, "isRep0Long", initArray(192));
  }
  /**
   * Initialize all probability models to default values
   */
  initModels() {
    initBitModels(this.isMatch);
    initBitModels(this.isRep);
    initBitModels(this.isRepG0);
    initBitModels(this.isRepG1);
    initBitModels(this.isRepG2);
    initBitModels(this.isRep0Long);
  }
  /**
   * Update repetition distances when a new match is found
   */
  updateRepDistances(newDistance, repIndex) {
    if (repIndex === 0) {
      this.repDistances[3] = this.repDistances[2];
      this.repDistances[2] = this.repDistances[1];
      this.repDistances[1] = this.repDistances[0];
      this.repDistances[0] = newDistance;
    } else {
      const temp = this.repDistances[repIndex];
      for (let i = repIndex; i > 0; i--) {
        this.repDistances[i] = this.repDistances[i - 1];
      }
      this.repDistances[0] = temp;
    }
  }
};
var PositionEncoder = class {
  constructor() {
    __publicField(this, "posSlotEncoder", []);
    __publicField(this, "posEncoders", initArray(114));
    __publicField(this, "posAlignEncoder");
    for (let lenState = 0; lenState < 4; lenState++) {
      this.posSlotEncoder[lenState] = createBitTree(6);
    }
    this.posAlignEncoder = createBitTree(4);
  }
  /**
   * Initialize all position models
   */
  init() {
    for (const encoder of this.posSlotEncoder) {
      initBitModels(encoder.models);
    }
    initBitModels(this.posEncoders);
    initBitModels(this.posAlignEncoder.models);
  }
  /**
   * Encode position using optimal method
   */
  encodePosition(distance, lenState, rangeEncoder) {
    const posSlot = this.getPosSlot(distance);
    rangeEncoder.encodeBitTree(this.posSlotEncoder[lenState], posSlot);
    if (posSlot >= 4) {
      const footerBits = (posSlot >> 1) - 1;
      const baseVal = (2 | posSlot & 1) << footerBits;
      const posReduced = distance - baseVal;
      if (posSlot < 14) {
        this.encodeReverseBits(posReduced, footerBits, rangeEncoder);
      } else {
        rangeEncoder.encodeDirectBits(posReduced >> 4, footerBits - 4);
        rangeEncoder.encodeBitTree(this.posAlignEncoder, posReduced & 15);
      }
    }
  }
  /**
   * Calculate price for encoding a position
   */
  getPositionPrice(distance, lenState) {
    const posSlot = this.getPosSlot(distance);
    let price = getBitTreePrice(this.posSlotEncoder[lenState], posSlot);
    if (posSlot >= 4) {
      const footerBits = (posSlot >> 1) - 1;
      const baseVal = (2 | posSlot & 1) << footerBits;
      const posReduced = distance - baseVal;
      if (posSlot < 14) {
        price += this.getReverseBitsPrice(posReduced, footerBits);
      } else {
        price += getDirectBitsPrice(footerBits - 4);
        price += getBitTreePrice(this.posAlignEncoder, posReduced & 15);
      }
    }
    return price;
  }
  getPosSlot(distance) {
    if (distance < 4)
      return distance;
    if (distance < 1 << 31 - 11) {
      return G_FAST_POS[distance >> 6] + 12;
    }
    return G_FAST_POS[distance >> 26] + 52;
  }
  encodeReverseBits(value, numBits, rangeEncoder) {
    let modelIndex = 1;
    for (let i = 0; i < numBits; i++) {
      const bit = value & 1;
      rangeEncoder.encodeBit(this.posEncoders, modelIndex, bit);
      modelIndex = modelIndex << 1 | bit;
      value >>>= 1;
    }
  }
  getReverseBitsPrice(value, numBits) {
    let price = 0;
    let modelIndex = 1;
    for (let i = 0; i < numBits; i++) {
      const bit = value & 1;
      price += getBitPrice(this.posEncoders[modelIndex], bit);
      modelIndex = modelIndex << 1 | bit;
      value >>>= 1;
    }
    return price;
  }
};
var Encoder = class {
  constructor() {
    __publicField(this, "encoderState", new EncoderState());
    __publicField(this, "positionEncoder", new PositionEncoder());
    // Core state properties
    __publicField(this, "_state", 0);
    __publicField(this, "_previousByte", 0);
    __publicField(this, "_distTableSize", 0);
    __publicField(this, "_longestMatchWasFound", 0);
    __publicField(this, "_optimumEndIndex", 0);
    __publicField(this, "_optimumCurrentIndex", 0);
    __publicField(this, "_additionalOffset", 0);
    // Dictionary and match finding
    __publicField(this, "_dictionarySize", 0);
    __publicField(this, "_matchFinder", null);
    __publicField(this, "_dictionarySizePrev", 0);
    __publicField(this, "_numFastBytes", 0);
    // Literal encoding configuration
    __publicField(this, "_numLiteralContextBits", 0);
    __publicField(this, "_numLiteralPosStateBits", 0);
    __publicField(this, "_posStateBits", 0);
    __publicField(this, "_posStateMask", 0);
    // Stream and processing state
    __publicField(this, "_needReleaseMFStream", 0);
    __publicField(this, "_inStream", null);
    __publicField(this, "_finished", 0);
    __publicField(this, "nowPos64", [0, 0]);
    // Distance and repetition arrays
    __publicField(this, "_repDistances", initArray(4));
    __publicField(this, "_optimum", []);
    // Range encoder
    __publicField(this, "_rangeEncoder", {
      stream: {
        buf: [],
        count: 0
      },
      rrange: 0,
      cache: 0,
      low: [0, 0],
      cacheSize: 0,
      position: [0, 0],
      encodeBit: () => {
      },
      encodeBitTree: () => {
      },
      encodeDirectBits: () => {
      }
    });
    // Bit model arrays for different types of encoding decisions
    __publicField(this, "_isMatch", initArray(192));
    __publicField(this, "_isRep", initArray(12));
    __publicField(this, "_isRepG0", initArray(12));
    __publicField(this, "_isRepG1", initArray(12));
    __publicField(this, "_isRepG2", initArray(12));
    __publicField(this, "_isRep0Long", initArray(192));
    // Position and alignment encoders
    __publicField(this, "_posSlotEncoder", []);
    __publicField(this, "_posEncoders", initArray(114));
    __publicField(this, "_posAlignEncoder", null);
    // Length encoders
    __publicField(this, "_lenEncoder", null);
    __publicField(this, "_repMatchLenEncoder", null);
    // Literal encoder
    __publicField(this, "_literalEncoder", null);
    // Distance and price arrays
    __publicField(this, "_matchDistances", []);
    __publicField(this, "_posSlotPrices", []);
    __publicField(this, "_distancesPrices", []);
    __publicField(this, "_alignPrices", initArray(16));
    __publicField(this, "_matchPriceCount", 0);
    __publicField(this, "_alignPriceCount", 0);
    // Optimization arrays
    __publicField(this, "reps", initArray(4));
    __publicField(this, "repLens", initArray(4));
    // Processing counters
    __publicField(this, "processedInSize", [[0, 0]]);
    __publicField(this, "processedOutSize", [[0, 0]]);
    __publicField(this, "finished", [0]);
    __publicField(this, "properties", initArray(5));
    __publicField(this, "tempPrices", initArray(128));
    // 128
    // Match finding properties
    __publicField(this, "_longestMatchLength", 0);
    __publicField(this, "_matchFinderType", 1);
    __publicField(this, "_numDistancePairs", 0);
    __publicField(this, "_numFastBytesPrev", -1);
    __publicField(this, "backRes", 0);
  }
  /**
   * Initialize basic encoder state
   */
  baseInit() {
    this._state = 0;
    this._previousByte = 0;
    for (let i = 0; i < 4; ++i) {
      this._repDistances[i] = 0;
    }
  }
  /**
   * Get optimum array
   */
  getOptimum() {
    return this._optimum;
  }
  /**
   * Get back result
   */
  getBackRes() {
    return this.backRes;
  }
  setBackRes(backRes) {
    this.backRes = backRes;
  }
  init() {
    this.baseInit();
    this.encoderState.initModels();
    this.positionEncoder.init();
    this._optimum = [];
    for (let i = 0; i < 4096; i++) {
      this._optimum[i] = {};
    }
    this.initEncoderState();
    initBitModels(this._isMatch);
    initBitModels(this._isRep0Long);
    initBitModels(this._isRep);
    initBitModels(this._isRepG0);
    initBitModels(this._isRepG1);
    initBitModels(this._isRepG2);
    initBitModels(this._posEncoders);
    this.initLiteralEncoder();
    for (let i = 0; i < 4; ++i) {
      initBitModels(this._posSlotEncoder[i].models);
    }
    if (this._lenEncoder) {
      this._lenEncoder.init(1 << this._posStateBits);
    }
    if (this._repMatchLenEncoder) {
      this._repMatchLenEncoder.init(1 << this._posStateBits);
    }
    if (this._posAlignEncoder) {
      initBitModels(this._posAlignEncoder.models);
    }
    this._longestMatchWasFound = 0;
    this._optimumEndIndex = 0;
    this._optimumCurrentIndex = 0;
    this._additionalOffset = 0;
  }
  /**
   * Initialize encoder range coder
   */
  initEncoderState() {
    this._rangeEncoder.low = [0, 0];
    this._rangeEncoder.rrange = 4294967295;
    this._rangeEncoder.cacheSize = 1;
    this._rangeEncoder.cache = 0;
    this._rangeEncoder.position = [0, 0];
  }
  /**
   * Initialize literal encoder
   */
  initLiteralEncoder() {
    const totalStates = 1 << this._literalEncoder.numPrevBits + this._literalEncoder.numPosBits;
    for (let i = 0; i < totalStates; ++i) {
      initBitModels(this._literalEncoder.coders[i].decoders);
    }
  }
  /**
   * Create optimum structures
   */
  createOptimumStructures() {
    for (let i = 0; i < 4096; ++i) {
      this._optimum[i] = {};
    }
    for (let i = 0; i < 4; ++i) {
      this._posSlotEncoder[i] = createBitTree(6);
    }
  }
  /**
   * Create length price table encoder
   */
  createLenPriceTableEncoder() {
    const encoder = new LenEncoder();
    encoder.initPriceTable();
    return encoder;
  }
  /**
   * Create literal encoder encoder2
   */
  createLiteralEncoderEncoder2() {
    const encoder = {
      decoders: initArray(768)
    };
    return encoder;
  }
  /**
   * Create literal encoder
   */
  createLiteralEncoder() {
    if (this._literalEncoder != null && this._literalEncoder.numPrevBits == this._numLiteralContextBits && this._literalEncoder.numPosBits == this._numLiteralPosStateBits) {
      return;
    }
    this._literalEncoder = new LitCoder(this._numLiteralPosStateBits, this._numLiteralContextBits);
  }
  /**
   * Initialize completely with proper encoder state
   */
  initialize() {
    this._lenEncoder = this.createLenPriceTableEncoder();
    this._repMatchLenEncoder = this.createLenPriceTableEncoder();
    this._posAlignEncoder = createBitTree(4);
    this._optimum = [];
    this.createOptimumStructures();
    this.createLiteralEncoder();
    this.init();
  }
  /**
   * Configure encoder settings
   */
  configure(mode) {
    this.setDictionarySize(1 << mode.searchDepth);
    this._numFastBytes = mode.filterStrength;
    this._matchFinderType = mode.modeIndex;
    this._numLiteralContextBits = 3;
    this._numLiteralPosStateBits = 0;
    this._posStateBits = 2;
    this._posStateMask = 3;
  }
  /**
   * Set dictionary size
   */
  setDictionarySize(dictionarySize) {
    this._dictionarySize = dictionarySize;
    let dicLogSize = 0;
    for (; dictionarySize > 1 << dicLogSize; ++dicLogSize)
      ;
    this._distTableSize = dicLogSize * 2;
  }
  /**
   * Encode a bit using range coder
   */
  encodeBit(probs, index, symbol) {
    const rangeEncoder = this._rangeEncoder;
    let newBound, prob = probs[index];
    newBound = (rangeEncoder.rrange >>> 11) * prob;
    if (!symbol) {
      rangeEncoder.rrange = newBound;
      probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;
    } else {
      rangeEncoder.low = add64(rangeEncoder.low, this.and64(fromInt64(newBound), [4294967295, 0]));
      rangeEncoder.rrange -= newBound;
      probs[index] = prob - (prob >>> 5) << 16 >> 16;
    }
    if (!(rangeEncoder.rrange & -16777216)) {
      rangeEncoder.rrange <<= 8;
      this.shiftLow();
    }
  }
  /**
   * Encode bit tree
   */
  encodeBitTree(encoder, symbol) {
    let bit, bitIndex, m = 1;
    for (bitIndex = encoder.numBitLevels; bitIndex != 0; ) {
      bitIndex -= 1;
      bit = symbol >>> bitIndex & 1;
      this.encodeBit(encoder.models, m, bit);
      m = m << 1 | bit;
    }
  }
  /**
   * Encode literal
   */
  encodeLiteral(encoder, symbol) {
    let bit, context = 1;
    for (let i = 7; i >= 0; --i) {
      bit = symbol >> i & 1;
      this.encodeBit(encoder.decoders, context, bit);
      context = context << 1 | bit;
    }
  }
  /**
   * Encode matched literal
   */
  encodeMatched(encoder, matchByte, symbol) {
    let bit, matchBit, state, same = true, context = 1;
    for (let i = 7; i >= 0; --i) {
      bit = symbol >> i & 1;
      state = context;
      if (same) {
        matchBit = matchByte >> i & 1;
        state += 1 + matchBit << 8;
        same = matchBit === bit;
      }
      this.encodeBit(encoder.decoders, state, bit);
      context = context << 1 | bit;
    }
  }
  /**
   * Encode length using direct method calls
   */
  encodeLength(encoder, symbol, posState) {
    encoder.encode(symbol, posState, this);
  }
  /**
   * Encode direct bits
   */
  encodeDirectBits(valueToEncode, numTotalBits) {
    const rangeEncoder = this._rangeEncoder;
    for (let i = numTotalBits - 1; i >= 0; i -= 1) {
      rangeEncoder.rrange >>>= 1;
      if ((valueToEncode >>> i & 1) == 1) {
        rangeEncoder.low = add64(rangeEncoder.low, fromInt64(rangeEncoder.rrange));
      }
      if (!(rangeEncoder.rrange & -16777216)) {
        rangeEncoder.rrange <<= 8;
        this.shiftLow();
      }
    }
  }
  /**
   * Reverse encode
   */
  reverseEncode(symbol) {
    const posAlignEncoder = this._posAlignEncoder;
    if (!posAlignEncoder)
      return;
    let bit, m = 1;
    for (let i = 0; i < posAlignEncoder.numBitLevels; ++i) {
      bit = symbol & 1;
      this.encodeBit(posAlignEncoder.models, m, bit);
      m = m << 1 | bit;
      symbol >>= 1;
    }
  }
  /**
   * Reverse encode range
   */
  reverseEncodeRange(startIndex, numBitLevels, symbol) {
    let bit, m = 1;
    for (let i = 0; i < numBitLevels; ++i) {
      bit = symbol & 1;
      this.encodeBit(this._posEncoders, startIndex + m, bit);
      m = m << 1 | bit;
      symbol >>= 1;
    }
  }
  /**
   * Write end marker
   */
  writeEndMarker(positionState) {
    this.encodeBit(this._isMatch, (this._state << 4) + positionState, 1);
    this.encodeBit(this._isRep, this._state, 0);
    this._state = this._state < 7 ? 7 : 10;
    this.encodeLength(this._lenEncoder, 0, positionState);
    const posSlot = 63;
    const lenToPosState = getLenToPosState(2);
    this.encodeBitTree(this._posSlotEncoder[lenToPosState], posSlot);
    this.encodeDirectBits(67108863, 26);
    this.reverseEncode(15);
  }
  /**
   * Encode length with price table update
   */
  encodeLengthWithPriceUpdate(encoder, symbol, posState) {
    encoder.encodeWithUpdate(symbol, posState, this);
  }
  and64(a, b) {
    const highBits = ~~Math.max(Math.min(a[1] / 4294967296, 2147483647), -2147483648) & ~~Math.max(Math.min(b[1] / 4294967296, 2147483647), -2147483648);
    const lowBits = lowBits64(a) & lowBits64(b);
    let high = highBits * 4294967296;
    let low = lowBits;
    if (lowBits < 0) {
      low += 4294967296;
    }
    return [low, high];
  }
  shru64(a, n) {
    n &= 63;
    let shiftFact = this.pwrAsDouble(n);
    let sr = create64(Math.floor(a[0] / shiftFact), a[1] / shiftFact);
    if (a[1] < 0) {
      sr = add64(sr, this.shl64([2, 0], 63 - n));
    }
    return sr;
  }
  shl64(a, n) {
    let diff, newHigh, newLow, twoToN;
    n &= 63;
    if (a[0] == 0 && a[1] == -9223372036854776e3) {
      if (!n) {
        return a;
      }
      return [0, 0];
    }
    if (a[1] < 0) {
      throw new Error("Neg");
    }
    twoToN = this.pwrAsDouble(n);
    newHigh = a[1] * twoToN % 18446744073709552e3;
    newLow = a[0] * twoToN;
    diff = newLow - newLow % 4294967296;
    newHigh += diff;
    newLow -= diff;
    if (newHigh >= 9223372036854776e3) {
      newHigh -= 18446744073709552e3;
    }
    return [newLow, newHigh];
  }
  pwrAsDouble(n) {
    if (n <= 30) {
      return 1 << n;
    }
    return this.pwrAsDouble(30) * this.pwrAsDouble(n - 30);
  }
  /**
   * Shift low helper (proper implementation) - public method for external access
   */
  shiftLow() {
    const rangeEncoder = this._rangeEncoder;
    const LowHi = lowBits64(this.shru64(rangeEncoder.low, 32));
    if (LowHi != 0 || compare64(rangeEncoder.low, [4278190080, 0]) < 0) {
      rangeEncoder.position = add64(rangeEncoder.position, fromInt64(rangeEncoder.cacheSize));
      let temp = rangeEncoder.cache;
      do {
        this.writeToStream(rangeEncoder.stream, temp + LowHi);
        temp = 255;
      } while ((rangeEncoder.cacheSize -= 1) != 0);
      rangeEncoder.cache = lowBits64(rangeEncoder.low) >>> 24;
    }
    rangeEncoder.cacheSize += 1;
    rangeEncoder.low = this.shl64(this.and64(rangeEncoder.low, [16777215, 0]), 8);
  }
  /**
   * Write byte to stream
   */
  writeToStream(stream, b) {
    if (!stream)
      return;
    if (stream.count >= stream.buf.length) {
      const newSize = Math.max(stream.buf.length * 2, stream.count + 1);
      const newBuf = new Array(newSize);
      for (let i = 0; i < stream.count; i++) {
        newBuf[i] = stream.buf[i];
      }
      stream.buf = newBuf;
    }
    stream.buf[stream.count++] = b << 24 >> 24;
  }
  initRangeEncoder() {
    this._rangeEncoder.position = [0, 0];
    this._rangeEncoder.low = [0, 0];
    this._rangeEncoder.rrange = -1;
    this._rangeEncoder.cacheSize = 1;
    this._rangeEncoder.cache = 0;
  }
  /**
   * Fill alignment prices for position alignment encoder
   */
  fillAlignPrices() {
    for (let i = 0; i < 16; ++i) {
      this._alignPrices[i] = this.reverseGetPrice(this._posAlignEncoder, i);
    }
    this._alignPriceCount = 0;
  }
  /**
   * Fill distance prices for position encoders
   */
  fillDistancesPrices() {
    let baseVal, bitTreeEncoder, footerBits, posSlot, st, st2;
    for (let i = 4; i < 128; ++i) {
      posSlot = this.getPosSlot(i);
      footerBits = (posSlot >> 1) - 1;
      baseVal = (2 | posSlot & 1) << footerBits;
      this.tempPrices[i] = this.reverseGetPriceArray(this._posEncoders, baseVal - posSlot - 1, footerBits, i - baseVal);
    }
    for (let lenToPosState = 0; lenToPosState < 4; ++lenToPosState) {
      bitTreeEncoder = this._posSlotEncoder[lenToPosState];
      st = lenToPosState << 6;
      for (posSlot = 0; posSlot < this._distTableSize; posSlot += 1) {
        this._posSlotPrices[st + posSlot] = this.rangeCoder_Encoder_GetPrice_1(bitTreeEncoder, posSlot);
      }
      for (posSlot = 14; posSlot < this._distTableSize; posSlot += 1) {
        this._posSlotPrices[st + posSlot] += (posSlot >> 1) - 1 - 4 << 6;
      }
      st2 = lenToPosState * 128;
      for (let i = 0; i < 4; ++i) {
        this._distancesPrices[st2 + i] = this._posSlotPrices[st + i];
      }
      for (let i = 4; i < 128; ++i) {
        this._distancesPrices[st2 + i] = this._posSlotPrices[st + this.getPosSlot(i)] + this.tempPrices[i];
      }
    }
    this._matchPriceCount = 0;
  }
  /**
   * Get position slot for a distance value
   */
  getPosSlot(pos) {
    if (pos < 2048) {
      return G_FAST_POS[pos];
    }
    if (pos < 2097152) {
      return G_FAST_POS[pos >> 10] + 20;
    }
    return G_FAST_POS[pos >> 20] + 40;
  }
  /**
   * Get reverse price for bit tree encoder
   */
  reverseGetPrice(encoder, symbol) {
    let bit, m = 1, price = 0;
    for (let i = encoder.numBitLevels; i != 0; i -= 1) {
      bit = symbol & 1;
      symbol >>>= 1;
      price += this.getPrice(encoder.models[m], bit);
      m = m << 1 | bit;
    }
    return price;
  }
  /**
   * Get reverse price for array of models
   */
  reverseGetPriceArray(Models, startIndex, NumBitLevels, symbol) {
    let bit, m = 1, price = 0;
    for (let i = NumBitLevels; i != 0; i -= 1) {
      bit = symbol & 1;
      symbol >>>= 1;
      price += PROB_PRICES[((Models[startIndex + m] - bit ^ -bit) & 2047) >>> 2];
      m = m << 1 | bit;
    }
    return price;
  }
  /**
   * Get price for probability model (optimized)
   */
  getPrice(Prob, symbol) {
    return getBitPrice(Prob, symbol);
  }
  /**
   * Get price for bit tree encoder (optimized)
   */
  rangeCoder_Encoder_GetPrice_1(encoder, symbol) {
    return getBitTreePrice(encoder, symbol);
  }
  /**
   * Create encoder optimization structures (optimized)
   */
  createEncoderStructures() {
    this._optimum = [];
    for (let i = 0; i < 4096; i++) {
      this._optimum[i] = {};
    }
    for (let i = 0; i < 4096; ++i) {
      this._optimum[i] = {};
    }
    this._posSlotEncoder = new Array(4);
    for (let i = 0; i < 4; ++i) {
      this._posSlotEncoder[i] = createBitTree(6);
    }
  }
  /**
   * Create match finder and encoder structures (replaces #Create_2)
   */
  createMatchFinderAndStructures() {
    if (!this._matchFinder) {
      const binTree = {};
      let numHashBytes = 4;
      if (!this._matchFinderType) {
        numHashBytes = 2;
      }
      binTree.HASH_ARRAY = numHashBytes > 2;
      if (binTree.HASH_ARRAY) {
        binTree.kNumHashDirectBytes = 0;
        binTree.kMinMatchCheck = 4;
        binTree.kFixHashSize = 66560;
      } else {
        binTree.kNumHashDirectBytes = 2;
        binTree.kMinMatchCheck = 3;
        binTree.kFixHashSize = 0;
      }
      binTree._cyclicBufferSize = 0;
      binTree._cyclicBufferPos = 0;
      binTree._streamPos = 0;
      binTree._cutValue = 255;
      binTree._matchMaxLen = 0;
      binTree._streamEndWasReached = 0;
      binTree._pos = 0;
      binTree._posLimit = 0;
      binTree._son = [];
      binTree._hash = [];
      binTree._bufferBase = [];
      binTree._blockSize = 0;
      binTree._keepSizeAfter = 0;
      binTree._keepSizeBefore = 0;
      binTree._pointerToLastSafePosition = 0;
      this._matchFinder = binTree;
    }
    this.createLiteralEncoder();
    if (this._dictionarySize == this._dictionarySizePrev && this._numFastBytesPrev == this._numFastBytes) {
      return;
    }
    this._dictionarySizePrev = this._dictionarySize;
    this._numFastBytesPrev = this._numFastBytes;
  }
  /**
   * Get literal encoder subcoder (utility method)
   */
  getSubCoderUtility(pos, prevByte) {
    const posBits = pos & this._literalEncoder.posMask;
    const posShifted = posBits << this._literalEncoder.numPrevBits;
    const prevByteShift = 8 - this._literalEncoder.numPrevBits;
    const prevByteBits = (prevByte & 255) >>> prevByteShift;
    const coderIndex = posShifted + prevByteBits;
    return this._literalEncoder.coders[coderIndex];
  }
};

// node_modules/lzma1/lib/lz-in-window.js
var LzInWindow = class {
  constructor(matchFinder) {
    __publicField(this, "matchFinder");
    this.matchFinder = matchFinder;
  }
  /**
   * Get a byte at the specified index relative to current position
   */
  getIndexByte(index) {
    const byte = this.matchFinder._bufferBase[this.matchFinder._bufferOffset + this.matchFinder._pos + index];
    return byte;
  }
  /**
   * Calculate match length between current position and a previous position
   */
  getMatchLen(index, distance, limit) {
    if (this.matchFinder._streamEndWasReached) {
      if (this.matchFinder._pos + index + limit > this.matchFinder._streamPos) {
        limit = this.matchFinder._streamPos - (this.matchFinder._pos + index);
      }
    }
    ++distance;
    let i;
    const pby = this.matchFinder._bufferOffset + this.matchFinder._pos + index;
    for (i = 0; i < limit && this.matchFinder._bufferBase[pby + i] == this.matchFinder._bufferBase[pby + i - distance]; ++i)
      ;
    return i;
  }
  /**
   * Get number of available bytes in the input window
   */
  getNumAvailableBytes() {
    return this.matchFinder._streamPos - this.matchFinder._pos;
  }
  /**
   * Move buffer block when reaching buffer boundaries
   */
  moveBlock() {
    let offset = this.matchFinder._bufferOffset + this.matchFinder._pos - this.matchFinder._keepSizeBefore;
    if (offset > 0) {
      --offset;
    }
    const numBytes = this.matchFinder._bufferOffset + this.matchFinder._streamPos - offset;
    for (let i = 0; i < numBytes; ++i) {
      this.matchFinder._bufferBase[i] = this.matchFinder._bufferBase[offset + i];
    }
    this.matchFinder._bufferOffset -= offset;
  }
  /**
   * Move position by one and handle buffer management
   */
  movePos() {
    this.matchFinder._pos += 1;
    if (this.matchFinder._pos > this.matchFinder._posLimit) {
      const pointerToPosition = this.matchFinder._bufferOffset + this.matchFinder._pos;
      if (pointerToPosition > this.matchFinder._pointerToLastSafePosition) {
        this.moveBlock();
      }
      this.readBlock();
    }
  }
  /**
   * Read a block of data from the input stream
   */
  readBlock() {
    if (this.matchFinder._streamEndWasReached) {
      return;
    }
    while (true) {
      const size = -this.matchFinder._bufferOffset + this.matchFinder._blockSize - this.matchFinder._streamPos;
      if (!size) {
        return;
      }
      const bytesRead = this.readFromStream(this.matchFinder._bufferOffset + this.matchFinder._streamPos, size);
      if (bytesRead == -1) {
        this.matchFinder._posLimit = this.matchFinder._streamPos;
        const pointerToPosition = this.matchFinder._bufferOffset + this.matchFinder._posLimit;
        if (pointerToPosition > this.matchFinder._pointerToLastSafePosition) {
          this.matchFinder._posLimit = this.matchFinder._pointerToLastSafePosition - this.matchFinder._bufferOffset;
        }
        this.matchFinder._streamEndWasReached = 1;
        return;
      }
      this.matchFinder._streamPos += bytesRead;
      if (this.matchFinder._streamPos >= this.matchFinder._pos + this.matchFinder._keepSizeAfter) {
        this.matchFinder._posLimit = this.matchFinder._streamPos - this.matchFinder._keepSizeAfter;
      }
    }
  }
  /**
   * Reduce all position offsets by the specified value
   */
  reduceOffsets(subValue) {
    this.matchFinder._bufferOffset += subValue;
    this.matchFinder._posLimit -= subValue;
    this.matchFinder._pos -= subValue;
    this.matchFinder._streamPos -= subValue;
  }
  /**
   * Read data from the input stream into the buffer
   */
  readFromStream(off, len) {
    const stream = this.matchFinder._stream;
    const buffer = this.matchFinder._bufferBase;
    if (stream.pos >= stream.count) {
      return -1;
    }
    let srcBuf;
    if (stream.buf instanceof Uint8Array) {
      srcBuf = Array.from(stream.buf);
    } else if (stream.buf instanceof ArrayBuffer) {
      srcBuf = Array.from(new Uint8Array(stream.buf));
    } else {
      srcBuf = stream.buf;
    }
    len = Math.min(len, stream.count - stream.pos);
    arraycopy(srcBuf, stream.pos, buffer, off, len);
    stream.pos += len;
    return len;
  }
};

// node_modules/lzma1/lib/match-finder-config.js
function computeWindowReservSize(dictionarySize, keepBefore, numFastBytes, keepAfter) {
  return ~~((dictionarySize + keepBefore + numFastBytes + keepAfter) / 2) + 256;
}
function ensureCyclicBuffer(matchFinder, dictionarySize) {
  const cyclicBufferSize = dictionarySize + 1;
  if (matchFinder._cyclicBufferSize !== cyclicBufferSize) {
    const doubledCyclicBufferSize = (matchFinder._cyclicBufferSize = cyclicBufferSize) * 2;
    matchFinder._son = initArray(doubledCyclicBufferSize);
  }
}
function computeHashSize(dictionarySize, hashArrayEnabled) {
  let hs = 65536;
  let hashMask = 0;
  if (hashArrayEnabled) {
    hs = dictionarySize - 1;
    hs |= hs >> 1;
    hs |= hs >> 2;
    hs |= hs >> 4;
    hs |= hs >> 8;
    hs >>= 1;
    hs |= 65535;
    if (hs > 16777216) {
      hs >>= 1;
    }
    hashMask = hs;
    hs += 1;
  }
  return { hashMask, hashSizeSum: hs };
}
function setCutValue(numFastBytes) {
  return 16 + (numFastBytes >> 1);
}
function setMatchMaxLen(numFastBytes) {
  return numFastBytes;
}
function isDictionarySizeBelowThreshold(dictionarySize) {
  return dictionarySize < DICTIONARY_SIZE_THRESHOLD;
}

// node_modules/lzma1/lib/lzma.js
var MODES = {
  1: { searchDepth: 16, filterStrength: 64, modeIndex: 0 },
  2: { searchDepth: 20, filterStrength: 64, modeIndex: 0 },
  3: { searchDepth: 19, filterStrength: 64, modeIndex: 1 },
  4: { searchDepth: 20, filterStrength: 64, modeIndex: 1 },
  5: { searchDepth: 21, filterStrength: 128, modeIndex: 1 },
  6: { searchDepth: 22, filterStrength: 128, modeIndex: 1 },
  7: { searchDepth: 23, filterStrength: 128, modeIndex: 1 },
  8: { searchDepth: 24, filterStrength: 255, modeIndex: 1 },
  9: { searchDepth: 25, filterStrength: 255, modeIndex: 1 }
};
var _encoder, _decoder, _lzInWindow, _compressor, _decompressor, _LZMA_instances, initCompressor_fn, initDecompressor_fn, read_fn, toByteArray_fn, write_fn, write_0_fn, getChars_fn, configure_fn, initCompression_fn, byteArrayCompressor_fn, initDecompression_fn, byteArrayDecompressor_fn, Create_4_fn, MovePos_1_fn, Create_3_fn, GetMatches_fn, Init_5_fn, MovePos_0_fn, NormalizeLinks_fn, SetType_fn, Skip_fn, CodeInChunks_fn, Init_1_fn, Backward_fn, CodeOneBlock_fn, Create_2_fn, Encoder_fn, FillAlignPrices_fn, Flush_fn, GetOptimum_fn, LZMA_Encoder_GetPosLenPrice_fn, GetPureRepPrice_fn, GetRepLen1Price_fn, MovePos_fn, ReadMatchDistances_fn, ReleaseMFStream_fn, ReleaseStreams_fn, LZMA_Encoder_GetSubCoder_fn, RangeCoder_Encoder_GetPrice_0_fn, MakeAsChar_fn, MakeAsShortRep_fn, ReverseGetPrice_fn, GetProcessedSizeAdd_fn, decodeString_fn;
var LZMA = class {
  constructor() {
    __privateAdd(this, _LZMA_instances);
    __privateAdd(this, _encoder);
    __privateAdd(this, _decoder);
    __privateAdd(this, _lzInWindow, null);
    __privateAdd(this, _compressor);
    __privateAdd(this, _decompressor);
    __privateSet(this, _encoder, new Encoder());
    __privateSet(this, _decoder, new Decoder());
    __privateSet(this, _compressor, __privateMethod(this, _LZMA_instances, initCompressor_fn).call(this));
    __privateSet(this, _decompressor, __privateMethod(this, _LZMA_instances, initDecompressor_fn).call(this));
  }
  writeHeaderProperties() {
    const HEADER_SIZE = 5;
    __privateGet(this, _encoder).properties[0] = (__privateGet(this, _encoder)._posStateBits * 5 + __privateGet(this, _encoder)._numLiteralPosStateBits) * 9 + __privateGet(this, _encoder)._numLiteralContextBits & 255;
    for (let byteIndex = 0; byteIndex < 4; byteIndex++) {
      __privateGet(this, _encoder).properties[1 + byteIndex] = __privateGet(this, _encoder)._dictionarySize >> 8 * byteIndex & 255;
    }
    __privateMethod(this, _LZMA_instances, write_0_fn).call(this, __privateGet(this, _compressor).output, __privateGet(this, _encoder).properties, 0, HEADER_SIZE);
  }
  GetPosSlot2(pos) {
    if (pos < 131072) {
      return G_FAST_POS[pos >> 6] + 12;
    }
    if (pos < 134217728) {
      return G_FAST_POS[pos >> 16] + 32;
    }
    return G_FAST_POS[pos >> 26] + 52;
  }
  ReverseEncode(startIndex, NumBitLevels, symbol) {
    let bit, m = 1;
    for (let i = 0; i < NumBitLevels; ++i) {
      bit = symbol & 1;
      __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._posEncoders, startIndex + m, bit);
      m = m << 1 | bit;
      symbol >>= 1;
    }
  }
  encodeString(inputString) {
    let ch, chars = [], elen = 0, l = inputString.length;
    __privateMethod(this, _LZMA_instances, getChars_fn).call(this, inputString, 0, l, chars, 0);
    for (let i = 0; i < l; ++i) {
      ch = chars[i];
      if (ch >= 1 && ch <= 127) {
        ++elen;
      } else if (!ch || ch >= 128 && ch <= 2047) {
        elen += 2;
      } else {
        elen += 3;
      }
    }
    const data = [];
    elen = 0;
    for (let i = 0; i < l; ++i) {
      ch = chars[i];
      if (ch >= 1 && ch <= 127) {
        data[elen++] = ch << 24 >> 24;
      } else if (!ch || ch >= 128 && ch <= 2047) {
        data[elen++] = (192 | ch >> 6 & 31) << 24 >> 24;
        data[elen++] = (128 | ch & 63) << 24 >> 24;
      } else {
        data[elen++] = (224 | ch >> 12 & 15) << 24 >> 24;
        data[elen++] = (128 | ch >> 6 & 63) << 24 >> 24;
        data[elen++] = (128 | ch & 63) << 24 >> 24;
      }
    }
    return data;
  }
  compress(data, mode = 5) {
    const compressionMode = MODES[mode];
    __privateMethod(this, _LZMA_instances, byteArrayCompressor_fn).call(this, data, compressionMode);
    while (__privateGet(this, _compressor).chunker.processChunk())
      ;
    const result = __privateMethod(this, _LZMA_instances, toByteArray_fn).call(this, __privateGet(this, _compressor).output);
    return new Int8Array(result);
  }
  compressString(data, mode = 5) {
    const encodedData = this.encodeString(data);
    return this.compress(new Uint8Array(encodedData), mode);
  }
  decompress(bytearray) {
    __privateMethod(this, _LZMA_instances, byteArrayDecompressor_fn).call(this, bytearray);
    while (__privateGet(this, _decompressor).chunker.processChunk())
      ;
    return __privateMethod(this, _LZMA_instances, toByteArray_fn).call(this, __privateGet(this, _decompressor).output);
  }
  decompressString(bytearray) {
    __privateMethod(this, _LZMA_instances, byteArrayDecompressor_fn).call(this, bytearray);
    while (__privateGet(this, _decompressor).chunker.processChunk())
      ;
    const decodedByteArray = __privateMethod(this, _LZMA_instances, toByteArray_fn).call(this, __privateGet(this, _decompressor).output);
    const result = __privateMethod(this, _LZMA_instances, decodeString_fn).call(this, decodedByteArray);
    if (typeof result === "string") {
      return result;
    } else {
      return String.fromCharCode(...result);
    }
  }
  // Public methods for chunker access
  codeOneBlock() {
    __privateMethod(this, _LZMA_instances, CodeOneBlock_fn).call(this);
  }
  releaseStreams() {
    __privateMethod(this, _LZMA_instances, ReleaseStreams_fn).call(this);
  }
};
_encoder = new WeakMap();
_decoder = new WeakMap();
_lzInWindow = new WeakMap();
_compressor = new WeakMap();
_decompressor = new WeakMap();
_LZMA_instances = new WeakSet();
initCompressor_fn = function() {
  const encoderChunker = new EncoderChunker(this);
  return {
    chunker: encoderChunker,
    output: {
      buf: initArray(32),
      count: 0,
      write: () => {
      }
    }
  };
};
initDecompressor_fn = function() {
  const decoderChunker = new DecoderChunker(__privateGet(this, _decoder));
  return {
    chunker: decoderChunker,
    output: {
      buf: initArray(32),
      count: 0,
      write: () => {
      }
    }
  };
};
read_fn = function(inputStream) {
  if (inputStream.pos >= inputStream.count) {
    return -1;
  }
  let value;
  if (inputStream.buf instanceof ArrayBuffer) {
    value = new Uint8Array(inputStream.buf)[inputStream.pos++];
  } else if (inputStream.buf instanceof Uint8Array) {
    value = inputStream.buf[inputStream.pos++];
  } else {
    value = inputStream.buf[inputStream.pos++];
  }
  return value & 255;
};
toByteArray_fn = function(output) {
  const data = output.buf.slice(0, output.count);
  return data;
};
write_fn = function(buffer, b) {
  if (!buffer)
    return;
  if (buffer.count >= buffer.buf.length) {
    const newSize = Math.max(buffer.buf.length * 2, buffer.count + 1);
    const newBuf = new Array(newSize);
    for (let i = 0; i < buffer.count; i++) {
      newBuf[i] = buffer.buf[i];
    }
    buffer.buf = newBuf;
  }
  buffer.buf[buffer.count++] = b << 24 >> 24;
};
write_0_fn = function(buffer, buf, off, len) {
  const requiredSize = buffer.count + len;
  if (requiredSize > buffer.buf.length) {
    const newSize = Math.max(buffer.buf.length * 2, requiredSize);
    const newBuf = new Array(newSize);
    for (let i = 0; i < buffer.count; i++) {
      newBuf[i] = buffer.buf[i];
    }
    buffer.buf = newBuf;
  }
  arraycopy(buf, off, buffer.buf, buffer.count, len);
  buffer.count += len;
};
getChars_fn = function(inputString, srcBegin, srcEnd, dst, dstBegin) {
  for (let srcIdx = srcBegin; srcIdx < srcEnd; ++srcIdx) {
    dst[dstBegin++] = inputString.charCodeAt(srcIdx);
  }
};
configure_fn = function(mode) {
  __privateGet(this, _encoder).initialize();
  __privateGet(this, _encoder).configure(mode);
};
initCompression_fn = function(input, len, mode) {
  if (compare64(len, N1_LONG_LIT) < 0) {
    throw new Error("invalid length " + len);
  }
  __privateGet(this, _compressor).length_0 = len;
  __privateMethod(this, _LZMA_instances, Encoder_fn).call(this);
  __privateMethod(this, _LZMA_instances, configure_fn).call(this, mode);
  this.writeHeaderProperties();
  for (let i = 0; i < 64; i += 8) {
    __privateMethod(this, _LZMA_instances, write_fn).call(this, __privateGet(this, _compressor).output, lowBits64(shr64(len, i)) & 255);
  }
  __privateGet(this, _encoder)._needReleaseMFStream = 0;
  __privateGet(this, _encoder)._inStream = input;
  __privateGet(this, _encoder)._finished = 0;
  __privateMethod(this, _LZMA_instances, Create_2_fn).call(this);
  __privateGet(this, _encoder)._rangeEncoder.stream = __privateGet(this, _compressor).output;
  __privateGet(this, _encoder).init();
  __privateGet(this, _encoder).fillDistancesPrices();
  __privateGet(this, _encoder).fillAlignPrices();
  __privateGet(this, _encoder)._lenEncoder.setTableSize(__privateGet(this, _encoder)._numFastBytes + 1 - 2);
  __privateGet(this, _encoder)._lenEncoder.updateTables(1 << __privateGet(this, _encoder)._posStateBits);
  __privateGet(this, _encoder)._repMatchLenEncoder.setTableSize(__privateGet(this, _encoder)._numFastBytes + 1 - 2);
  __privateGet(this, _encoder)._repMatchLenEncoder.updateTables(1 << __privateGet(this, _encoder)._posStateBits);
  __privateGet(this, _encoder).nowPos64 = P0_LONG_LIT;
  __privateGet(this, _compressor).chunker.encoder = __privateGet(this, _encoder);
  __privateGet(this, _compressor).chunker.alive = 1;
};
byteArrayCompressor_fn = function(data, mode) {
  const inputSize = data instanceof ArrayBuffer ? data.byteLength : data.length;
  const estimatedOutputSize = Math.max(32, Math.ceil(inputSize * 1.2));
  __privateGet(this, _compressor).output = {
    buf: initArray(estimatedOutputSize),
    count: 0,
    write: () => {
    }
  };
  const inputBuffer = {
    pos: 0,
    buf: data instanceof ArrayBuffer ? new Uint8Array(data) : data,
    count: data instanceof ArrayBuffer ? new Uint8Array(data).length : data.length
  };
  __privateMethod(this, _LZMA_instances, initCompression_fn).call(this, inputBuffer, fromInt64(data instanceof ArrayBuffer ? data.byteLength : data.length), mode);
};
initDecompression_fn = function(input) {
  let hex_length = "", properties = [], r, tmp_length;
  for (let i = 0; i < 5; ++i) {
    r = __privateMethod(this, _LZMA_instances, read_fn).call(this, input);
    if (r == -1) {
      throw new Error("truncated input");
    }
    properties[i] = r << 24 >> 24;
  }
  const isDecoderInitialized = !__privateGet(this, _decoder).setDecoderProperties(properties) ? 1 : 0;
  if (isDecoderInitialized) {
    throw new Error("corrupted input");
  }
  for (let i = 0; i < 64; i += 8) {
    r = __privateMethod(this, _LZMA_instances, read_fn).call(this, input);
    if (r == -1) {
      throw new Error("truncated input");
    }
    r = r.toString(16);
    if (r.length == 1)
      r = "0" + r;
    hex_length = r + "" + hex_length;
  }
  if (/^0+$|^f+$/i.test(hex_length)) {
    __privateGet(this, _compressor).length_0 = N1_LONG_LIT;
  } else {
    tmp_length = parseInt(hex_length, 16);
    if (tmp_length > _MAX_UINT32) {
      __privateGet(this, _compressor).length_0 = N1_LONG_LIT;
    } else {
      __privateGet(this, _compressor).length_0 = fromInt64(tmp_length);
    }
  }
  __privateGet(this, _decompressor).chunker = __privateMethod(this, _LZMA_instances, CodeInChunks_fn).call(this, input, __privateGet(this, _compressor).length_0);
};
byteArrayDecompressor_fn = function(data) {
  const inputDataSize = data instanceof ArrayBuffer ? data.byteLength : data.length;
  const minBufferSize = 32;
  const estimatedOutputSize = inputDataSize * 2;
  const initialBufferSize = Math.max(minBufferSize, estimatedOutputSize);
  __privateGet(this, _decompressor).output = {
    buf: initArray(initialBufferSize),
    count: 0,
    write: () => {
    }
  };
  const inputBuffer = {
    buf: data,
    pos: 0,
    count: data instanceof ArrayBuffer ? data.byteLength : data.length
  };
  __privateMethod(this, _LZMA_instances, initDecompression_fn).call(this, inputBuffer);
};
Create_4_fn = function(keepSizeBefore, keepSizeAfter, keepSizeReserv) {
  let blockSize;
  __privateGet(this, _encoder)._matchFinder._keepSizeBefore = keepSizeBefore;
  __privateGet(this, _encoder)._matchFinder._keepSizeAfter = keepSizeAfter;
  blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
  if (__privateGet(this, _encoder)._matchFinder._bufferBase == null || __privateGet(this, _encoder)._matchFinder._blockSize != blockSize) {
    __privateGet(this, _encoder)._matchFinder._bufferBase = initArray(blockSize);
    __privateGet(this, _encoder)._matchFinder._blockSize = blockSize;
  }
  __privateGet(this, _encoder)._matchFinder._pointerToLastSafePosition = __privateGet(this, _encoder)._matchFinder._blockSize - keepSizeAfter;
};
MovePos_1_fn = function() {
  const matchFinder = __privateGet(this, _compressor).chunker.encoder._matchFinder;
  let pointerToPostion;
  matchFinder._pos += 1;
  if (matchFinder._pos > matchFinder._posLimit) {
    pointerToPostion = matchFinder._bufferOffset + matchFinder._pos;
    if (pointerToPostion > matchFinder._pointerToLastSafePosition) {
      __privateGet(this, _lzInWindow).moveBlock();
    }
    __privateGet(this, _lzInWindow).readBlock();
  }
};
Create_3_fn = function(keepAddBufferBefore, keepAddBufferAfter) {
  const dictionarySize = __privateGet(this, _encoder)._dictionarySize;
  const numFastBytes = __privateGet(this, _encoder)._numFastBytes;
  if (isDictionarySizeBelowThreshold(dictionarySize)) {
    __privateGet(this, _encoder)._matchFinder._cutValue = setCutValue(numFastBytes);
    const windowReservSize = computeWindowReservSize(dictionarySize, keepAddBufferBefore, numFastBytes, keepAddBufferAfter);
    __privateMethod(this, _LZMA_instances, Create_4_fn).call(this, dictionarySize + keepAddBufferBefore, numFastBytes + keepAddBufferAfter, windowReservSize);
    __privateGet(this, _encoder)._matchFinder._matchMaxLen = setMatchMaxLen(numFastBytes);
    ensureCyclicBuffer(__privateGet(this, _encoder)._matchFinder, dictionarySize);
    const { hashMask, hashSizeSum } = computeHashSize(dictionarySize, __privateGet(this, _encoder)._matchFinder.HASH_ARRAY);
    if (__privateGet(this, _encoder)._matchFinder.HASH_ARRAY) {
      __privateGet(this, _encoder)._matchFinder._hashMask = hashMask;
      const finalHashSizeSum = hashSizeSum + __privateGet(this, _encoder)._matchFinder.kFixHashSize;
      if (finalHashSizeSum !== __privateGet(this, _encoder)._matchFinder._hashSizeSum) {
        __privateGet(this, _encoder)._matchFinder._hashSizeSum = finalHashSizeSum;
        __privateGet(this, _encoder)._matchFinder._hash = initArray(finalHashSizeSum);
      }
    } else {
      if (hashSizeSum !== __privateGet(this, _encoder)._matchFinder._hashSizeSum) {
        __privateGet(this, _encoder)._matchFinder._hashSizeSum = hashSizeSum;
        __privateGet(this, _encoder)._matchFinder._hash = initArray(hashSizeSum);
      }
    }
  }
};
GetMatches_fn = function() {
  let count, cur, curMatch, curMatch2, curMatch3, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, maxLen, offset, pby1, ptr0, ptr1, temp;
  const matchFinder = __privateGet(this, _compressor).chunker.encoder._matchFinder;
  const distances = __privateGet(this, _compressor).chunker.encoder._matchDistances;
  if (matchFinder._pos + matchFinder._matchMaxLen <= matchFinder._streamPos) {
    lenLimit = matchFinder._matchMaxLen;
  } else {
    lenLimit = matchFinder._streamPos - matchFinder._pos;
    if (lenLimit < matchFinder.kMinMatchCheck) {
      __privateMethod(this, _LZMA_instances, MovePos_0_fn).call(this);
      return 0;
    }
  }
  offset = 0;
  matchMinPos = matchFinder._pos > matchFinder._cyclicBufferSize ? matchFinder._pos - matchFinder._cyclicBufferSize : 0;
  cur = matchFinder._bufferOffset + matchFinder._pos;
  maxLen = 1;
  hash2Value = 0;
  hash3Value = 0;
  if (matchFinder.HASH_ARRAY) {
    temp = CRC32_TABLE[matchFinder._bufferBase[cur] & 255] ^ matchFinder._bufferBase[cur + 1] & 255;
    hash2Value = temp & 1023;
    temp ^= (matchFinder._bufferBase[cur + 2] & 255) << 8;
    hash3Value = temp & 65535;
    hashValue = (temp ^ CRC32_TABLE[matchFinder._bufferBase[cur + 3] & 255] << 5) & matchFinder._hashMask;
  } else {
    hashValue = matchFinder._bufferBase[cur] & 255 ^ (matchFinder._bufferBase[cur + 1] & 255) << 8;
  }
  curMatch = matchFinder._hash[matchFinder.kFixHashSize + hashValue] || 0;
  if (matchFinder.HASH_ARRAY) {
    curMatch2 = matchFinder._hash[hash2Value] || 0;
    curMatch3 = matchFinder._hash[1024 + hash3Value] || 0;
    matchFinder._hash[hash2Value] = matchFinder._pos;
    matchFinder._hash[1024 + hash3Value] = matchFinder._pos;
    if (curMatch2 > matchMinPos) {
      if (matchFinder._bufferBase[matchFinder._bufferOffset + curMatch2] == matchFinder._bufferBase[cur]) {
        distances[offset++] = maxLen = 2;
        distances[offset++] = matchFinder._pos - curMatch2 - 1;
      }
    }
    if (curMatch3 > matchMinPos) {
      if (matchFinder._bufferBase[matchFinder._bufferOffset + curMatch3] == matchFinder._bufferBase[cur]) {
        if (curMatch3 == curMatch2) {
          offset -= 2;
        }
        distances[offset++] = maxLen = 3;
        distances[offset++] = matchFinder._pos - curMatch3 - 1;
        curMatch2 = curMatch3;
      }
    }
    if (offset != 0 && curMatch2 == curMatch) {
      offset -= 2;
      maxLen = 1;
    }
  }
  matchFinder._hash[matchFinder.kFixHashSize + hashValue] = matchFinder._pos;
  ptr0 = (matchFinder._cyclicBufferPos << 1) + 1;
  ptr1 = matchFinder._cyclicBufferPos << 1;
  len0 = len1 = matchFinder.kNumHashDirectBytes;
  if (matchFinder.kNumHashDirectBytes != 0) {
    if (curMatch > matchMinPos) {
      if (matchFinder._bufferBase[matchFinder._bufferOffset + curMatch + matchFinder.kNumHashDirectBytes] != matchFinder._bufferBase[cur + matchFinder.kNumHashDirectBytes]) {
        distances[offset++] = maxLen = matchFinder.kNumHashDirectBytes;
        distances[offset++] = matchFinder._pos - curMatch - 1;
      }
    }
  }
  count = matchFinder._cutValue;
  while (1) {
    if (curMatch <= matchMinPos || count == 0) {
      count -= 1;
      matchFinder._son[ptr0] = matchFinder._son[ptr1] = 0;
      break;
    }
    delta = matchFinder._pos - curMatch;
    cyclicPos = (delta <= matchFinder._cyclicBufferPos ? matchFinder._cyclicBufferPos - delta : matchFinder._cyclicBufferPos - delta + matchFinder._cyclicBufferSize) << 1;
    pby1 = matchFinder._bufferOffset + curMatch;
    len = len0 < len1 ? len0 : len1;
    if (matchFinder._bufferBase[pby1 + len] == matchFinder._bufferBase[cur + len]) {
      while ((len += 1) != lenLimit) {
        if (matchFinder._bufferBase[pby1 + len] != matchFinder._bufferBase[cur + len]) {
          break;
        }
      }
      if (maxLen < len) {
        distances[offset++] = maxLen = len;
        distances[offset++] = delta - 1;
        if (len == lenLimit) {
          matchFinder._son[ptr1] = matchFinder._son[cyclicPos];
          matchFinder._son[ptr0] = matchFinder._son[cyclicPos + 1];
          break;
        }
      }
    }
    if ((matchFinder._bufferBase[pby1 + len] & 255) < (matchFinder._bufferBase[cur + len] & 255)) {
      matchFinder._son[ptr1] = curMatch;
      ptr1 = cyclicPos + 1;
      curMatch = matchFinder._son[ptr1];
      len1 = len;
    } else {
      matchFinder._son[ptr0] = curMatch;
      ptr0 = cyclicPos;
      curMatch = matchFinder._son[ptr0];
      len0 = len;
    }
  }
  __privateMethod(this, _LZMA_instances, MovePos_0_fn).call(this);
  return offset;
};
Init_5_fn = function() {
  __privateGet(this, _compressor).chunker.encoder._matchFinder._bufferOffset = 0;
  __privateGet(this, _compressor).chunker.encoder._matchFinder._pos = 0;
  __privateGet(this, _compressor).chunker.encoder._matchFinder._streamPos = 0;
  __privateGet(this, _compressor).chunker.encoder._matchFinder._streamEndWasReached = 0;
  __privateGet(this, _lzInWindow).readBlock();
  __privateGet(this, _compressor).chunker.encoder._matchFinder._cyclicBufferPos = 0;
  __privateGet(this, _lzInWindow).reduceOffsets(-1);
};
MovePos_0_fn = function() {
  let subValue;
  const matchFinder = __privateGet(this, _compressor).chunker.encoder._matchFinder;
  if ((matchFinder._cyclicBufferPos += 1) >= matchFinder._cyclicBufferSize) {
    matchFinder._cyclicBufferPos = 0;
  }
  __privateMethod(this, _LZMA_instances, MovePos_1_fn).call(this);
  if (matchFinder._pos == DICTIONARY_SIZE_THRESHOLD) {
    subValue = matchFinder._pos - matchFinder._cyclicBufferSize;
    __privateMethod(this, _LZMA_instances, NormalizeLinks_fn).call(this, matchFinder._cyclicBufferSize * 2, subValue);
    __privateMethod(this, _LZMA_instances, NormalizeLinks_fn).call(this, matchFinder._hashSizeSum, subValue);
    __privateGet(this, _lzInWindow).reduceOffsets(subValue);
  }
};
/**
 * This is only called after reading one whole gigabyte.
 */
NormalizeLinks_fn = function(numItems, subValue) {
  const items = __privateGet(this, _compressor).chunker.encoder._matchFinder._son;
  for (let i = 0, value; i < numItems; ++i) {
    value = items[i] || 0;
    if (value <= subValue) {
      value = 0;
    } else {
      value -= subValue;
    }
    items[i] = value;
  }
};
SetType_fn = function(binTree, numHashBytes) {
  binTree.HASH_ARRAY = numHashBytes > 2;
  if (binTree.HASH_ARRAY) {
    binTree.kNumHashDirectBytes = 0;
    binTree.kMinMatchCheck = 4;
    binTree.kFixHashSize = 66560;
  } else {
    binTree.kNumHashDirectBytes = 2;
    binTree.kMinMatchCheck = 3;
    binTree.kFixHashSize = 0;
  }
};
Skip_fn = function(num) {
  const matchFinder = __privateGet(this, _compressor).chunker.encoder._matchFinder;
  let count, cur, curMatch, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, pby1, ptr0, ptr1, temp;
  do {
    if (matchFinder._pos + matchFinder._matchMaxLen <= matchFinder._streamPos) {
      lenLimit = matchFinder._matchMaxLen;
    } else {
      lenLimit = matchFinder._streamPos - matchFinder._pos;
      if (lenLimit < matchFinder.kMinMatchCheck) {
        __privateMethod(this, _LZMA_instances, MovePos_0_fn).call(this);
        continue;
      }
    }
    matchMinPos = matchFinder._pos > matchFinder._cyclicBufferSize ? matchFinder._pos - matchFinder._cyclicBufferSize : 0;
    cur = matchFinder._bufferOffset + matchFinder._pos;
    if (matchFinder.HASH_ARRAY) {
      temp = CRC32_TABLE[matchFinder._bufferBase[cur] & 255] ^ matchFinder._bufferBase[cur + 1] & 255;
      hash2Value = temp & 1023;
      matchFinder._hash[hash2Value] = matchFinder._pos;
      temp ^= (matchFinder._bufferBase[cur + 2] & 255) << 8;
      hash3Value = temp & 65535;
      matchFinder._hash[1024 + hash3Value] = matchFinder._pos;
      hashValue = (temp ^ CRC32_TABLE[matchFinder._bufferBase[cur + 3] & 255] << 5) & matchFinder._hashMask;
    } else {
      hashValue = matchFinder._bufferBase[cur] & 255 ^ (matchFinder._bufferBase[cur + 1] & 255) << 8;
    }
    curMatch = matchFinder._hash[matchFinder.kFixHashSize + hashValue];
    matchFinder._hash[matchFinder.kFixHashSize + hashValue] = matchFinder._pos;
    ptr0 = (matchFinder._cyclicBufferPos << 1) + 1;
    ptr1 = matchFinder._cyclicBufferPos << 1;
    len0 = len1 = matchFinder.kNumHashDirectBytes;
    count = matchFinder._cutValue;
    while (1) {
      if (curMatch <= matchMinPos || count == 0) {
        count -= 1;
        matchFinder._son[ptr0] = matchFinder._son[ptr1] = 0;
        break;
      }
      delta = matchFinder._pos - curMatch;
      cyclicPos = (delta <= matchFinder._cyclicBufferPos ? matchFinder._cyclicBufferPos - delta : matchFinder._cyclicBufferPos - delta + matchFinder._cyclicBufferSize) << 1;
      pby1 = matchFinder._bufferOffset + curMatch;
      len = len0 < len1 ? len0 : len1;
      if (matchFinder._bufferBase[pby1 + len] == matchFinder._bufferBase[cur + len]) {
        while ((len += 1) != lenLimit) {
          if (matchFinder._bufferBase[pby1 + len] != matchFinder._bufferBase[cur + len]) {
            break;
          }
        }
        if (len == lenLimit) {
          matchFinder._son[ptr1] = matchFinder._son[cyclicPos];
          matchFinder._son[ptr0] = matchFinder._son[cyclicPos + 1];
          break;
        }
      }
      if ((matchFinder._bufferBase[pby1 + len] & 255) < (matchFinder._bufferBase[cur + len] & 255)) {
        matchFinder._son[ptr1] = curMatch;
        ptr1 = cyclicPos + 1;
        curMatch = matchFinder._son[ptr1];
        len1 = len;
      } else {
        matchFinder._son[ptr0] = curMatch;
        ptr0 = cyclicPos;
        curMatch = matchFinder._son[ptr0];
        len0 = len;
      }
    }
    __privateMethod(this, _LZMA_instances, MovePos_0_fn).call(this);
  } while ((num -= 1) != 0);
};
CodeInChunks_fn = function(inStream, outSize) {
  __privateGet(this, _decoder).rangeDecoder.stream = inStream;
  __privateGet(this, _decoder).flush();
  __privateGet(this, _decoder).outWindow.stream = null;
  __privateGet(this, _decoder).outWindow.stream = __privateGet(this, _decompressor).output;
  __privateMethod(this, _LZMA_instances, Init_1_fn).call(this);
  __privateGet(this, _decoder).state = 0;
  __privateGet(this, _decoder).rep0 = 0;
  __privateGet(this, _decoder).rep1 = 0;
  __privateGet(this, _decoder).rep2 = 0;
  __privateGet(this, _decoder).rep3 = 0;
  __privateGet(this, _decoder).outSize = outSize;
  __privateGet(this, _decoder).nowPos64 = P0_LONG_LIT;
  __privateGet(this, _decoder).prevByte = 0;
  const decoderChunker = new DecoderChunker(__privateGet(this, _decoder));
  decoderChunker.alive = 1;
  return decoderChunker;
};
Init_1_fn = function() {
  __privateGet(this, _decoder).init();
};
Backward_fn = function(cur) {
  const encoder = __privateGet(this, _compressor).chunker.encoder;
  let backCur, backMem, posMem, posPrev;
  encoder._optimumEndIndex = cur;
  posMem = encoder._optimum[cur].posPrev;
  backMem = encoder._optimum[cur].backPrev;
  do {
    if (encoder._optimum[cur].prev1IsChar) {
      __privateMethod(this, _LZMA_instances, MakeAsChar_fn).call(this, encoder._optimum[posMem]);
      encoder._optimum[posMem].posPrev = posMem - 1;
      if (encoder._optimum[cur].prev2) {
        encoder._optimum[posMem - 1].prev1IsChar = 0;
        encoder._optimum[posMem - 1].posPrev = encoder._optimum[cur].posPrev2;
        encoder._optimum[posMem - 1].backPrev = encoder._optimum[cur].backPrev2;
      }
    }
    posPrev = posMem;
    backCur = backMem;
    backMem = encoder._optimum[posPrev].backPrev;
    posMem = encoder._optimum[posPrev].posPrev;
    encoder._optimum[posPrev].backPrev = backCur;
    encoder._optimum[posPrev].posPrev = cur;
    cur = posPrev;
  } while (cur > 0);
  encoder.backRes = encoder._optimum[0].backPrev;
  encoder._optimumCurrentIndex = encoder._optimum[0].posPrev;
  return encoder._optimumCurrentIndex;
};
CodeOneBlock_fn = function() {
  let baseVal, complexState, curByte, distance, footerBits, len, lenToPosState, matchByte, pos, posReduced, posSlot, posState, progressPosValuePrev, subCoder;
  __privateGet(this, _compressor).chunker.encoder.processedInSize[0] = P0_LONG_LIT;
  __privateGet(this, _compressor).chunker.encoder.processedOutSize[0] = P0_LONG_LIT;
  __privateGet(this, _compressor).chunker.encoder.finished[0] = 1;
  progressPosValuePrev = __privateGet(this, _compressor).chunker.encoder.nowPos64;
  if (__privateGet(this, _compressor).chunker.encoder._inStream) {
    __privateGet(this, _compressor).chunker.encoder._matchFinder._stream = __privateGet(this, _compressor).chunker.encoder._inStream;
    __privateMethod(this, _LZMA_instances, Init_5_fn).call(this);
    __privateGet(this, _compressor).chunker.encoder._needReleaseMFStream = 1;
    __privateGet(this, _compressor).chunker.encoder._inStream = null;
  }
  if (__privateGet(this, _compressor).chunker.encoder._finished) {
    return;
  }
  __privateGet(this, _compressor).chunker.encoder._finished = 1;
  if (compare64(__privateGet(this, _compressor).chunker.encoder.nowPos64, P0_LONG_LIT) === 0) {
    if (!__privateGet(this, _lzInWindow).getNumAvailableBytes()) {
      __privateMethod(this, _LZMA_instances, Flush_fn).call(this, lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64));
      return;
    }
    __privateMethod(this, _LZMA_instances, ReadMatchDistances_fn).call(this);
    posState = lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64) & __privateGet(this, _compressor).chunker.encoder._posStateMask;
    __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isMatch, (__privateGet(this, _compressor).chunker.encoder._state << 4) + posState, 0);
    __privateGet(this, _compressor).chunker.encoder._state = stateUpdateChar(__privateGet(this, _compressor).chunker.encoder._state);
    curByte = __privateGet(this, _lzInWindow).getIndexByte(-__privateGet(this, _compressor).chunker.encoder._additionalOffset);
    __privateGet(this, _compressor).chunker.encoder.encodeLiteral(__privateMethod(this, _LZMA_instances, LZMA_Encoder_GetSubCoder_fn).call(this, lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64), __privateGet(this, _compressor).chunker.encoder._previousByte), curByte);
    __privateGet(this, _compressor).chunker.encoder._previousByte = curByte;
    __privateGet(this, _compressor).chunker.encoder._additionalOffset -= 1;
    __privateGet(this, _compressor).chunker.encoder.nowPos64 = add64(__privateGet(this, _compressor).chunker.encoder.nowPos64, P1_LONG_LIT);
  }
  if (!__privateGet(this, _lzInWindow).getNumAvailableBytes()) {
    __privateMethod(this, _LZMA_instances, Flush_fn).call(this, lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64));
    return;
  }
  while (1) {
    len = __privateMethod(this, _LZMA_instances, GetOptimum_fn).call(this, lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64));
    pos = __privateGet(this, _compressor).chunker.encoder.backRes;
    posState = lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64) & __privateGet(this, _compressor).chunker.encoder._posStateMask;
    complexState = (__privateGet(this, _compressor).chunker.encoder._state << 4) + posState;
    if (len == 1 && pos == -1) {
      __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isMatch, complexState, 0);
      curByte = __privateGet(this, _lzInWindow).getIndexByte(-__privateGet(this, _compressor).chunker.encoder._additionalOffset);
      subCoder = __privateMethod(this, _LZMA_instances, LZMA_Encoder_GetSubCoder_fn).call(this, lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64), __privateGet(this, _compressor).chunker.encoder._previousByte);
      if (__privateGet(this, _compressor).chunker.encoder._state < 7) {
        __privateGet(this, _compressor).chunker.encoder.encodeLiteral(subCoder, curByte);
      } else {
        matchByte = __privateGet(this, _lzInWindow).getIndexByte(-__privateGet(this, _compressor).chunker.encoder._repDistances[0] - 1 - __privateGet(this, _compressor).chunker.encoder._additionalOffset);
        __privateGet(this, _compressor).chunker.encoder.encodeMatched(subCoder, matchByte, curByte);
      }
      __privateGet(this, _compressor).chunker.encoder._previousByte = curByte;
      __privateGet(this, _compressor).chunker.encoder._state = stateUpdateChar(__privateGet(this, _compressor).chunker.encoder._state);
    } else {
      __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isMatch, complexState, 1);
      if (pos < 4) {
        __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRep, __privateGet(this, _compressor).chunker.encoder._state, 1);
        if (!pos) {
          __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRepG0, __privateGet(this, _compressor).chunker.encoder._state, 0);
          if (len == 1) {
            __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRep0Long, complexState, 0);
          } else {
            __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRep0Long, complexState, 1);
          }
        } else {
          __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRepG0, __privateGet(this, _compressor).chunker.encoder._state, 1);
          if (pos == 1) {
            __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRepG1, __privateGet(this, _compressor).chunker.encoder._state, 0);
          } else {
            __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRepG1, __privateGet(this, _compressor).chunker.encoder._state, 1);
            __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRepG2, __privateGet(this, _compressor).chunker.encoder._state, pos - 2);
          }
        }
        if (len == 1) {
          __privateGet(this, _compressor).chunker.encoder._state = __privateGet(this, _compressor).chunker.encoder._state < 7 ? 9 : 11;
        } else {
          __privateGet(this, _compressor).chunker.encoder.encodeLength(__privateGet(this, _compressor).chunker.encoder._repMatchLenEncoder, len - 2, posState);
          __privateGet(this, _compressor).chunker.encoder._state = __privateGet(this, _compressor).chunker.encoder._state < 7 ? 8 : 11;
        }
        distance = __privateGet(this, _compressor).chunker.encoder._repDistances[pos];
        if (pos != 0) {
          const encoder = __privateGet(this, _compressor).chunker.encoder;
          for (let i = pos; i >= 1; --i) {
            encoder._repDistances[i] = encoder._repDistances[i - 1];
          }
          encoder._repDistances[0] = distance;
        }
      } else {
        __privateGet(this, _compressor).chunker.encoder.encodeBit(__privateGet(this, _compressor).chunker.encoder._isRep, __privateGet(this, _compressor).chunker.encoder._state, 0);
        __privateGet(this, _compressor).chunker.encoder._state = __privateGet(this, _compressor).chunker.encoder._state < 7 ? 7 : 10;
        __privateGet(this, _compressor).chunker.encoder.encodeLength(__privateGet(this, _compressor).chunker.encoder._lenEncoder, len - 2, posState);
        pos -= 4;
        posSlot = __privateGet(this, _compressor).chunker.encoder.getPosSlot(pos);
        lenToPosState = getLenToPosState(len);
        __privateGet(this, _compressor).chunker.encoder.encodeBitTree(__privateGet(this, _compressor).chunker.encoder._posSlotEncoder[lenToPosState], posSlot);
        if (posSlot >= 4) {
          footerBits = (posSlot >> 1) - 1;
          baseVal = (2 | posSlot & 1) << footerBits;
          posReduced = pos - baseVal;
          if (posSlot < 14) {
            __privateGet(this, _compressor).chunker.encoder.reverseEncodeRange(baseVal - posSlot - 1, footerBits, posReduced);
          } else {
            __privateGet(this, _compressor).chunker.encoder.encodeDirectBits(posReduced >> 4, footerBits - 4);
            __privateGet(this, _compressor).chunker.encoder.reverseEncode(posReduced & 15);
            __privateGet(this, _compressor).chunker.encoder._alignPriceCount += 1;
          }
        }
        distance = pos;
        const encoder2 = __privateGet(this, _compressor).chunker.encoder;
        for (let i = 3; i >= 1; --i) {
          encoder2._repDistances[i] = encoder2._repDistances[i - 1];
        }
        encoder2._repDistances[0] = distance;
        encoder2._matchPriceCount += 1;
      }
      __privateGet(this, _compressor).chunker.encoder._previousByte = __privateGet(this, _lzInWindow).getIndexByte(len - 1 - __privateGet(this, _compressor).chunker.encoder._additionalOffset);
    }
    __privateGet(this, _compressor).chunker.encoder._additionalOffset -= len;
    __privateGet(this, _compressor).chunker.encoder.nowPos64 = add64(__privateGet(this, _compressor).chunker.encoder.nowPos64, fromInt64(len));
    if (!__privateGet(this, _compressor).chunker.encoder._additionalOffset) {
      if (__privateGet(this, _compressor).chunker.encoder._matchPriceCount >= 128) {
        __privateGet(this, _compressor).chunker.encoder.fillDistancesPrices();
      }
      if (__privateGet(this, _compressor).chunker.encoder._alignPriceCount >= 16) {
        __privateMethod(this, _LZMA_instances, FillAlignPrices_fn).call(this, __privateGet(this, _compressor).chunker.encoder);
      }
      __privateGet(this, _compressor).chunker.encoder.processedInSize[0] = __privateGet(this, _compressor).chunker.encoder.nowPos64;
      __privateGet(this, _compressor).chunker.encoder.processedOutSize[0] = __privateMethod(this, _LZMA_instances, GetProcessedSizeAdd_fn).call(this);
      if (!__privateGet(this, _lzInWindow).getNumAvailableBytes()) {
        __privateMethod(this, _LZMA_instances, Flush_fn).call(this, lowBits64(__privateGet(this, _compressor).chunker.encoder.nowPos64));
        return;
      }
      if (compare64(sub64(__privateGet(this, _compressor).chunker.encoder.nowPos64, progressPosValuePrev), [4096, 0]) >= 0) {
        __privateGet(this, _compressor).chunker.encoder._finished = 0;
        __privateGet(this, _compressor).chunker.encoder.finished[0] = 0;
        return;
      }
    }
  }
};
Create_2_fn = function() {
  let binTree, numHashBytes;
  if (!__privateGet(this, _encoder)._matchFinder) {
    binTree = {};
    numHashBytes = 4;
    if (!__privateGet(this, _encoder)._matchFinderType) {
      numHashBytes = 2;
    }
    __privateMethod(this, _LZMA_instances, SetType_fn).call(this, binTree, numHashBytes);
    __privateGet(this, _encoder)._matchFinder = binTree;
    __privateSet(this, _lzInWindow, new LzInWindow(binTree));
  }
  __privateGet(this, _encoder).createLiteralEncoder();
  if (__privateGet(this, _encoder)._dictionarySize == __privateGet(this, _encoder)._dictionarySizePrev && __privateGet(this, _encoder)._numFastBytesPrev == __privateGet(this, _encoder)._numFastBytes) {
    return;
  }
  __privateMethod(this, _LZMA_instances, Create_3_fn).call(this, 4096, 274);
  __privateGet(this, _encoder)._dictionarySizePrev = __privateGet(this, _encoder)._dictionarySize;
  __privateGet(this, _encoder)._numFastBytesPrev = __privateGet(this, _encoder)._numFastBytes;
};
Encoder_fn = function() {
  for (let i = 0; i < 4096; ++i) {
    __privateGet(this, _encoder)._optimum[i] = {};
  }
  for (let i = 0; i < 4; ++i) {
    __privateGet(this, _encoder)._posSlotEncoder[i] = createBitTree(6);
  }
};
FillAlignPrices_fn = function(encoder) {
  for (let i = 0; i < 16; ++i) {
    encoder._alignPrices[i] = __privateMethod(this, _LZMA_instances, ReverseGetPrice_fn).call(this, encoder._posAlignEncoder, i);
  }
  encoder._alignPriceCount = 0;
};
Flush_fn = function(nowPos) {
  __privateMethod(this, _LZMA_instances, ReleaseMFStream_fn).call(this);
  __privateGet(this, _compressor).chunker.encoder.writeEndMarker(nowPos & __privateGet(this, _compressor).chunker.encoder._posStateMask);
  for (let i = 0; i < 5; ++i) {
    __privateGet(this, _compressor).chunker.encoder.shiftLow();
  }
};
GetOptimum_fn = function(position) {
  let cur, curAnd1Price, curAndLenCharPrice, curAndLenPrice, curBack, curPrice, currentByte, distance, len, lenEnd, lenMain, lenTest, lenTest2, lenTestTemp, matchByte, matchPrice, newLen, nextIsChar, nextMatchPrice, nextOptimum, nextRepMatchPrice, normalMatchPrice, numAvailableBytes, numAvailableBytesFull, numDistancePairs, offs, offset, opt, optimum, pos, posPrev, posState, posStateNext, price_4, repIndex, repLen, repMatchPrice, repMaxIndex, shortRepPrice, startLen, state, state2, t, price, price_0, price_1, price_2, price_3, lenRes;
  const encoder = __privateGet(this, _compressor).chunker.encoder;
  if (encoder._optimumEndIndex != encoder._optimumCurrentIndex) {
    lenRes = encoder._optimum[encoder._optimumCurrentIndex].posPrev - encoder._optimumCurrentIndex;
    encoder.backRes = encoder._optimum[encoder._optimumCurrentIndex].backPrev;
    encoder._optimumCurrentIndex = encoder._optimum[encoder._optimumCurrentIndex].posPrev;
    return lenRes;
  }
  encoder._optimumCurrentIndex = encoder._optimumEndIndex = 0;
  if (encoder._longestMatchWasFound) {
    lenMain = encoder._longestMatchLength;
    encoder._longestMatchWasFound = 0;
  } else {
    lenMain = __privateMethod(this, _LZMA_instances, ReadMatchDistances_fn).call(this);
  }
  numDistancePairs = encoder._numDistancePairs;
  numAvailableBytes = __privateGet(this, _lzInWindow).getNumAvailableBytes() + 1;
  if (numAvailableBytes < 2) {
    encoder.backRes = -1;
    return 1;
  }
  if (numAvailableBytes > 273) {
    numAvailableBytes = 273;
  }
  repMaxIndex = 0;
  for (let i = 0; i < 4; ++i) {
    encoder.reps[i] = encoder._repDistances[i];
    encoder.repLens[i] = __privateGet(this, _lzInWindow).getMatchLen(-1, encoder.reps[i], 273);
    if (encoder.repLens[i] > encoder.repLens[repMaxIndex]) {
      repMaxIndex = i;
    }
  }
  if (encoder.repLens[repMaxIndex] >= encoder._numFastBytes) {
    encoder.backRes = repMaxIndex;
    lenRes = encoder.repLens[repMaxIndex];
    __privateMethod(this, _LZMA_instances, MovePos_fn).call(this, lenRes - 1);
    return lenRes;
  }
  if (lenMain >= encoder._numFastBytes) {
    encoder.backRes = __privateGet(this, _compressor).chunker.encoder._matchDistances[numDistancePairs - 1] + 4;
    __privateMethod(this, _LZMA_instances, MovePos_fn).call(this, lenMain - 1);
    return lenMain;
  }
  currentByte = __privateGet(this, _lzInWindow).getIndexByte(-1);
  matchByte = __privateGet(this, _lzInWindow).getIndexByte(-encoder._repDistances[0] - 1 - 1);
  if (lenMain < 2 && currentByte != matchByte && encoder.repLens[repMaxIndex] < 2) {
    encoder.backRes = -1;
    return 1;
  }
  encoder._optimum[0].state = encoder._state;
  posState = position & encoder._posStateMask;
  encoder._optimum[1].price = PROB_PRICES[encoder._isMatch[(encoder._state << 4) + posState] >>> 2] + __privateMethod(this, _LZMA_instances, RangeCoder_Encoder_GetPrice_0_fn).call(this, __privateMethod(this, _LZMA_instances, LZMA_Encoder_GetSubCoder_fn).call(this, position, encoder._previousByte), encoder._state >= 7, matchByte, currentByte);
  __privateMethod(this, _LZMA_instances, MakeAsChar_fn).call(this, encoder._optimum[1]);
  matchPrice = PROB_PRICES[2048 - encoder._isMatch[(encoder._state << 4) + posState] >>> 2];
  repMatchPrice = matchPrice + PROB_PRICES[2048 - encoder._isRep[encoder._state] >>> 2];
  if (matchByte == currentByte) {
    shortRepPrice = repMatchPrice + __privateMethod(this, _LZMA_instances, GetRepLen1Price_fn).call(this, posState);
    if (shortRepPrice < encoder._optimum[1].price) {
      encoder._optimum[1].price = shortRepPrice;
      __privateMethod(this, _LZMA_instances, MakeAsShortRep_fn).call(this, encoder._optimum[1]);
    }
  }
  lenEnd = lenMain >= encoder.repLens[repMaxIndex] ? lenMain : encoder.repLens[repMaxIndex];
  if (lenEnd < 2) {
    encoder.backRes = encoder._optimum[1].backPrev;
    return 1;
  }
  encoder._optimum[1].posPrev = 0;
  encoder._optimum[0].backs0 = encoder.reps[0];
  encoder._optimum[0].backs1 = encoder.reps[1];
  encoder._optimum[0].backs2 = encoder.reps[2];
  encoder._optimum[0].backs3 = encoder.reps[3];
  len = lenEnd;
  do {
    encoder._optimum[len].price = INFINITY_PRICE;
    len -= 1;
  } while (len >= 2);
  for (let i = 0; i < 4; ++i) {
    repLen = encoder.repLens[i];
    if (repLen < 2) {
      continue;
    }
    price_4 = repMatchPrice + __privateMethod(this, _LZMA_instances, GetPureRepPrice_fn).call(this, i, encoder._state, posState);
    do {
      curAndLenPrice = price_4 + encoder._repMatchLenEncoder.getPrice(repLen - 2, posState);
      optimum = encoder._optimum[repLen];
      if (curAndLenPrice < optimum.price) {
        optimum.price = curAndLenPrice;
        optimum.posPrev = 0;
        optimum.backPrev = i;
        optimum.prev1IsChar = 0;
      }
    } while ((repLen -= 1) >= 2);
  }
  normalMatchPrice = matchPrice + PROB_PRICES[encoder._isRep[encoder._state] >>> 2];
  len = encoder.repLens[0] >= 2 ? encoder.repLens[0] + 1 : 2;
  if (len <= lenMain) {
    offs = 0;
    while (len > encoder._matchDistances[offs]) {
      offs += 2;
    }
    for (; ; len += 1) {
      distance = encoder._matchDistances[offs + 1];
      curAndLenPrice = normalMatchPrice + __privateMethod(this, _LZMA_instances, LZMA_Encoder_GetPosLenPrice_fn).call(this, distance, len, posState);
      optimum = encoder._optimum[len];
      if (curAndLenPrice < optimum.price) {
        optimum.price = curAndLenPrice;
        optimum.posPrev = 0;
        optimum.backPrev = distance + 4;
        optimum.prev1IsChar = 0;
      }
      if (len == encoder._matchDistances[offs]) {
        offs += 2;
        if (offs == numDistancePairs) {
          break;
        }
      }
    }
  }
  cur = 0;
  while (1) {
    ++cur;
    if (cur == lenEnd) {
      return __privateMethod(this, _LZMA_instances, Backward_fn).call(this, cur);
    }
    newLen = __privateMethod(this, _LZMA_instances, ReadMatchDistances_fn).call(this);
    numDistancePairs = encoder._numDistancePairs;
    if (newLen >= encoder._numFastBytes) {
      encoder._longestMatchLength = newLen;
      encoder._longestMatchWasFound = 1;
      return __privateMethod(this, _LZMA_instances, Backward_fn).call(this, cur);
    }
    position += 1;
    posPrev = encoder._optimum[cur].posPrev;
    if (encoder._optimum[cur].prev1IsChar) {
      posPrev -= 1;
      if (encoder._optimum[cur].prev2) {
        state = encoder._optimum[encoder._optimum[cur].posPrev2].state;
        if (encoder._optimum[cur].backPrev2 < 4) {
          state = state < 7 ? 8 : 11;
        } else {
          state = state < 7 ? 7 : 10;
        }
      } else {
        state = encoder._optimum[posPrev].state;
      }
      state = stateUpdateChar(state);
    } else {
      state = encoder._optimum[posPrev].state;
    }
    if (posPrev == cur - 1) {
      if (!encoder._optimum[cur].backPrev) {
        state = state < 7 ? 9 : 11;
      } else {
        state = stateUpdateChar(state);
      }
    } else {
      if (encoder._optimum[cur].prev1IsChar && encoder._optimum[cur].prev2) {
        posPrev = encoder._optimum[cur].posPrev2;
        pos = encoder._optimum[cur].backPrev2;
        state = state < 7 ? 8 : 11;
      } else {
        pos = encoder._optimum[cur].backPrev;
        if (pos < 4) {
          state = state < 7 ? 8 : 11;
        } else {
          state = state < 7 ? 7 : 10;
        }
      }
      opt = encoder._optimum[posPrev];
      if (pos < 4) {
        if (!pos) {
          encoder.reps[0] = opt.backs0;
          encoder.reps[1] = opt.backs1;
          encoder.reps[2] = opt.backs2;
          encoder.reps[3] = opt.backs3;
        } else if (pos == 1) {
          encoder.reps[0] = opt.backs1;
          encoder.reps[1] = opt.backs0;
          encoder.reps[2] = opt.backs2;
          encoder.reps[3] = opt.backs3;
        } else if (pos == 2) {
          encoder.reps[0] = opt.backs2;
          encoder.reps[1] = opt.backs0;
          encoder.reps[2] = opt.backs1;
          encoder.reps[3] = opt.backs3;
        } else {
          encoder.reps[0] = opt.backs3;
          encoder.reps[1] = opt.backs0;
          encoder.reps[2] = opt.backs1;
          encoder.reps[3] = opt.backs2;
        }
      } else {
        encoder.reps[0] = pos - 4;
        encoder.reps[1] = opt.backs0;
        encoder.reps[2] = opt.backs1;
        encoder.reps[3] = opt.backs2;
      }
    }
    encoder._optimum[cur].state = state;
    encoder._optimum[cur].backs0 = encoder.reps[0];
    encoder._optimum[cur].backs1 = encoder.reps[1];
    encoder._optimum[cur].backs2 = encoder.reps[2];
    encoder._optimum[cur].backs3 = encoder.reps[3];
    curPrice = encoder._optimum[cur].price;
    currentByte = __privateGet(this, _lzInWindow).getIndexByte(-1);
    matchByte = __privateGet(this, _lzInWindow).getIndexByte(-encoder.reps[0] - 1 - 1);
    posState = position & encoder._posStateMask;
    curAnd1Price = curPrice + PROB_PRICES[encoder._isMatch[(state << 4) + posState] >>> 2] + __privateMethod(this, _LZMA_instances, RangeCoder_Encoder_GetPrice_0_fn).call(this, __privateMethod(this, _LZMA_instances, LZMA_Encoder_GetSubCoder_fn).call(this, position, __privateGet(this, _lzInWindow).getIndexByte(-2)), state >= 7, matchByte, currentByte);
    nextOptimum = encoder._optimum[cur + 1];
    nextIsChar = 0;
    if (curAnd1Price < nextOptimum.price) {
      nextOptimum.price = curAnd1Price;
      nextOptimum.posPrev = cur;
      nextOptimum.backPrev = -1;
      nextOptimum.prev1IsChar = 0;
      nextIsChar = 1;
    }
    matchPrice = curPrice + PROB_PRICES[2048 - encoder._isMatch[(state << 4) + posState] >>> 2];
    repMatchPrice = matchPrice + PROB_PRICES[2048 - encoder._isRep[state] >>> 2];
    if (matchByte == currentByte && !(nextOptimum.posPrev < cur && !nextOptimum.backPrev)) {
      shortRepPrice = repMatchPrice + (PROB_PRICES[encoder._isRepG0[state] >>> 2] + PROB_PRICES[encoder._isRep0Long[(state << 4) + posState] >>> 2]);
      if (shortRepPrice <= nextOptimum.price) {
        nextOptimum.price = shortRepPrice;
        nextOptimum.posPrev = cur;
        nextOptimum.backPrev = 0;
        nextOptimum.prev1IsChar = 0;
        nextIsChar = 1;
      }
    }
    numAvailableBytesFull = __privateGet(this, _lzInWindow).getNumAvailableBytes() + 1;
    numAvailableBytesFull = 4095 - cur < numAvailableBytesFull ? 4095 - cur : numAvailableBytesFull;
    numAvailableBytes = numAvailableBytesFull;
    if (numAvailableBytes < 2) {
      continue;
    }
    if (numAvailableBytes > encoder._numFastBytes) {
      numAvailableBytes = encoder._numFastBytes;
    }
    if (!nextIsChar && matchByte != currentByte) {
      t = Math.min(numAvailableBytesFull - 1, encoder._numFastBytes);
      lenTest2 = __privateGet(this, _lzInWindow).getMatchLen(0, encoder.reps[0], t);
      if (lenTest2 >= 2) {
        state2 = stateUpdateChar(state);
        posStateNext = position + 1 & encoder._posStateMask;
        nextRepMatchPrice = curAnd1Price + PROB_PRICES[2048 - encoder._isMatch[(state2 << 4) + posStateNext] >>> 2] + PROB_PRICES[2048 - encoder._isRep[state2] >>> 2];
        offset = cur + 1 + lenTest2;
        while (lenEnd < offset) {
          encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;
        }
        curAndLenPrice = nextRepMatchPrice + (price = encoder._repMatchLenEncoder.getPrice(lenTest2 - 2, posStateNext), price + __privateMethod(this, _LZMA_instances, GetPureRepPrice_fn).call(this, 0, state2, posStateNext));
        optimum = encoder._optimum[offset];
        if (curAndLenPrice < optimum.price) {
          optimum.price = curAndLenPrice;
          optimum.posPrev = cur + 1;
          optimum.backPrev = 0;
          optimum.prev1IsChar = 1;
          optimum.prev2 = 0;
        }
      }
    }
    startLen = 2;
    for (repIndex = 0; repIndex < 4; ++repIndex) {
      lenTest = __privateGet(this, _lzInWindow).getMatchLen(-1, encoder.reps[repIndex], numAvailableBytes);
      if (lenTest < 2) {
        continue;
      }
      lenTestTemp = lenTest;
      do {
        while (lenEnd < cur + lenTest) {
          encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;
        }
        curAndLenPrice = repMatchPrice + (price_0 = encoder._repMatchLenEncoder.getPrice(lenTest - 2, posState), price_0 + __privateMethod(this, _LZMA_instances, GetPureRepPrice_fn).call(this, repIndex, state, posState));
        optimum = encoder._optimum[cur + lenTest];
        if (curAndLenPrice < optimum.price) {
          optimum.price = curAndLenPrice;
          optimum.posPrev = cur;
          optimum.backPrev = repIndex;
          optimum.prev1IsChar = 0;
        }
      } while ((lenTest -= 1) >= 2);
      lenTest = lenTestTemp;
      if (!repIndex) {
        startLen = lenTest + 1;
      }
      if (lenTest < numAvailableBytesFull) {
        t = Math.min(numAvailableBytesFull - 1 - lenTest, encoder._numFastBytes);
        lenTest2 = __privateGet(this, _lzInWindow).getMatchLen(lenTest, encoder.reps[repIndex], t);
        if (lenTest2 >= 2) {
          state2 = state < 7 ? 8 : 11;
          posStateNext = position + lenTest & encoder._posStateMask;
          curAndLenCharPrice = repMatchPrice + (price_1 = encoder._repMatchLenEncoder.getPrice(lenTest - 2, posState), price_1 + __privateMethod(this, _LZMA_instances, GetPureRepPrice_fn).call(this, repIndex, state, posState)) + PROB_PRICES[encoder._isMatch[(state2 << 4) + posStateNext] >>> 2] + __privateMethod(this, _LZMA_instances, RangeCoder_Encoder_GetPrice_0_fn).call(this, __privateMethod(this, _LZMA_instances, LZMA_Encoder_GetSubCoder_fn).call(this, position + lenTest, __privateGet(this, _lzInWindow).getIndexByte(lenTest - 1 - 1)), true, __privateGet(this, _lzInWindow).getIndexByte(lenTest - 1 - (encoder.reps[repIndex] + 1)), __privateGet(this, _lzInWindow).getIndexByte(lenTest - 1));
          state2 = stateUpdateChar(state2);
          posStateNext = position + lenTest + 1 & encoder._posStateMask;
          nextMatchPrice = curAndLenCharPrice + PROB_PRICES[2048 - encoder._isMatch[(state2 << 4) + posStateNext] >>> 2];
          nextRepMatchPrice = nextMatchPrice + PROB_PRICES[2048 - encoder._isRep[state2] >>> 2];
          offset = lenTest + 1 + lenTest2;
          while (lenEnd < cur + offset) {
            encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;
          }
          curAndLenPrice = nextRepMatchPrice + (price_2 = encoder._repMatchLenEncoder.getPrice(lenTest2 - 2, posStateNext), price_2 + __privateMethod(this, _LZMA_instances, GetPureRepPrice_fn).call(this, 0, state2, posStateNext));
          optimum = encoder._optimum[cur + offset];
          if (curAndLenPrice < optimum.price) {
            optimum.price = curAndLenPrice;
            optimum.posPrev = cur + lenTest + 1;
            optimum.backPrev = 0;
            optimum.prev1IsChar = 1;
            optimum.prev2 = 1;
            optimum.posPrev2 = cur;
            optimum.backPrev2 = repIndex;
          }
        }
      }
    }
    if (newLen > numAvailableBytes) {
      newLen = numAvailableBytes;
      for (numDistancePairs = 0; newLen > encoder._matchDistances[numDistancePairs]; numDistancePairs += 2) {
      }
      encoder._matchDistances[numDistancePairs] = newLen;
      numDistancePairs += 2;
    }
    if (newLen >= startLen) {
      normalMatchPrice = matchPrice + PROB_PRICES[encoder._isRep[state] >>> 2];
      while (lenEnd < cur + newLen) {
        encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;
      }
      offs = 0;
      while (startLen > encoder._matchDistances[offs]) {
        offs += 2;
      }
      for (lenTest = startLen; ; lenTest += 1) {
        curBack = encoder._matchDistances[offs + 1];
        curAndLenPrice = normalMatchPrice + __privateMethod(this, _LZMA_instances, LZMA_Encoder_GetPosLenPrice_fn).call(this, curBack, lenTest, posState);
        optimum = encoder._optimum[cur + lenTest];
        if (curAndLenPrice < optimum.price) {
          optimum.price = curAndLenPrice;
          optimum.posPrev = cur;
          optimum.backPrev = curBack + 4;
          optimum.prev1IsChar = 0;
        }
        if (lenTest == encoder._matchDistances[offs]) {
          if (lenTest < numAvailableBytesFull) {
            t = Math.min(numAvailableBytesFull - 1 - lenTest, encoder._numFastBytes);
            lenTest2 = __privateGet(this, _lzInWindow).getMatchLen(lenTest, curBack, t);
            if (lenTest2 >= 2) {
              state2 = state < 7 ? 7 : 10;
              posStateNext = position + lenTest & encoder._posStateMask;
              curAndLenCharPrice = curAndLenPrice + PROB_PRICES[encoder._isMatch[(state2 << 4) + posStateNext] >>> 2] + __privateMethod(this, _LZMA_instances, RangeCoder_Encoder_GetPrice_0_fn).call(this, __privateMethod(this, _LZMA_instances, LZMA_Encoder_GetSubCoder_fn).call(this, position + lenTest, __privateGet(this, _lzInWindow).getIndexByte(lenTest - 1 - 1)), true, __privateGet(this, _lzInWindow).getIndexByte(lenTest - (curBack + 1) - 1), __privateGet(this, _lzInWindow).getIndexByte(lenTest - 1));
              state2 = stateUpdateChar(state2);
              posStateNext = position + lenTest + 1 & encoder._posStateMask;
              nextMatchPrice = curAndLenCharPrice + PROB_PRICES[2048 - encoder._isMatch[(state2 << 4) + posStateNext] >>> 2];
              nextRepMatchPrice = nextMatchPrice + PROB_PRICES[2048 - encoder._isRep[state2] >>> 2];
              offset = lenTest + 1 + lenTest2;
              while (lenEnd < cur + offset) {
                encoder._optimum[lenEnd += 1].price = INFINITY_PRICE;
              }
              curAndLenPrice = nextRepMatchPrice + (price_3 = encoder._repMatchLenEncoder.getPrice(lenTest2 - 2, posStateNext), price_3 + __privateMethod(this, _LZMA_instances, GetPureRepPrice_fn).call(this, 0, state2, posStateNext));
              optimum = encoder._optimum[cur + offset];
              if (curAndLenPrice < optimum.price) {
                optimum.price = curAndLenPrice;
                optimum.posPrev = cur + lenTest + 1;
                optimum.backPrev = 0;
                optimum.prev1IsChar = 1;
                optimum.prev2 = 1;
                optimum.posPrev2 = cur;
                optimum.backPrev2 = curBack + 4;
              }
            }
          }
          offs += 2;
          if (offs == numDistancePairs) {
            break;
          }
        }
      }
    }
  }
  return 1;
};
LZMA_Encoder_GetPosLenPrice_fn = function(pos, len, posState) {
  const encoder = __privateGet(this, _compressor).chunker.encoder;
  let price, lenToPosState = getLenToPosState(len);
  if (pos < 128) {
    price = encoder._distancesPrices[lenToPosState * 128 + pos];
  } else {
    const position = (lenToPosState << 6) + this.GetPosSlot2(pos);
    price = encoder._posSlotPrices[position] + encoder._alignPrices[pos & 15];
  }
  return price + encoder._lenEncoder.getPrice(len - 2, posState);
};
GetPureRepPrice_fn = function(repIndex, state, posState) {
  const encoder = __privateGet(this, _compressor).chunker.encoder;
  let price;
  if (!repIndex) {
    price = PROB_PRICES[encoder._isRepG0[state] >>> 2];
    price += PROB_PRICES[2048 - __privateGet(this, _compressor).chunker.encoder._isRep0Long[(state << 4) + posState] >>> 2];
  } else {
    price = PROB_PRICES[2048 - __privateGet(this, _compressor).chunker.encoder._isRepG0[state] >>> 2];
    if (repIndex == 1) {
      price += PROB_PRICES[__privateGet(this, _compressor).chunker.encoder._isRepG1[state] >>> 2];
    } else {
      price += PROB_PRICES[2048 - __privateGet(this, _compressor).chunker.encoder._isRepG1[state] >>> 2];
      price += getBitPrice(__privateGet(this, _compressor).chunker.encoder._isRepG2[state], repIndex - 2);
    }
  }
  return price;
};
GetRepLen1Price_fn = function(posState) {
  const encoder = __privateGet(this, _compressor).chunker.encoder;
  const repG0Price = PROB_PRICES[encoder._isRepG0[encoder._state] >>> 2];
  const rep0LongPrice = PROB_PRICES[encoder._isRep0Long[(encoder._state << 4) + posState] >>> 2];
  return repG0Price + rep0LongPrice;
};
MovePos_fn = function(num) {
  if (num > 0) {
    __privateMethod(this, _LZMA_instances, Skip_fn).call(this, num);
    __privateGet(this, _compressor).chunker.encoder._additionalOffset += num;
  }
};
ReadMatchDistances_fn = function() {
  let lenRes = 0;
  const encoder = __privateGet(this, _compressor).chunker.encoder;
  encoder._numDistancePairs = __privateMethod(this, _LZMA_instances, GetMatches_fn).call(this);
  if (encoder._numDistancePairs > 0) {
    lenRes = encoder._matchDistances[encoder._numDistancePairs - 2];
    if (lenRes == encoder._numFastBytes) {
      lenRes += __privateGet(this, _lzInWindow).getMatchLen(lenRes - 1, encoder._matchDistances[encoder._numDistancePairs - 1], 273 - lenRes);
    }
  }
  encoder._additionalOffset += 1;
  return lenRes;
};
ReleaseMFStream_fn = function() {
  const encoder = __privateGet(this, _compressor).chunker.encoder;
  if (encoder._matchFinder && encoder._needReleaseMFStream) {
    encoder._matchFinder._stream = null;
    encoder._needReleaseMFStream = 0;
  }
};
ReleaseStreams_fn = function() {
  __privateMethod(this, _LZMA_instances, ReleaseMFStream_fn).call(this);
  __privateGet(this, _compressor).chunker.encoder._rangeEncoder.stream = null;
};
LZMA_Encoder_GetSubCoder_fn = function(pos, prevByte) {
  const subCoder = __privateGet(this, _compressor).chunker.encoder._literalEncoder.getSubCoder(pos, prevByte);
  return { decoders: subCoder.decoders };
};
RangeCoder_Encoder_GetPrice_0_fn = function(encoder, matchMode, matchByte, symbol) {
  let bit, context = 1, i = 7, matchBit, price = 0;
  if (matchMode) {
    for (; i >= 0; --i) {
      matchBit = matchByte >> i & 1;
      bit = symbol >> i & 1;
      price += getBitPrice(encoder.decoders[(1 + matchBit << 8) + context], bit);
      context = context << 1 | bit;
      if (matchBit != bit) {
        --i;
        break;
      }
    }
  }
  for (; i >= 0; --i) {
    bit = symbol >> i & 1;
    price += getBitPrice(encoder.decoders[context], bit);
    context = context << 1 | bit;
  }
  return price;
};
MakeAsChar_fn = function(optimum) {
  optimum.backPrev = -1;
  optimum.prev1IsChar = 0;
};
MakeAsShortRep_fn = function(optimum) {
  optimum.backPrev = 0;
  optimum.prev1IsChar = 0;
};
ReverseGetPrice_fn = function(encoder, symbol) {
  let bit, m = 1, price = 0;
  for (let i = encoder.numBitLevels; i != 0; i -= 1) {
    bit = symbol & 1;
    symbol >>>= 1;
    price += getBitPrice(encoder.models[m], bit);
    m = m << 1 | bit;
  }
  return price;
};
GetProcessedSizeAdd_fn = function() {
  const processedCacheSize = add64(fromInt64(__privateGet(this, _compressor).chunker.encoder._rangeEncoder.cacheSize), __privateGet(this, _compressor).chunker.encoder._rangeEncoder.position);
  return add64(processedCacheSize, [4, 0]);
};
decodeString_fn = function(utf) {
  let j = 0, x, y, z, l = utf.length, buf = [], charCodes = [];
  for (let i = 0; i < l; ++i, ++j) {
    x = utf[i] & 255;
    if (!(x & 128)) {
      if (!x) {
        return utf;
      }
      charCodes[j] = x;
    } else if ((x & 224) == 192) {
      if (i + 1 >= l) {
        return String.fromCharCode(...utf);
      }
      y = utf[++i] & 255;
      if ((y & 192) != 128) {
        return String.fromCharCode(...utf);
      }
      charCodes[j] = (x & 31) << 6 | y & 63;
    } else if ((x & 240) == 224) {
      if (i + 2 >= l) {
        return utf;
      }
      y = utf[++i] & 255;
      if ((y & 192) != 128) {
        return utf;
      }
      z = utf[++i] & 255;
      if ((z & 192) != 128) {
        return utf;
      }
      charCodes[j] = (x & 15) << 12 | (y & 63) << 6 | z & 63;
    } else {
      return utf;
    }
    if (j == 16383) {
      buf.push(String.fromCharCode.apply(String, charCodes));
      j = -1;
    }
  }
  if (j > 0) {
    charCodes.length = j;
    buf.push(String.fromCharCode.apply(String, charCodes));
  }
  return buf.join("");
};

// node_modules/lzma1/lib/index.js
function compress(data, mode = 5) {
  const input = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
  const result = new LZMA().compress(input, mode);
  return new Uint8Array(result);
}
function compressString(data, mode = 5) {
  const compressedData = new LZMA().compressString(data, mode);
  return new Uint8Array(compressedData);
}
function decompress(data) {
  const input = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
  const decompressedData = new LZMA().decompress(input);
  return new Uint8Array(decompressedData);
}
function decompressString(data) {
  return new LZMA().decompressString(data);
}
export {
  CRC32_TABLE,
  LZMA,
  compress,
  compressString,
  decompress,
  decompressString
};
/*! Bundled license information:

lzma1/lib/index.js:
  (**
   * @license
   * Copyright Filip Seman
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=lzma1.js.map
